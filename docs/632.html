<html>
<head>
<title>JUnit vs TestNG: Which Testing Framework Should You Choose? | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>JUnit vs TestNG:应该选择哪个测试框架？装具</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/junit-vs-testng#0001-01-01">https://www.harness.io/blog/junit-vs-testng#0001-01-01</a></blockquote><div><p>JUnit 和 TestNG 的特性和用例的比较。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p><strong> JUnit vs TestNG:测试框架对决</strong></p><p>在平衡的开发团队中，测试是软件发布周期不可分割的一部分。事情并不总是这样。单元测试、集成测试、系统测试和其他测试并不总是存在。今天，我们很幸运处在一个测试很重要的时代，并且大多数涉众都知道测试的价值。</p><p>在本文中，我们将测试放在中心位置，并通过 JUnit 和 TestNG 的视角探索 Java 测试，同时比较它们的主要特性和用例。<br/></p><h2>1.满足框架</h2><p>JUnit 和 TestNG 无疑是最流行的测试框架。事实上，当我们调查 GitHub 的顶级 Java 项目使用的库时，这两个项目都进入了前 20 名。</p><p>JUnit 在 62%的项目中排名第一，TestNG 排在第 20 位，占 6%。<a href="https://mvnrepository.com/"> Maven 知识库</a>显示了类似的结果，JUnit 以 42，484 次使用位居流行榜第一，TestNG 以 3，873 次使用位居第十五。这也是因为在许多 Maven 原型中默认添加了 JUnit。</p><h3>版本和一些最近的历史</h3><p>最新的 JUnit 版本是 4.12，于 2014 年 12 月发布，<a href="http://junit.org/junit5/"> JUnit 5 </a>预计将于 2016 年末达到 GA 状态。这很快就会实现，我们也希望它能成为会议的热门话题。</p><p>JUnit 是采用测试驱动开发的驱动因素之一，最初是由 Kent Beck 和 Erich Gamma 开发的。2013 年，火炬传递给了<a href="https://twitter.com/junitteam"> JUnit 团队。</a></p><p>一个早期的 JUnit 5 版本已经可供你试用，你也可以在<a href="https://github.com/junit-team/junit5/"> GitHub </a>上为它的开发做出贡献。一个有趣的事实是，新版本的开发是通过众筹活动实现的。</p><p>至于由 Cedric Beust 创建的 TestNG，在撰写本文时的最新版本是 2015 年 12 月的 6.9.10。它第一次出现在 JUnit 3 还存在的时候，并提供了当时不存在的新特性，其设计专注于更广泛的测试用例。其中一些特性，如注释的使用，是在 JUnit 4 中添加的，这是我们在这里重点关注的版本，并展望了即将到来的 JUnit 5 版本。</p><h2>2.写作测试</h2><p>TestNG 和 JUnit 都基于类似于 Java 断言的行为，Java 断言是在 Java 4 中添加的。而且我们可以直接使用断言，所以……为什么要用测试框架呢？</p><p>从简单的 Java 断言开始很容易受到诱惑，但是随着项目的增长，测试很快变得不简单，使用框架来管理它是非常有意义的。此外，学习曲线非常快，主要概念简单而强大。JUnits 代码库是如此的轻量级，以至于 Martin Fowler 的名言被引用:<em>“在软件开发领域，从来没有如此多的代码行带来如此多的好处。”</em></p><p><em>‍</em>JUnit 和 TestNG 都遵循<a href="https://en.wikipedia.org/wiki/XUnit"> xUnit </a>约定，但是有一些区别我们想在这里强调一下:组、并行性、参数化测试和依赖性。</p><h3>组</h3><p>TestNG 为 JUnit 提供了额外的注释。可能最值得注意的是在测试用例组之前/之后运行代码的能力。此外，单个测试可以属于多个组，然后在不同的上下文中运行(比如慢速或快速测试)。它实际上是测试用例与测试套件之间的另一层:<br/></p><p>@Test(groups = {“神智健全”、“精神错乱”})</p><p>JUnit 类别中也有类似的特性，但是缺少@ before groups/@ after groups TestNG 注释，该注释允许初始化测试/取消测试。顺便说一句，看起来 JUnit 5 将弃用类别，并引入一个名为标签的新概念:</p><h6>@ Tag(" sanity ")@ Tag(" anism ")void test something(){...}</h6><p>但是现在看来，还看不到@BeforeTag / @AfterTag 注释。</p><h3>平行</h3><p>如果您想在多个线程上并行运行同一个测试，TestNG 为您提供了一个简单易用的注释，而 JUnit 并没有提供一个现成的简单方法。TestNG 的实现应该是这样的:<br/></p><h6>@Test(threadPoolSize = 3，invocationCount = 9)public void Test something(){...}</h6><p>这意味着，同一测试的 3 个线程和 9 次调用。如果您在 TestNG 的 XML 运行配置中指定，您也可以并行运行整个套件。而使用 JUnit，您必须编写一个定制的 runner 方法，并多次输入相同的测试参数。这就引出了下一个要点。</p><h3>参数化/数据驱动测试</h3><p>这是将不同的测试输入提供给同一个测试用例的问题，TestNG 和 JUnit 都解决了这个问题，但是使用了不同的方法。基本思想是一样的，创建一个包含参数的 2D 数组 Object[][]。</p><p>然而，除了通过代码提供参数之外，TestNG @DataProvider 还可以支持 XML 来输入数据、CSV 甚至纯文本文件。JUnit 中存在而 TestNG 缺少的一个特性是在几个参数之间使用不同组合的能力。这为长参数列表提供了一个快捷方式，并在 JUnit 理论中进行了解释。</p><h3>组和方法之间的依赖关系</h3><p>由于 JUnit 是为单元测试而构建的，而 TestNG 考虑了更多的测试，所以它们在测试之间的依赖关系上也有所不同。<br/> TestNG 允许你声明测试之间的依赖，如果依赖测试没有通过，就跳过它们:<br/></p><h6>@ Test(dependsOnMethods = { " dependOnSomething " })public void Test something(){...}</h6><p>这个功能在 JUnit 中不存在，但是可以使用<a href="https://github.com/junit-team/junit4/wiki/Assumptions-with-assume">假设</a>来模拟。失败的假设会导致被忽略的测试被跳过。<strong>底线:</strong>不同的开发人员对他们选择的框架会有不同的期望。与 JUnit 相比，TestNG 似乎提供了更大的灵活性。</p><h2>3.运行测试</h2><p>当编写测试时，我们不需要包含一个 main 方法，因为框架用它们自己的 main 方法为我们运行这些测试，该方法管理单个测试的执行。</p><p>如果您确实需要一个定制的跑步者，JUnit 提供了@RunWith 注释，允许您使用自己的跑步者。使用 TestNG 也可以绕过默认的 runner，但是没有使用 JUnit 那么简单。然而值得注意的是，TestNG 支持 XML 运行配置，这在许多用例中被证明是有用的。<br/>至于实际运行测试，这两个框架都支持通过 ANT 运行的命令行界面，并且都有插件可供您选择，具有非常相似的功能。尽管 JUnit 与 JDT (Eclipse Java 开发工具)一起上市，但它确实存在。</p><p><strong>底线:</strong> JUnit 的@RunWith 注释更加灵活。</p><h2>4.报告结果</h2><p>很多人对测试结果感兴趣。运行它们的不仅仅是开发商。这就是报告发挥作用的时候，两个框架都有这个问题的答案。<br/>默认情况下，TestNG 报告会生成到一个测试输出文件夹中，该文件夹包含 html 报告，其中包含所有测试数据、通过/失败/跳过、运行时间、使用的输入以及完整的测试日志。此外，它还将所有内容导出到一个 XML 文件中，该文件可用于构建您自己的报告模板。<br/>在 JUnit 方面，所有这些数据也可以通过 XML 获得，但没有现成的报告，您需要依赖插件。</p><p><strong>底线:</strong> TestNG 提供现成的报告，JUnit 只将其导出到 XML</p><h2>5.自动化测试运行</h2><p>这两个框架都可以用来通过 Jenkins、Travis CI 和 Teamcity 等工具创建自动化测试运行。插件也可用于从测试数据中创建报告，并将其发送给任何可能对您选择的渠道感兴趣的人。比如和 Jenkins 一起使用 TestNG，和 email、Slack 整合。我们之前也写过一些对开发者最有用的 Slack 集成，看看吧。<br/> <br/> <strong>底线:</strong>自动化为赢。JUnit 和 TestNG 可能都有您正在寻找的集成。</p><h2>6.取消失败的测试</h2><p>哎呀，我们考试失败了。接下来会发生什么？如果足够细，找到失败的原因应该相对容易，但是现实往往对我们有不同的计划。当最重要的元素是选择您的攻击计划时，有许多不同的方法可以在阶段和产品中测试我们的代码。我们的大部分用户还建立了 Harness 服务可靠性管理来监控他们的测试环境。每当测试失败时，他们能够查看导致失败的变量，包括所有导致失败的方法。<br/></p><p><strong>底线:</strong>为了让您的环境更上一层楼，请查看服务可靠性管理，了解它如何帮助您排除错误。</p><h2>7.模仿、匹配和其他框架</h2><p>一篇关于 Java 测试、JUnit 和 TestNG 的博客文章如果不提到一些补充的测试库是不完整的。<br/>在这一部分，我们将根据<a href="https://www.overops.com/the-top-100-java-libraries-in-2016-after-analyzing-47251-dependencies/"> GitHub 的顶级 Java 项目</a>对这些最受欢迎的库进行快速概述。</p><h3>嘲弄的</h3><p>一个好的实践是独立地运行单元测试，但是如果你测试的组件依赖于其他复杂的对象呢？这就是模仿的用武之地，我们可以创建模仿对象来模仿系统其他部分的行为:</p><h3>相称的</h3><p>JUnit 和 TestNG 提供的断言非常基本，使用匹配器有助于它们的可读性，并增加了更多功能供您选择:</p><h3>还有…斯波克</h3><p>Spock 是一个基于 JUnit 的新兴 Groovy 测试框架。背后的想法是用一个简单的 Groovy DSL 将这个测试库的生态系统整合到一个框架中。我们已经在一篇关于 Groovy 及其 Java 用途的文章中介绍了它的一些功能。<br/> <br/> <strong>底线:</strong>测试通常不会止步于单个框架，去了解游戏中的其他库。</p><h2>8.社区</h2><p>JUnit 有更多的历史和更大的用户群，它基本上定义了 Java 单元测试的标准。因此，它拥有最大的用户群，你可能遇到的任何问题都很容易找到答案或找到人来询问。TestNG 的用户可能会少一些，但它的社区并不差(尽管它的网站可能需要改头换面)。而且……两者都可以从一些标志指南中受益。人群中有设计师吗？</p><p><em>stack overflow 上标记有 junit 和 testng 的问题</em></p><p>以下是一些对 JUnit 更有用的链接:</p><p>和测试:</p><p><strong>底线:</strong>你不会因为他们中的任何一个而迷失。</p><h2>最后的想法</h2><p>Java 测试已经走过了漫长的道路，我们很高兴处在一个测试很重要的时代。这里的要点是创建有意义的测试。</p></div></div>    
</body>
</html>