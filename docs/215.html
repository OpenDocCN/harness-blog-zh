<html>
<head>
<title>Helm Support for Harness Continuous Delivery | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用于线束连续输送的舵支架|线束</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/helm-support-for-harness-continuous-delivery#0001-01-01">https://www.harness.io/blog/helm-support-for-harness-continuous-delivery#0001-01-01</a></blockquote><div><p>我们已经升级了我们的头盔集成，以提供金丝雀和蓝绿色部署，自动回滚，等等！现在就去看看。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>Helm 已经成为一种广泛流行的打包、分发和管理Kubernetes应用程序的方式。在Harness，我们看到越来越多的客户已经在使用Helm，它的用途多种多样。在本帖中，我们将讨论Harness如何为打包为Helm Charts的微服务/应用提供一流的<a href="https://harness.io/products/continuous-delivery/" target="_blank">持续交付解决方案</a>，并回顾我们为提供最佳Helm支持所做的增强。</p><h2>舵图的淡黄色和蓝绿色部署</h2><p>虽然Helm能够很好地将多个Kubernetes资源打包到Kubernetes应用程序中，但它在部署和回滚方面提供的功能有限。Helm项目的目标不是解决持续交付，实施像<a href="https://harness.io/blog/blue-green-canary-deployment-strategies/" target="_blank"> Canary和Blue-Green </a>这样的高级部署策略并不简单。在许多情况下，我们看到人们使用聪明的模板技巧来实现它们。这通常需要手动使用不同的值文件运行helm CLI。</p><p>在Harness平台中，我们为金丝雀和蓝绿色部署策略构建了一流的支持。我们还会进行部署状态检查，如果需要，还会进行自动回滚。我们的实现非常灵活，任何一组Kubernetes资源都可以作为服务的一部分进行部署。通过我们的舵集成，我们旨在为今天已经使用舵图表的客户带来相同的功能集。</p><p>下图说明了canary部署策略。Harness workflow创建了一个并行canary部署。当canary部署通过所有验证时，主部署将升级。实现这一点不需要改变规格。</p><figure class="w-richtext-figure-type- "><figcaption>Figure 1: Harness Orchestrated Canary Deployment</figcaption></figure><figure class="w-richtext-figure-type- "><figcaption>Figure 2: Example Run of Canary Workflow</figcaption></figure><p>同样，下图说明了蓝绿策略。线束工作流创建两个并行部署(蓝色和绿色插槽)。服务对象(即主要服务)用于跟踪哪个部署服务于生产流量。新服务被部署到另一个插槽中。一旦所有测试都通过了，就可以通过更新服务将生产流量路由到新的Pods。在任何时候，服务都可以更新为指向一个较旧的版本，以实现即时回滚。</p><figure class="w-richtext-figure-type- "><figcaption>Figure 3: Harness Orchestrated Blue-Green Deployment</figcaption></figure><p>在我们的方法中，我们使用Helm从存储库和模板渲染中获取图表。一旦我们将Helm chart渲染到Kubernetes资源中，我们就可以像上面描述的那样编排一个金丝雀或蓝绿色的部署，并在出现故障时自动回滚。所有这些都不需要改变微服务的图表规格。</p><h2>使用Helm跨环境部署服务</h2><p>使用Helm模板，很容易将图表部署到多个环境中。特定于环境的配置保存在值覆盖文件中。尽管如此，仍然需要管理特定于环境的秘密和集群配置，例如Kubeconfig。当您扩展到更多环境时，跟踪哪些覆盖了哪些群集变得非常困难。</p><p>Harness提供了环境抽象，所有这些都可以在环境资源中进行组织。当服务被部署到特定环境时，正确的集群具有正确的配置和值覆盖。</p><figure class="w-richtext-figure-type- "><figcaption>Figure 4: Harness Environment Encapsulates Cluster Details &amp; Configuration Specific to an Environment</figcaption></figure><h2>舵部署的自动回滚</h2><p>Helm安装/升级命令不跟踪展开的状态。在头盔升级完成后，仍然需要手动跟踪展示的状态。回滚也是手动操作。线束跟踪部署的部署状态，并可以在需要时自动回滚。</p><h2>其他头盔增强功能</h2><p>一些客户在Git存储库中维护他们的Helm图表，但是发现维护一个单独的Helm存储库很麻烦。许多人使用亚马逊S3和GCS桶来存储图表包。</p><p>许多人只使用Helm进行打包和模板化，而其他人则利用Helm客户端来管理版本的安装/升级/回滚。我们从一些客户那里了解到他们在使用tiller时遇到的挑战，他们更喜欢使用客户端模式。</p><p>基于这些经验，我们改进了舵面集成的以下方面:</p><h3>舵库连接器</h3><p>我们已经为头盔库添加了一个连接器。HTTP服务器、亚马逊S3和基于Google云存储的存储库都支持开箱即用。</p><figure class="w-richtext-figure-type- "/><h3>来自源存储库的舵图</h3><p>舵图可以直接从Git存储库中的图表源获取。这避免了维护单独的Helm存储库服务器的开销。<br/></p><figure class="w-richtext-figure-type- "/><h3>远程值覆盖</h3><p>服务和环境级别的值覆盖现在可以存储在远程Git存储库中。这使得GitOps流和环境级别覆盖可以保存在与图表相同的存储库中。<br/></p><figure class="w-richtext-figure-type- "/><h3>支持仅客户端使用头盔</h3><p>我们增加了对头盔客户端模式的支持。许多人更喜欢客户端模式，因为tiller在设置、RBAC和可用性方面带来了挑战。在这种模式下，Helm client用于从存储库中获取图表并呈现模板。部署是通过标准的kubectl机制完成的。这避免了对舵柄的依赖。</p><p>我们希望这些增强功能对您有用。</p><p>问候，<br/>安舒尔，瓦伊巴夫，伊桑特，文卡特什&amp;普内特</p></div></div>    
</body>
</html>