<html>
<head>
<title>Simplifying Docker Multi-Stage Builds | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>简化Docker多阶段构建|装具</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/docker-multi-stage-build#0001-01-01">https://www.harness.io/blog/docker-multi-stage-build#0001-01-01</a></blockquote><div><p>尽管采用了云架构，但许多公司并没有取得最佳效果。了解如何在云中使用Drone简化您的多步Dockerfile部署。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>在过去几年中，许多组织已经开始采用云原生架构。尽管采用了这些架构，许多公司并没有取得最佳结果。但这是为什么呢？一个原因是我们坚持构建和部署应用程序的传统方法。由于我们生活在云原生时代，我们构建的每个应用程序都应该可以通过容器化部署到任何云上。</p><p>为了演示我在本教程中的意思，我将使用next.js <a href="https://github.com/vercel/next.js/tree/canary/examples/with-docker">和-docker-example </a>。你可以从我的<a href="https://github.com/kameshsampath/nextjs-with-drone">博客演示源</a>中克隆这个演示源。</p><p class="w-embed"><code class="code--embed"> ```shell<br/> git clone https://github.com/kameshsampath/nextjs-with-drone<br/> export PROJECT_HOME=$(pwd)/nextjs-with-drone<br/> cd $PROJECT_HOME<br/> ````</code></p><p>这里的目标是将这个应用程序部署到云平台上。以下是实现这一目标的步骤:</p><ol role="list"><li>使用Dockerfile文件将应用程序容器化</li><li>将它们推送到任意一个集装箱注册中心，如<a href="https://github.com/features/packages"> Github </a>、<a href="https://quay.io"> Quay.io </a>等。</li><li>将容器化的应用部署到云平台，如<a href="https://kubernetes.io/"> Kubernetes </a>、<a href="https://docs.aws.amazon.com/AmazonECS/latest/userguide/what-is-fargate.html"> AWS Fargate </a>、<a href="https://cloud.google.com/run"> Google Cloud Run </a>等。</li></ol><h2>入门指南</h2><p>让我们从Dockerfile开始分析我们的代码:</p><h6><br/>` ` docker file<br/>FROM node:16-alpine AS deps<br/>运行apk add-no-cache libc 6-compat<br/>WORKDIR/app<br/>COPY package . JSON yarn . lock。/ <br/>运行yarn install-freezed-lock file<br/><br/>FROM node:16-alpine AS builder<br/>work dir/app<br/>COPY-FROM = deps/app/node _ modules。/node_modules <br/>复制。。<br/><br/>RUN yarn build<br/><br/>FROM NODE:16-alpine AS runner<br/>work dir/app<br/><br/>ENV NODE _ ENV production<br/><br/>RUN add group-system-GID 1001 nodejs<br/>RUN adduser-system-uid 1001 nextjs<br/><br/>COPY-FROM = builder/app/public。/public<br/>COPY-from = builder/app/package . JSON。/package . JSON<br/><br/>COPY-from = builder-chown = nextjs:nodejs/app/。下一个/独立。/<br/>COPY-from = builder-chown = nextjs:nodejs/app/。下一个/静态<br/>。/.下一个/静态<br/> ‍ <br/>用户next js<br/><br/>expose 3000<br/>env port 3000<br/><br/>cmd[" node "，" server . js "]<br/>` `<br/></h6><p>这是一个多步骤的构建，对于不熟悉这些过程的人来说可能很困难。此外，如果其中一个步骤失败了，那么我们就很难知道它失败的原因。但是让我们停下来想一想:难道我们不觉得所有这些命令都应该按顺序流动，每个步骤都按定义的顺序运行，一个接一个吗？如果你也得出这个结论，那么你和我一起迈出了持续集成(CI)的第一步。</p><h2>为什么构建不同于CI</h2><p>我们经常混淆构建和CI。火上浇油的是，市场上的工具也可能相当混乱，为构建工具提供插件和扩展，例如yarn或Apache Maven，以将构建与CI混合在一起。我是单一责任原则的忠实拥护者。当我们将其应用于应用构建和部署流程时，云原生应用中的构建应该将应用构建到容器映像，然后移交其他步骤(如推送至注册表、部署到云原生平台等。)到CI工具。</p><p>考虑到这一点，当我们考虑CI时，我已经向您介绍了两个重要的术语:</p><ul role="list"><li><strong>步骤</strong>——只做一件事的东西，比如构建应用，推送注册等。</li><li><strong>管道</strong>——多步并作拥抱CI</li></ul><p>在我进一步探讨如何从多步dockerfile构建转移到CI管道之前，让我们先来看看一个开源工具，<a href="https://www.drone.io/"> Drone </a>，一个云原生的自助式CI平台。虽然它已经有10年的历史，但Drone仍然提供了一个成熟的CI系统，利用了云原生架构的可伸缩性和容错特性。Drone以其简单、解耦和声明性的特性而闻名，使我们能够定义一些易于理解的健壮管道。</p><h2>将dockerfile添加到管道</h2><p>让我们开始将我们的多步docker文件移动到一个无人管道。这就像Dockerfile Drone如何使用一个名为<em> .drone.yml </em>的YAML文件，它通常位于项目源代码的根目录中。你可以在<a href="https://docs.drone.io/">文档</a>页面上阅读更多关于无人机的信息。在接下来的部分，我们将开始组装<em> .drone.yml </em>。</p><p>对于编写. drone.yml的第一步，我们需要以下信息:</p><ul role="list"><li><strong>应用程序的名称是什么？</strong> nextjs-with-drone</li><li><strong>我们将使用什么类型的建筑？</strong>码头工人</li><li><strong>我们会使用什么样的无人机资源？</strong>我们将使用<a href="https://docs.drone.io/pipeline/overview/">管道</a>，因为我们有多个步骤。</li></ul><ul role="list"><li>我们将在什么样的平台上构建？对于大多数容器情况，平台将是Linux，操作系统架构将是amd64或arm64。</li></ul><p>有了这些信息，我们的. drone.yml将如下所示:</p><p class="w-embed"><code class="code--embed"> ```yaml ---kind: pipeline type: docker name: nextjs-with-drone  platform: os: linux   arch: arm64 ``` </code></p><p>所以现在我们已经填满了管道的前几条线。下一个任务是从docker文件中确定我们的管道步骤，我们可以推断出我们有以下三个步骤:</p><ol role="list"><li><strong>deps</strong>–构建节点依赖关系</li><li><strong>构建器</strong>–构建node.js应用程序</li><li><strong>runner</strong>–应用程序的包，作为linux容器映像</li></ol><p>‍</p><p>现在让我们开始添加这些步骤作为无人机管道<a href="https://docs.drone.io/pipeline/exec/syntax/steps/">步骤</a>。无人机流水线步骤至少需要以下细节:</p><ul role="list"><li>该步骤的名称是什么？</li><li>这个步骤将运行什么容器映像？</li><li>哪些命令将在容器内执行它？</li></ul><p>我们从docker文件中获得了所有这些必需的信息，所以让我们开始将它们作为无人机步骤添加到. drone.yml中:</p><p class="w-embed"><code class="code--embed"> ```yaml<br/> ---<br/> kind: pipeline<br/> type: docker<br/> name: nextjs-with-drone<br/> <br/> platform:  <br/> os: linux  <br/> arch: arm64<br/> <br/> steps:  <br/> - name: yarn-install    <br/> image: docker.io/node:lts-alpine    <br/> commands:  	<br/> - apk add --no-cache libc6-compat  	<br/> - cd /app-build  	<br/> - cp /drone/src/package.json ./  	<br/> - cp /drone/src/yarn.lock ./  	<br/> - yarn install --frozen-lockfile  	<br/> - cp -r /drone/src/* .  	<br/> - yarn build    <br/> volumes:  	<br/> - name: app-build-dir    	<br/> path: /app-build  <br/> - name: build-image   <br/>  image: gcr.io/kaniko-project/executor:debug    <br/> commands:  	<br/> - &gt;    	<br/> /kaniko/executor    	<br/> --context /app-build    	<br/> --dockerfile Dockerfile    	<br/> --destination ttl.sh/nextjswithdrone/my-app:1h     <br/> volumes:  	<br/> - name: app-build-dir    	<br/> path: /app-build<br/> volumes:  <br/> - name: app-build-dir     <br/> temp: {}<br/> ``` </code></p><p>您可能已经注意到，该步骤的commands属性只是RUN，复制Dockerfile中的指令。这些被翻译成等价的Linux命令。我们添加了一个名为volumes的额外属性，它主要用于将任何目录或文件挂载到容器中。在这种情况下，我们使用它来与另一个步骤共享构建工件。</p><h2>最后一步:清理</h2><p>最后一步是清理docker文件，这样我们只有一个步骤来构建最终的容器映像。清理后的docker文件如下所示:</p><p class="w-embed"><code class="code--embed"> ```dockerfile<br/> FROM node:lts-alpine<br/> LABEL org.opencontainers.image.source <br/> https://github.com/kameshsampath/fruits-app-ui<br/> <br/> WORKDIR /app<br/> <br/> ENV NODE_ENV production<br/> <br/> RUN adduser --system --uid 1001 nextjs<br/> <br/> RUN cp -r /app-build/.next/standalone/. ./ \   <br/> &amp;&amp; cp -r /app-build/public ./ \   <br/> &amp;&amp; cp /app-build/package.json ./package.json \   <br/> &amp;&amp; cp -r /app-build/.next/static ./.next/<br/> <br/> RUN chown -R 1001:0 /app \  <br/> &amp;&amp; chmod -R g+=wrx /app<br/> <br/> RUN ls -ltra /app<br/> <br/> USER nextjs<br/> <br/> EXPOSE 3000<br/> <br/> ENV PORT 3000<br/> <br/> CMD ["yarn", "start"]<br/> ``` </code></p><p>现在，您已经准备好对您的应用程序进行第一次CI构建了！下载<a href="https://docs.drone.io/cli/"> Drone CLI </a>并将其添加到您的$PATH中。如果运行以下命令一切顺利，那么您应该会看到类似于drone版本1.5.0的输出:</p><p class="w-embed"><code class="code--embed"> ```shell<br/> drone --version<br/> ``` </code></p><p>让我们运行管道:</p><p class="w-embed"><code class="code--embed"> ```shell<br/> drone exec<br/> ``` </code></p><p>如果一切顺利，那么您的容器映像将被推送到<a href="https://ttl.sh"> ttl.sh </a>存储库。让我们在本地运行容器，看看我们的构建是否有效:</p><p class="w-embed"><code class="code--embed"> ```shell<br/> docker run -it --rm -p 3000:3000 ttl.sh/nextjswithdrone/my-app:1h<br/> ``` </code></p><p>当您在浏览器中打开<a href="http://localhost:3000"> http://localhost:3000 </a>时，您应该会看到欢迎屏幕:</p><p>‍</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>瞧啊。您已经向使用<a href="https://harness.io/blog/continuous-delivery/best-practices-software-delivery/" target="_blank">软件交付最佳实践</a>实践CI迈出了第一步。现在，您可以对管道进行改进或添加额外的步骤，使其部署到容器云平台。</p><p>准备好开始使用无人机桌面了吗？<a href="https://docs.drone.io/">立即下载免费试用版</a>。</p></div><div class="blog-code-embed w-richtext"><p><script type="application/ld+json"/></p><p>{</p><p>" @context": "https://schema.org "，</p><p>" @type": "FAQPage "，</p><p>" mainEntity": [{</p><p>" @type ":"问题"，</p><p>" name ":"什么是多级dockerfile？",</p><p>" acceptedAnswer": {</p><p>" @type ":"回答"，</p><p>" text ":"多阶段dockerfile是一种使用一个dockerfile来构建容器映像的方法，该方法使用一个步骤在另一个步骤中的构建输出。"</p><p>}</p><p>},{</p><p>" @type ":"问题"，</p><p>" name ":"多级构建的优势是什么？",</p><p>" acceptedAnswer": {</p><p>" @type ":"回答"，</p><p>"文本": "</p><ul role="list"><li>在一个地方构建一个容器映像</li><li>能够在一个上下文中轻松地将工件从一个阶段复制到另一个阶段”</li></ul><p>},{</p><p>" @type ":"问题"，</p><p>" name ":"何时使用多阶段构建？",</p><p>" acceptedAnswer": {</p><p>" @type ":"回答"，</p><p>" text ":"当您需要使用相同的构建上下文来构建多个工件时。如果不使用多级构建，您可能需要使用多个docker文件和构建。</p><p>}</p><p>}]</p><p>}</p><p/><p>‍</p><p>‍</p></div></div>    
</body>
</html>