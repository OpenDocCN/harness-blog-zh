# 迁移到 Bazel 作为构建工具——为什么我们离开 Maven | Harness

> 原文：<https://www.harness.io/blog/migrating-bazel-build-tool>

我们与 Maven 一起回顾了我们面临的挑战，为什么我们决定选择 Bazel，我们如何迁移，以及我们看到了什么结果。

在 Harness，我们完整的代码库在一个 GitHub repo 中。它由大约 500 万行代码和 100 多个相互依赖的模块组成。我们开始观察到构建时间每周都在增加，而我们现有的构建工具(Maven)无法随着我们不断增长的需求而扩展。在这篇博文中，我们将回顾我们在 Maven 上面临的挑战，为什么我们决定使用 Bazel，我们如何迁移，以及我们看到了什么结果。

## Maven 的挑战

*   **缺乏增量构建支持** *—* 当我们对数百个模块中的一个进行小的改动时，Maven 通常需要干净的构建。作为一个快速发展的组织，我们以很快的速度加入了新的模块。随着代码的增加，每次构建所花费的时间会显著增加。
*   **本地开发问题** —对于本地开发来说，分支切换然后重新构建整个项目是一个棘手的问题。开发人员必须等待大约 20-25 分钟，项目才能同步。
*   **单元测试作业所花费的时间** —持续集成中的最大时间是单元测试作业所花费的时间。当开发人员做了一个小的改变时，理想情况下，它应该只运行依赖单元测试。但是 Maven 执行所有的单元测试，不管代码有什么变化。例如:如果开发人员更新了自述文件，就不需要运行任何单元测试。但是开发者不得不等待所有的测试通过。我们分三批运行单元测试:单元测试-0、单元测试-1 和单元测试-2。随着代码和单元测试的增加，单元测试工作所花费的时间也在增加。

在这个关键时刻，我们意识到我们需要寻找一个替代方案来满足我们未来的需求。

## 为什么是巴泽尔？

Bazel 是谷歌在 2015 年开发的开源构建工具。它用于构建和测试软件。我们选择 Bazel 作为以下属性的构建系统:

*   **快**:*巴泽尔是*快*。通过分析依赖图，Bazel 确切地知道需要重建什么。Bazel 缓存所有以前完成的工作，只重建需要的部分。此外，Bazel 可以并行构建我们的项目。例如，如果我们有三个名为 A、B 和 C 的模块，其中 A 依赖于 B and B，而 C 依赖于它，如果你在模块 B 中做了更改，Bazel 将只构建模块 A 和 B，而不是 C*
*   **正确/可重现的构建** : 如果你用相同的参数构建相同的代码，它将总是输出相同的构建。
*   **更少的间歇性测试失败** : Bazel 在沙箱中运行测试。碰撞的机会非常少，这导致间歇性测试失败的可能性更小。

## **概念验证(POC)**

为了证实这一点，我们从 Maven 中取出了两个模块——模块 A 和 B，其中 B 依赖于 A(B-> A)——并在那里测试了 Bazel 的变化。我们还在 GCP 上创建了一个缓存桶。以下是我们的发现:

1.  **第一次运行两个模块** —我们观察到两个模块测试都在没有任何缓存的情况下运行。
2.  **在模块 A 中进行更改** *—* 两个模块都已构建，所有测试都已运行。
3.  **在模块 B 中进行更改** *—* 在这种情况下，缓存了模块 A，只构建了模块 B。模块 B 的测试运行，而模块 A 的测试被缓存。与上述两个用例相比，整个过程花费的时间更少。
4.  **任何模块都没有变化** *—* 没有构建模块。模块 A 和 B 都被缓存了。两个模块的测试也被缓存。在上述所有案例中，耗时最短。为了测试缓存，我们还在模块 b 的一个测试中添加了一个 sleep 语句。在没有缓存的情况下，测试运行接近 30 秒，而在有缓存的情况下，只需不到一秒。我们知道有些模块需要很长时间来构建和运行测试。通过缓存，我们节省了大量时间。因此，我们决定从 Maven 搬到 Bazel。

## 迁移

我们在迁移时面临的挑战之一是我们有 100 多个模块要迁移。一次性迁移所有这些模块是不可能的。因此，我们决定采用混合方法。这里，“混合方法”意味着我们同时使用了 Maven 和 Bazel。转换成 Bazel 的模块是通过 Bazel 构建的，其余的是通过 Maven 构建的。我们将在这篇博客的后半部分讨论这个问题。

在这里，我们将讨论如何将一个简单的模块从 Maven 迁移到 Bazel。

### **工作空间**

我们可以将其与 Maven 中的中心 pom.xml 文件进行比较。在 Bazel 中，这个文件位于项目的根层，我们在这里定义外部依赖项，类似于我们在 Maven 的 pom.xml 中的做法。

对于外部 Maven 依赖项，我们使用 rules_jvm_external。这是一个外部库，它以传递方式获取这些依赖项。

添加依赖项时遵循的模式是:groupId:artifactId:version

**例子:**

在下图中，首先，我们加载 rules_jvm_external。然后，我们使用
maven_install 来获取外部 maven 依赖项。

### BUILD .巴塞尔协议

这个文件可以在模块级和文件级创建。由于我们的代码库包含许多文件，我们决定采用模块级 Bazel 迁移，这意味着我们在模块级创建了 BUILD.bazel 文件。

BUILD.bazel 可定义如下:

*   **java _ library**:*这是 Bazel 中的一个 java_rule，编译一组 Java 源文件，创建一个 jar。*
*   ***名称**:该目标的唯一名称。将用于在构建时引用此目标。*
*   ***@maven** : 这里 maven 是我们在 WORKSPACE 中定义的目标的名称。通过组合 groupId 后跟 artifactId 并以 _ 分隔来引用依赖关系。我们需要更换每一个。groupId 和 artifactId 中的 with _ in。*
*   ***srcs** : 我们希望包含在这个目标中并一起构建的一组 Java 源文件。*
*   ***deps**:*src 的所有依赖关系都在 deps 下定义。它可以有外部依赖项，也可以有项目中的其他目标。**

**创建 BUILD.bazel 文件后，我们可以运行下面的命令来构建这个目标:**

**bazel 构建路径到目录:模块**

**这里，path_to_directory 是从项目根目录到 Build.bazel 文件目录的相对路径。**

## **迁移过程中的障碍**

**在这里，我们将讨论从 Maven 迁移到 Bazel 时所面临的挑战。我们还将讨论应对挑战的解决方案。**

### **大型代码库**

**我们有一个庞大的代码库和 100 多个相互依赖的模块。因此，我们不能一次性迁移整个存储库。**

**如前所述，我们需要一个允许迭代迁移的策略，并且不会对当前的开发工作产生太大影响。为此，我们提出了一种方法，我们称之为混合方法。**

****混合方法**:我们有一个要求，我们要迁移到 Bazel 的模块只能依赖于 Bazel 模块(它可以依赖于外部库，但不能依赖于本地 Maven 模块)。因此，我们从独立/叶模块开始迁移。**

*   **我们创建了一个脚本，并将这个脚本挂在 Maven 的 pom.xml 文件中。因此，当我们运行 Maven 构建时，首先执行这个脚本，它构建所有的 Bazel 模块并在本地 Maven 存储库中安装工件(在我们的例子中是~ ~/. m2/repository)。**
*   **然后，Maven 继续构建 Maven 模块，这些模块可以依赖于 Bazel 模块。Maven 将 Bazel 模块视为外部依赖项。由于 Bazel 模块的构件已经安装在本地 Maven repo 中，Maven 只是进行构建，而不关心这些依赖项是外部库还是 Bazel 构建的构件。**

**有了这个策略，我们能够在不影响[开发人员生产力](https://harness.io/blog/developer-productivity/)的情况下迭代地迁移模块。**

### **运行所有单元测试**

**Bazel 对于在一个目标中运行一组单元测试没有任何内置的规则。开发人员必须为每个单元测试文件编写一个目标。考虑到我们的代码库，我们将不得不编写大量的单元测试目标。那将是重复的工作，并且会使我们的构建文件非常大并且不可维护。**

**为了克服上述问题，我们编写了一个宏，当我们运行 Bazel 操作时，它为每个单元测试文件初始化 java_test 规则。这使得我们的 BUILD.bazel 文件更小、更干净、更易于维护。如果我们想要为所有的单元测试改变一个参数，我们可以简单地在宏中做这个改变，它将会为所有的测试目标反映出来。**

**在上面的宏中，我们有 runtime_deps = ["tests"]。这里的“tests”是一个 java_library 目标，它应该包含运行该模块的单元测试的所有依赖项。**

**下面是运行 Bazel 测试的命令:
bazel 测试//relative _ path _ to _ module _ directory:fqn _ of _ test _ class**

### **固定单元测试**

**最大的挑战之一是在将模块从 Maven 迁移到 Bazel 之后修复测试。90%的失败测试都是因为路径问题。Bazel 在自己的私有沙箱中运行测试——因此，当您的测试依赖于您的资源文件时，它会失败，因为您的文件可能不在沙箱中。**

**在每个资源文件夹中，我们都创建了一个 BUILD.bazel 文件。如果任何测试需要任何资源文件，测试目标将依赖于此目标。**

### **检查样式**

**Bazel 没有对 checkstyle 的内置支持，所以我们需要手动集成它和其他静态检查。首先，我们使用 checkstyle 外部 jar 和我们的自定义 checkstyle 规则创建了 java_binary。**

**然后，我们在 Bazel 中创建了一个 **genrule** ,它接受 checkstyle 二进制文件，并在应用 checkstyle 参数后形成一个 shell 命令来执行该二进制文件。**

**现在，我们可以从模块级构建文件中调用这个 genrule，对该模块中的所有文件运行 checkstyle。**

***加载("//工具/检查样式:规则。bzl "，" checkstyle")***

***checkstyle()***

**我们可以使用 Bazel build 命令运行检查，如下所示:**

**bazel 构建相对路径到模块目录:checkstyle**

**同样，pmd 检查也可以集成到 Bazel 上。**

## **我们从 Maven 迁移到 Bazel 后的体验**

**在完全从 Maven 迁移到 Bazel 之后，我们面临着正反两方面的问题。Maven 面临的挑战已经在 Bazel 迁移中介绍过了。**

**然而，在 Bazel 迁移之后，我们面临着一些新的问题。我们将在下面讨论优点和缺点。**

#### ****优点****

*   ****单元测试作业:**测试作业的运行有了显著的改进。现在，单元测试工作所花费的时间取决于开发人员进行更改的模块。截止到 7 月 21 日，我们拥有单元测试工作的以下时间记录:**

***Stats for unit-tests-0***

***Dashboard***

*   ****跨分支工作的本地开发人员**:当我们在多个分支上工作时，如果我们切换分支并进行同步，那么 Bazel 不会再次编译/同步整个回购，如果我们之前已经同步过它。Bazel 获取以前缓存的结果，只编译那些需要的结果。这样，开发人员可以很容易地同时在多个分支上工作。**
*   ****较少间歇性测试失败**:**Bazel 在沙箱中运行测试，因此发生碰撞的几率很小。这降低了间歇性测试失败的可能性。****

#### ****缺点****

*   ****对 IntelliJ Bazel 插件**的支持较少:与 Maven 插件相比，用于 IntelliJ 的Bazel 插件对特性的支持较少。Maven 已经足够成熟，可以添加对 IntelliJ 的支持，而 Bazel 是一项非常年轻的技术，要达到这种支持水平还需要一些时间。**
*   ****第一次项目同步需要更多时间** : Bazel 工作在高粒度上，因此它有大量的动作要执行。它生成构建图，这有助于确定在更改后要重建什么。所有这些动作都会消耗一些时间，使得 Bazel 中的第一次/干净构建很慢。但是，Bazel 中的增量/无操作构建要快得多，这使得我们的整体构建更快。**

## **结论**

**我们对从 Maven 迁移到 Bazel 后得到的结果感到兴奋。迁移帮助我们提高了开发人员的工作效率，这帮助我们显著提高了构建和测试时间。**

**看起来你喜欢技术性的深潜！如果你对进一步阅读感兴趣，请查看我们在[上的文章:“多少个 bug 太多了?”？利用数据驱动的质量管理方法](https://harness.io/blog/bugs-data-driven-quality/)和[使用 Redis 流的事件驱动架构](https://harness.io/blog/event-driven-architecture-redis-streams/)。**

**本文由 Prashant Sharma 和 Brijesh Dhakar 合作撰写。**

**Prashant Sharma 是 Harness 的一名软件后端工程师。他是负责实施和迁移到 Bazel 的团队的核心成员，并参与构建线束管道的新迭代。**

**Brijesh Dhakar 是一名热爱技术的软件工程师。他在 Harness 工作，构建首要的软件交付平台来解决整个行业的问题。**