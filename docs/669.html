<html>
<head>
<title>How to Create Multi-Stage Docker Builds with Harness Continuous Delivery | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何使用线束连续交付|线束创建多阶段Docker构建</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/how-to-create-multi-stage-docker-builds-with-harness-continuous-delivery#0001-01-01">https://www.harness.io/blog/how-to-create-multi-stage-docker-builds-with-harness-continuous-delivery#0001-01-01</a></blockquote><div><p>本教程解释了什么是多阶段Docker构建，以及它们如何帮助加速您的开发过程。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>在软件开发和部署的快节奏世界中，每一分钟都很重要。对于简化您的过程来说，每一秒都很重要，因此您可以减少等待构建时间或其他滞后步骤所花费的时间。在尽可能高效地创建容器图像方面，有许多不同的技术。一种方法是使用Docker的多阶段构建，这有助于减小容器的大小。</p><p>当使用Docker管理软件构建和部署时，您希望确保尽一切可能简化过程，这样开发人员就不会陷入冗长的构建过程。这就是为什么多阶段构建是Docker的一个非常有用的特性。</p><p>本教程解释了什么是多阶段构建，以及它们如何帮助加速您的开发过程。但是首先，让我们探索更多可以从多阶段构建中获益的方法。</p><h2>使用多阶段构建的好处</h2><p>如果简化软件交付是你的目标之一，那么你一定要理解多阶段Docker是如何构建工作的。多阶段构建是简化映像创建过程并节省开发人员时间的好方法。</p><p>多阶段Docker构建的一个极好的好处是，它减少了映像中的依赖项和不必要的包的数量，减少了攻击面并提高了安全性。此外，通过只拥有在生产中运行应用程序所需的东西，它保持了构建的干净和精简。否则，开发人员最终都会构建和推送带有漏洞的大尺寸图像，这给攻击者提供了进入我们应用程序的简单途径。尝试使用多阶段Docker构建来优化映像和安全性。</p><p>以下是使用多阶段构建的一些其他优势:</p><ul role="list"><li>优化Docker图像的整体大小</li><li>消除了为不同阶段创建多个docker文件的负担</li><li>易于调试特定的构建阶段</li><li>能够在新的环境中使用前一阶段作为新的阶段</li><li>能够使用缓存的图像使整个过程更快</li><li>随着多阶段构建使映像变得更小，降低了发现漏洞的风险</li></ul><h2>创建Dockerfile文件</h2><p>容器允许您将应用程序与所有必要的部分打包在一起，比如库和其他依赖项，并作为一个包发送出去。整个应用程序可以转换成一个图像，并推送到DockerHub之类的图像注册中心。Docker是一个容器化平台，允许开发者创建可移植的、自给自足的容器。Docker构建过程从图像开始，这只是最终图像的基础层。这意味着映像只包含操作系统和执行命令所需的任何其他包。</p><p>Dockerfile的主要目的是创建一个可以尽快部署的映像，并尽可能减少依赖性。Dockerfile是一个简单的文本文档，包含创建Docker映像的所有命令和指令，它被编写为Docker要遵循的指令列表。</p><p>docker文件以一个将另一个文件(称为基本映像)的内容复制到您的计算机上的指令开始。之后，您可以根据您正在使用的应用程序相应地添加您自己的定制。Docker文件由Docker引擎读取，然后按顺序执行指令。</p><p>此过程的下一步是使用其他映像中的层或手动安装包向此基础层添加层。</p><p>您在上一步中创建的Docker文件详细指定了所有这些步骤，并且可以通过Docker build命令用作Docker构建过程的输入。Docker build命令用于从Docker文件创建映像，并且可以与一个标记一起运行，以指定应该创建映像的哪个版本。</p><h2>创建多阶段Docker构件</h2><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>每个微服务都应该是一个独立的容器。如果你只使用单阶段的Docker构建，你就错过了构建过程的一些强大的特性。相比之下，在部署微服务方面，多阶段Docker构建比单阶段构建有许多优势。</p><p>多阶段构建是一个允许您将构建Docker映像的步骤分成多个阶段的过程。这将使您能够创建只包含最终应用程序所需功能所必需的依赖项的映像，从而节省时间和空间。对于多阶段构建，您将首先构建仅包含构建应用程序所需的依赖项的映像。然后，在构建映像之后，您可以添加创建应用程序所需的任何附加层，并为部署进行配置。这样，您可以只使用构建应用程序所需的代码来构建图像。这也是战略性地用于优化容器图像，使它们更小。</p><p>如上所述，多阶段构建允许您创建优化的Docker映像，并且只包含构建应用程序所需的依赖项。结合Docker的分层图像，这可以帮助您节省大量空间。多阶段过程节省了Docker主机和Docker映像中的空间，并加快了构建过程。此外，与包含构建应用程序所需的所有代码相比，这个过程会快得多。</p><p>创建两个docker文件(一个用于开发，一个用于生产)在DevOps世界中并不理想。这就是多阶段Docker构建派上用场的地方，因为我们可以为所有环境创建一个优化的Docker文件，无论是开发、试运行还是生产环境。</p><h3>Java多阶段Docker构建示例</h3><p>为了更好地理解多阶段Docker构建的概念，让我们考虑一个简单的Java Hello World应用程序。</p><p>在名为HelloWorld.java的文件中添加以下代码</p><h6>HelloWorld类{</h6><h6>公共静态void main(String[] a) {</h6><h6>System.out.println("Hello world！");</h6><h6>}</h6><h6>}</h6><p>然后，创建一个Dockerfile文件，其中包含以下内容，</p><h6>来自openjdk:11-jdk</h6><h6>复制HelloWorld.java。</h6><h6>运行javac HelloWorld.java</h6><h6>CMD java HelloWorld</h6><p>使用以下命令构建映像，</p><h6>巨大的。</h6><p>让我们用以下内容修改我们的Docker文件，以展示多阶段Docker构建是如何工作的。</p><h6>来自openjdk:11-jdk AS build</h6><h6>复制HelloWorld.java。</h6><h6>运行javac HelloWorld.java</h6><h6> </h6><h6>从openjdk:11-jre AS运行</h6><h6>COPY-from =构建HelloWorld.class。</h6><h6>CMD java HelloWorld</h6><p>使用以下命令构建映像，</p><h6>docker build -t helloworld:小型。</h6><p>现在，让我们比较两张图片。检查用以下命令创建的图像，</p><h6>docker图像</h6><p>‍</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>这两幅图像在尺寸上有很大的差别。这种差异允许您在同一个Dockerfile文件中分离构建和运行时环境。将生成环境用作依赖项[COPY-from = build hello world . class。]同时使用多阶段docker构建方法创建docker文件。这将有助于最小化Docker图像的大小。</p><h3>节点。Js多阶段Docker构建示例</h3><p>我们先从一个简单的节点来学习。有一个基本Dockerfile文件的Js应用程序。</p><h6>从节点:14-阿尔卑斯山</h6><h6>补充。/应用程序</h6><h6>工作目录/应用程序</h6><h6>复制package.json。</h6><h6>运行npm安装-生产</h6><h6>收到。。</h6><h6>曝光3002</h6><h6>CMD [ "node "，" app.js" ]</h6><p>让我们用下面的命令构建图像，</p><h6>docker build -t [DockerHub用户名]/图像名称:标签</h6><p>使用命令将映像推送到Docker Hub，</p><h6>docker推送[DockerHub用户名]/图片名称:标签</h6><p>我把图片推送到DockerHub，下面是图片和尺寸，</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>现在，让我们尝试使用多阶段Docker构建的概念并修改我们现有的Docker文件。</p><h6>从节点:14-阿尔卑斯山作为基础</h6><h6>补充。/应用程序</h6><h6>工作目录/应用程序</h6><h6>复制package.json。</h6><h6>运行npm安装</h6><h6>来自阿尔卑斯山:最新</h6><h6>复制自=阶段1/应用程序/应用程序</h6><h6>工作目录/应用程序</h6><h6>曝光3002</h6><h6>CMD [ "node "，" app.js" ]</h6><p>让我们用上面使用的类似命令来构建和推送映像。只是要确保给这个图像取一个不同的名字。</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>现在，比较图像大小。一个是通常的Docker文件，大小为48.81 MB，另一个是用多阶段Docker构建创建的，大小为7.12 MB。由多阶段Docker构建方法创建的映像更加优化且更小。</p><p>另一个展示如何有效使用多阶段Docker构建的例子是一个场景，其中您为不同的环境剖析Docker文件。</p><p>一个普通的docker文件如下所示:</p><h6>从节点:14-阿尔卑斯山</h6><h6> </h6><h6>工作主管/服务代表</h6><h6>复制package.json包-lock.json /src/</h6><h6>运行npm安装-生产</h6><h6>收到。/src</h6><h6>COPY . /src</h6><h6>曝光3000</h6><h6>EXPOSE 3000</h6><h6>CMD ["node "，" bin/www"]</h6><h6>我们将从上面的Dockerfile文件创建三个简单的阶段。</h6><p><strong> <em>基础阶段</em> </strong>:该阶段将与原始Dockerfile有共同之处</p><ol role="list"><li><strong> <em>生产阶段</em> </strong>:这个阶段将包括对生产环境有用的东西</li><li><strong> <em>开发阶段</em> </strong>:这个阶段将拥有对开发环境有用的组件</li><li>请参见下面修改后的Dockerfile文件:</li></ol><p>从节点:14-阿尔卑斯山作为基础</p><h6>从节点:14-阿尔卑斯山作为基础</h6><h6>工作主管/服务代表</h6><h6>复制package.json包-lock.json /src/</h6><h6>曝光3000</h6><h6>EXPOSE 3000</h6><h6>从生产基地开始</h6><h6>环境节点_环境=生产</h6><h6>运行npm ci</h6><h6>收到。/src</h6><h6>CMD ["node "，" bin/www"]</h6><h6>CMD ["node", "bin/www"]</h6><h6>从基础作为开发</h6><h6>环境节点_环境=开发</h6><h6>运行NPM install-g nodemon &amp; &amp; NPM install</h6><h6>收到。/src</h6><h6>CMD ["nodemon "，" bin/www"]</h6><h6>开始使用Harness部署应用程序</h6><h2><a href="https://app.harness.io/auth/#/signup/?utm_source=internal&amp;utm_medium=social&amp;utm_campaign=community&amp;utm_content=replace&amp;utm_term=get-started">注册免费试用</a>装具，选择<strong> TryNextGen </strong>选项卡，体验无缝体验。</h2><p>创建一个新项目并选择连续交付模块。首先创建一个新的管道，并添加管道所需的所有细节。</p><p><strong> <em>注意:</em> </strong>为了让Harness发挥它的魔力，你需要一个叫做“代理”的东西在你的Kubernetes集群上运行。别担心，我们有一个简单的教程来帮助你<a href="https://docs.harness.io/article/2k7lnc7lvl-delegates-overview">设置代表</a>。</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>接下来，为您的应用程序指定服务、基础设施和部署策略。设置好一切后，保存配置并运行以部署应用程序。</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>一旦管道成功运行，您应该看到您的应用程序部署在指定的Kubernetes集群上。这可以通过kubectl命令来验证:</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>kubectl获取豆荚</p><h6>‘kubectl get pods' </h6></div></div>    
</body>
</html>