# 线程魔术:用 Java 线程可以做 5 件你从来不知道的事情

> 原文：<https://www.harness.io/blog/5-things-you-can-do-with-java-threads>

一些鲜为人知的使用 Java 线程的技术。

Java 线程有哪些鲜为人知的事实和用例？

有些人喜欢爬山，有些人喜欢跳伞。我呢，喜欢 Java。我喜欢它的一点是你永远不会停止学习。您日常使用的工具通常可以向他们展示全新的一面，包括您还没有机会看到的方法和有趣的用例。比如说线。实际线程。或者更确切地说，是线程类本身。当我们处理高可伸缩性系统时，并发编程从未停止带来挑战，但是现在我们将谈论一些稍微不同的东西。

‍
在这篇文章中，你将会看到线程支持的一些鲜为人知却很有用的技术和方法。无论你是初学者、高级用户还是 Java 开发专家，试着看看哪些你已经知道，哪些对你来说是新的。关于线程，您觉得还有什么值得一提的吗？我很想在下面的评论中听到它。让我们开始吧。

## 新手

### 1.线程名称

应用程序中的每个线程都有一个名称，一个简单的 Java 字符串，在构建线程时为它生成。默认的名称值从“线程 0”到“线程 1”、“线程 2”等等。接下来是更有趣的部分——线程公开了两种方式来设置它们的名称:
**1。线程构造器，这里最简单的一个:**
‍

###### [java]
类 SuchThread 扩展 Thread {
Public void run(){
system . out . println(" Hi Mom！"+getName())；
}
}
such thread wow = new such thread(" much-name ")；
[/java]

‍
**2。线程名称设置器:**

###### **‍**
【Java】
wow . setname("只是另一个线程名")；
[/java]

对，线程名是可变的。因此，除了在实例化它们时设置自定义名称之外，我们还可以在运行时更改它。name 字段本身被设置为一个简单的 String 对象。这意味着它可以长达 2 -1 个字符(整数。MAX_VALUE)。我觉得已经够多了。请注意，这个名称不像一个唯一的 ID，所以线程可以共享相同的名称。此外，除非您希望抛出异常，否则不要尝试将 null 作为名称传递(“null”是可以的，但我不是在评判！).

### 使用线程名称进行调试

现在您已经可以访问线程名称了，遵循一些您自己的命名约定可以在发生不好的事情时让您的生活变得容易得多。“Thread-6”听起来有点无情，我相信你能想到一个更好的名字。在处理用户请求时，将它与自己分配的事务 ID 结合起来，将它附加到线程的名称上，就可以大大减少解决错误的时间。这里要保持的一个好习惯是，确保在应用程序的每个线程入口点生成一个 UUID，并在请求在节点、进程和线程之间传递时保持一致。让我们来看看这个例子，某个线程池中的一个工作线程挂起的时间太长了。您运行 jstack 来仔细查看，然后您会看到:

‍***" pool-1-thread-1"****# 17 prio = 5 OS _ prio = 31 tid = 0x 00007 F9 d 620 c 9800*
*NID = 0x6d 03 in object . wait()[0x 000000013 ebcc 000]*
好吧，" pool-1-thread-1 "，为什么这么严重？让我们更了解你，想一个更合适的名字:
【Java】
thread . current thread()。setName(上下文+ TID +参数+当前时间，…)；
[/java]

现在，当我们再次运行 jstack 时，事情看起来要光明得多:

‍ *"* ***队列处理线程，MessageID: AB5CAD，type:***
***analyze graph，queue: ACTIVE_PROD，Transaction_ID: 5678956，***
***开始时间:30/12/2014 17:37”**# 17 prio = 5 OS _ prio = 31 tid = 0x 000071***

我们知道线程在做什么，什么时候被卡住，我们也有启动这一切的事务 ID。您可以追溯您的步骤，重现错误，隔离并解决它。

### 2.线程优先级

线程的另一个有趣的领域是优先级。线程的优先级是 1 (MIN_PRIORITY)到 10 (MAX_PRIORITY)之间的值，主线程的默认值是 5 (NORM_PRIORITY)。每个新线程都获得其父线程的优先级，所以如果你没有手动操作它，你所有的线程优先级可能都被设置为 5。这也是线程类中一个经常被忽略的字段，我们可以通过方法 *getPriority()* 和 *setPriority()* 来访问和操作它。没有办法在线程构造函数中设置这个。

#### 不管怎样，谁需要优先权？

当然，并不是所有的线程都是一样的，有些线程需要你的 CPU 立即处理，而有些线程只是后台任务。优先级用于向 OS 线程调度器发出信号。在 Harness，我们开发了一个错误跟踪和分析工具，为用户处理新异常的线程获得 MAX_PRIORITY，而处理报告新部署等任务的线程被赋予较低的优先级。人们可能会认为，具有较高优先级的线程会从与 JVM 一起工作的线程调度器中获得更多的时间。嗯，并不总是这样。

‍
每个 Java 线程在操作系统层打开一个新的本地线程，你设置的 Java 优先级在每个平台上以不同的方式转换成本地优先级。在 Linux 上，当运行你的应用程序时，你还必须包含*-XX:+UseThreadPriorities "*标志，它们才会被考虑。尽管如此，线程优先级仍然只是您提供的建议。与原生 Linux 优先级相比，它们甚至没有涵盖所有的价值(1..99，以及范围在-20..20).主要要点是保持自己的逻辑的重要性，这将确保您的优先级反映在每个线程获得的 CPU 时间中，但不建议只依赖优先级。

## 先进的

### 3.线程本地存储

这只与我们在这里讨论的其他生物有点不同。ThreadLocal 是一个在 Thread 类( *java.lang.ThreadLocal* )之外实现的概念，但是为每个线程存储唯一的数据。正如它在 tin 上所说的，它为您提供了线程本地存储，这意味着您可以创建对每个线程实例唯一的变量。与创建线程名称或优先级的方式类似，您可以创建自定义字段，就像它们是 thread 类的成员一样。是不是很酷？但我们不要太兴奋，前面还有一些警告。

建议以两种方式之一创建 ThreadLocal:要么作为静态变量，要么作为 singleton 的一部分，它不必是静态的。请注意，它位于全局范围内，但对每个能够访问它的线程都是局部的。下面是一个 ThreadLocal 变量的例子，它保存了我们自己的数据结构，以便于访问:

###### 【Java】
公共静态类 CriticalData
{
公共 int transactionId
public int 用户名；
}
公共静态最终 thread local<critical data>global data =
new thread local<critical data>()；
[/java]

一旦我们手中有了一个 ThreadLocal，我们就可以用 *globalData.set()* 和 *globalData.get()* 来访问它。

#### 全球？它一定是邪恶的

不一定。ThreadLocal 变量可以保存一个事务 ID。当您的代码中出现一个未被捕获的异常时，这就派上了用场。一个好的实践是在适当的位置有一个 [UncaughtExceptionHandler](http://docs.oracle.com/javase/8/docs/api/java/lang/Thread.UncaughtExceptionHandler.html) ,我们也可以通过 Thread 类得到它，但是必须自己实现。一旦我们到达了那个阶段，就没有多少线索能告诉我们到底是什么让我们到达了那个阶段。我们只剩下了线程对象，并且不能访问任何在堆栈帧关闭时进入那里的变量。在我们的 UncaughtExceptionHandler 中，当线程奄奄一息时，ThreadLocal 几乎是我们剩下的仅有的东西之一。
我们可以本着这样的精神做些事情:

###### [java]
System.err.println("事务 ID " + globalData.get()。transaction id)；
[/java]

就这样，我们给错误添加了一些有价值的上下文。使用 *ThreadLocal* 的一个更有创造性的方法是分配一个指定的内存块作为工作线程反复使用的缓冲区。当然，这取决于你在内存和 CPU 开销权衡中的立场。也就是说，要注意的是内存空间的滥用。ThreadLocal 对于一个特定的线程来说是存在的，只要它还活着，就不会被垃圾收集，除非你释放它或者线程死亡。所以你用的时候最好小心点，保持简单。

### 4.用户线程和守护线程

回到我们的线程类。我们应用程序中的每个线程要么接收一个用户状态，要么接收一个守护进程状态。换句话说，前台或后台线程。默认情况下，主线程是用户线程，每个新线程都获得创建它的线程的状态。因此，如果您将一个线程设置为守护进程，它创建的所有线程也将被标记为守护进程。当您的应用程序中唯一运行的线程处于守护进程状态时，该进程就会关闭。为了试验、检查和改变线程状态，我们使用了布尔值*。setDaemon(true)* 和*。isDaemon()* 方法。

#### 你什么时候设置一个守护线程？

当一个线程的状态对它来说不是关键的时候，你应该把它的状态改为守护进程，这样进程就可以关闭了。它去掉了正确关闭线程的麻烦，一次停止所有事情，让它快速结束。另一方面，当有一个线程运行一个必须正确结束的操作，否则会发生不好的事情，确保它被设置为用户线程。例如，一个关键事务可以是一个数据库条目或完成一个不能被中断的更新。

## 专家

### 5.Java 处理器关联性

这一部分让我们更接近硬件，也就是代码与金属相遇的地方。处理器关联性允许您将线程或进程绑定到特定的 CPU 内核。这意味着每当特定线程执行时，它将专门在某个特定的内核上运行。通常情况下，操作系统线程调度程序会根据自己的逻辑承担这个角色，可能会考虑我们之前提到的线程优先级。

这里的筹码是 CPU 缓存。如果一个线程只在一个特定的内核上运行，它更有可能享受在缓存上为它准备好所有数据的乐趣。当数据已经存在时，没有必要重新加载它。您节省的微秒数可以得到更好的利用，代码实际上会在那个时间运行，从而更好地利用分配给它的 CPU 时间。虽然在操作系统层面确实存在一些优化，当然硬件架构也有重要作用，但是使用 affinity 可以消除线程切换内核的机会。

因为这里有许多因素在起作用，所以确定处理器关联性如何影响您的吞吐量的最佳方式是养成测试的习惯。虽然它可能不总是明显更好，但您可能体验到的好处之一是稳定的吞吐量。亲和策略可以下降到外科手术的水平，这取决于有什么收获。高频交易行业是这类事情最重要的领域之一。

#### 测试处理器关联性

Java 没有对处理器亲和性的本地支持，但这当然不是故事的结尾。在 Linux 上，我们可以使用 *taskset* 命令来设置进程亲缘关系。假设我们有一个正在运行的 Java 进程，我们想把它固定到一个特定的 CPU:
*taskset-C1 " Java abouttobepined "*
或者如果它已经在运行:
*taskset-C1<PID>*‍

现在，为了深入到线程级别，我们需要插入一些新代码。幸运的是，有一个开源库可以帮助我们做到这一点: [Java-Thread-Affinity](https://github.com/OpenHFT/Java-Thread-Affinity) 。由 OpenHFT 的 [Peter Lawrey](https://twitter.com/peterlawrey) 撰写，这可能是最直接的方法。让我们来看一个快速锁定线程的例子，更多的例子可以在库的 GitHub repo 上找到:
【Java】
affinity lock al = affinity lock . acquire lock()；
[/java]

仅此而已。GitHub 上提供了获取锁的更多高级选项——考虑到选择特定内核的不同策略。

## 结论

我们已经看到了查看线程的 5 种方式:线程名称、线程本地存储、优先级、守护线程和亲缘关系。希望这对你日常处理的事情有所帮助，并很高兴听到你的评论！还有什么其他的线程处理方法可以适用呢？

harness Service Reliability Management 向您展示您的代码在生产中何时以及为什么会中断。它检测已捕获和未捕获的异常、HTTP 和日志错误，并在它们发生时给出代码和变量状态。获得可操作的信息，在几分钟内解决复杂的错误。5 分钟内安装完毕。为生产而制造。