<html>
<head>
<title>Flow Control For Microservice Deployments | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>微服务部署的流量控制|线束</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/flow-control-for-microservice-deployments#0001-01-01">https://www.harness.io/blog/flow-control-for-microservice-deployments#0001-01-01</a></blockquote><div><p>Harness通过提供几种部署工作流策略来支持微服务部署:基本、多服务、金丝雀和蓝绿色。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>如今，随着大多数组织开始追求云、开发运维以及持续交付，他们正在寻求打破其“过时”的单一应用。在某些方面，迁移到微服务部署架构是这些计划的先决条件。</p><p>这篇博客描述了从整体架构迁移到微服务架构的一些部署挑战。</p><h2>整体部署管道</h2><p>回到过去的美好时光，单体应用程序可能有一两个工件，部署管道相对简单，就像下面这样:</p><figure class="w-richtext-figure-type- "/><p><br/>这个管道有1个工件(Monolithic.war)和4个阶段{开发、QA、人工批准、生产}。每个阶段(也称为工作流)将新的工件部署到其目标环境，运行一系列测试，然后在进入下一个阶段之前验证一切正常。</p><p>如果一个阶段失败了，整个部署管道就失败了，并且工件永远也不会进入生产阶段(因此救了你的命)。如果生产失败，那么Harness会自动将它回滚到上一个工作版本(更多保存下来的培根)。</p><p><strong>底线:</strong>部署、测试和验证单体应用程序相对来说比较简单。</p><p>对于2010年来说，这一切都很好。然而，我们现在生活在一个被容器和Kubernetes统治的世界。微服务很流行，而EJB则不然。</p><h2>微服务改变一切</h2><p>云原生应用只不过是服务、微服务或功能的逻辑组。</p><p>微服务的全部要点是将应用程序逻辑分解成小的定义明确的组件，这些组件可以彼此独立地开发和部署，从而增加团队的并行性和生产力。很好，让我们每个微服务只有一个部署管道。当一个新的工件、构建或者版本存在时，团队可以自动触发他们自己的管道。任务完成了吗？</p><p>只有它不是，因为在现实中，微服务架构在服务/微服务之间有隐含的依赖关系。这些依赖性使得部署管道、测试、验证和回滚管理更加复杂。</p><figure class="w-richtext-figure-type- "/><p><br/> <strong>底线:</strong>部署微服务是小事一桩，但是鉴于微服务的上下游依赖性，测试、验证和回滚微服务是非常复杂的。</p><h2>我们从客户那里听到的</h2><p>在使用Harness之前，我们采访的客户通常会将许多微服务并行部署到一个给定的环境/云，然后手动单独或共同验证每个微服务的影响。如果一个微服务部署失败，客户可能会回滚与整个部署相关的一个或所有微服务。</p><p>在Harness，我们将这一过程自动化，称之为<a href="https://harness.io/platform/continuous-delivery/continuous-verification/" target="_blank">持续验证</a>。我们允许客户独立地或共同地自动验证每个微服务的运行状况(性能/质量),如果出现故障，我们会根据客户的偏好自动进行本地或全局回滚。</p><h2>利用Harness实现微服务部署</h2><p>为了帮助客户部署他们的微服务，Harness提供了几种现成的<a href="https://harness.io/blog/blue-green-canary-deployment-strategies/" target="_blank">部署策略</a>:</p><ul role="list"><li>基本(一个环境一项服务)</li><li>多服务(一个环境中有多种服务)</li><li><a href="https://harness.io/blog/build-canary-deployment/" target="_blank">金丝雀部署</a></li><li>蓝色/绿色部署</li><li>滚动部署</li></ul><p>根据您的微服务架构、团队和环境，有几种方法可以使用Harness进行部署:</p><ul role="list"><li>每个微服务/团队都有自己的部署管道，并且部署管道可以链接到镜像依赖项</li><li>一个部署管道，每个阶段(开发、QA、生产)有多个多服务部署工作流</li><li>每个环境一个部署管道，由每个微服务的多个并行部署工作流组成；这些管道也可以为开发、质量保证和生产链接起来。</li></ul><p>例如，后者显示了一个管道，其中多个微服务部署工作流作为一个并行阶段一起执行:</p><figure class="w-richtext-figure-type- "/><p>每个微服务并行执行自己的部署工作流。例如，典型的微服务工作流如下所示:</p><figure class="w-richtext-figure-type- "/><p>每个微服务工件首先使用Kubernetes进行挑选、设置和部署，然后使用Splunk和AppDynamics通过利用Harness连续验证(基于机器学习的验证)对每个微服务进行独立的自动验证。Harness对AppDynamics、New Relic、Dynatrace、Splunk、ELK、Sumo Logic、Jenkins等都有原生验证支持。</p><h2>部署后验证微服务依赖关系非常困难</h2><p>上面的工作流对于自动化微服务部署和独立验证来说很好，但是对于集体验证来说真的很差，因为其他微服务部署可能还没有成功完成。</p><p>您可能会在其他微服务处于运行中时开始验证一个微服务，因此您将获得不一致的结果，除非所有微服务部署都已完成，并且在您的环境中表现正常。还是那句话，部署微服务很容易，但是验证上下游很难。</p><h2>为管道流量控制引入“屏障”</h2><p>为了克服上述挑战，我们最近发布了一项名为“Barriers”的功能，让客户可以控制部署管道的流动，以便他们可以独立、集体和安全地部署和验证微服务。</p><p>障碍基本上会阻止部署工作流的执行，直到所有其他部署工作流到达相同的障碍。一旦发生这种情况，正常的执行就会恢复。</p><p>如果任何部署工作流失败或超时(未到达障碍)，则默认情况下线束将自动回滚。回滚可以是特定部署工作流的局部回滚，也可以是管道中所有部署工作流的全局回滚。因此，这允许客户在部署或验证失败时回滚一个或所有微服务。</p><p>在我们的微服务示例中，我们可以为每个微服务部署工作流添加一个“等待部署完成”的障碍，以便在所有微服务成功部署之前不会开始集体验证。它看起来会像这样:</p><figure class="w-richtext-figure-type- "/><p>我们的微服务部署工作流现在看起来像这样:</p><figure class="w-richtext-figure-type- "/><p>我们的示例管道现在将为每个微服务并行执行许多上述工作流。一旦“Deploy Containers”步骤完成，每个工作流的执行将在我们的新障碍处停止，并且它将等待直到所有其他工作流都具有相同的障碍。一旦发生这种情况，将恢复正常执行，然后基于所有成功部署的微服务进行验证。</p><p>甚至有可能在部署工作流或管道中设置多层屏障。例如，您可能在工作流的不同阶段执行不同类型的部署验证。当您需要跨微服务或工作流的一致性时，您只需添加新的障碍来控制执行流程。</p><p>上周，我们有一位客户推出了这一新的屏障功能，因此他们现在可以同时在同一环境中部署和验证40项微服务。如果任何微服务或验证失败，它们会自动回滚。用<a href="https://app.harness.io/auth/#/signup" target="_blank">装具试用</a>亲自试试。</p><p>如今，您如何在生产中部署和验证数十项微服务？<br/>干杯，<br/>史蒂夫。<br/>@伯顿说</p></div></div>    
</body>
</html>