<html>
<head>
<title>Externalizing Strings in React - Part 2 of Step-by-Step Tutorial | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React 中的外部化字符串——分步指南| Harness 的第 2 部分</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/externalizing-strings-in-react-part-2#0001-01-01">https://www.harness.io/blog/externalizing-strings-in-react-part-2#0001-01-01</a></blockquote><div><p>React 系列中外部化字符串的第 2 部分！下面是我们如何利用 TypeScript。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>继续 React - <a href="https://harness.io/blog/externalizing-strings-in-react-1/">第 1 部分</a>中的外部化字符串，我们将看看如何利用 TypeScript 来提供静态分析、验证和自动完成。</p><p>首先，我们必须编写一个节点脚本。这将读取一个“YAML”文件并生成类型。例如，如果我们有以下 YAML:</p><p>key1:值 1 <br/> key2:值 2<br/>key 3:<br/>key 3 _ 1:值 3 _ 1<br/>key 3_2:值 3 _ 2</p><p>那么它应该产生以下类型:</p><p>键入 string key = ' key 1 ' | ' key 2 ' | ' key 3。键 3 _ 1“|”键 3。键 3 _ 2 '</p><p>注意，对于嵌套值，我们使用其父代的所有键(直到到达根)来生成键，用` .'分隔。这是 JavaScript 生态系统中遵循的一个通用约定，并受到诸如<a href="https://lodash.com/docs/4.17.15#get" target="_blank"> lodash </a>等库的支持。</p><p>接下来，我们可以在“StringsContext”文件中利用这种类型，并利用 TypeScript。</p><p>以下脚本应该读取 YAML 文件并生成类型:</p><p>从“fs”导入 fs；<br/>从“路径”导入路径；<br/>从“yaml”导入 YAML；<br/> <br/> /** <br/> *递归遍历对象并生成所有值的路径<br/> * { foo: "bar "，foo2: { key1: "value1 "，key2: "value2" }，foo3: [1，2，3] } <br/> *将给出结果:<br/> * <br/> * ["foo "，" foo2.key1 "，" foo2.key2 "，" foo3.0 "，" foo3.1 "，" foo3.2"] <br/> */ <br/>函数 createKeys(obj，objflatMap(([key，value])=&gt;{<br/>const obj path = initial path？` ＄{ initial path }。$ { key } `:key；<br/><br/>if(type of value = = = " object "&amp;&amp;value！== null) { <br/>返回 createKeys(value，obj path)；<br/>}<br/>T18】返回 objPath<br/>})；<br/> } <br/> <br/> /** <br/> *读取输入 YAML 文件并将类型写入输出文件<br/> */ <br/>异步函数 generateStringTypes(input，output){<br/>const data = await fs . promises . readfile(input，" utf8 ")；<br/>const JSON data = YAML . parse(data)；<br/>const keys = create keys(JSON data)；<br/><br/>const typesData = ` export type string keys = \ n | " $ { keys . join(" " \ n | " ')} "；`;<br/><br/>await fs . promises . writefile(output，typesData，" utf8 ")；<br/>}<br/><br/>const input = path . resolve(process . CWD()，“src/strings . YAML”)；<br/>const output = path . resolve(process . CWD()，“src/strings . types . ts”)；<br/><br/>【generateStringTypes】(输入，输出)；</p><p>您可以将此脚本放在“scripts/generate-types.mjs”中，然后运行“node scripts/generate-types.mjs”。此外，您应该会看到“src/strings.types.ts”是用以下内容编写的:</p><p>导出类型 string keys =<br/>| " home page title "<br/>| " about page title "<br/>| " home page content . para 1 "<br/>| " home page content . para 2 "<br/>| " home page content . para 3 "<br/>| " about page content . para 1 "<br/>| " about page content . para 2 "<br/>| " about page content . para 3 "；</p><figure class="w-richtext-align-center w-richtext-figure-type-video"><p/></figure><p>当前形式的脚本不能处理所有的用例/边缘情况。如果需要，您可以增强它，并根据您的使用情况进行定制。</p><p>现在，我们可以更新“StringsContext.tsx ”,以利用生成的类型“StringKeys”。</p><p>从“react”导入 React，{ create context }；<br/>从“lodash.has”导入 has<br/>从“lodash.get”导入 get<br/>从“小胡子”导入小胡子；<br/> <br/> +从“”导入类型{ StringKeys }。/strings . types "；<br/> <br/> +导出类型 string map = Record&lt;string keys，string&gt;；<br/><br/>-const string context = create context({ } as any)；<br/>+const strings context = create context&lt;strings map&gt;({ } as any)；<br/> <br/>导出接口 StringsContextProviderProps {<br/>-data:记录&lt;字符串，任意&gt;；<br/>+data:strings map；<br/> } <br/> <br/>导出函数 StringsContextProvider( <br/>道具:React。props with children&lt;StringsContextProviderProps&gt;<br/>){<br/>return(<br/>&lt;string context)。provider value = { props . data }&gt;<br/>{ props . children }<br/>&lt;/string context。提供商&gt;<br/>)；<br/> } <br/> <br/> -导出函数 usestringcontext():Record&lt;string，any &gt; { <br/> +导出函数 usestringcontext():strings map {<br/>return react . use context(strings context)；<br/> } <br/> <br/>导出接口 UseLocaleStringsReturn {<br/>-getString(key:string，variables？:any):string；<br/> + getString(key: StringKeys，variables？:any):string；<br/> } <br/> <br/>导出函数 useLocaleStrings(){<br/>const strings = useStringsContext()；<br/><br/>return {<br/>-getString(key:string，variables:any = { }):string {<br/>+getString(key:string keys，variables:any = { }):string {<br/>if(has(string，key)){<br/>const str = get(strings，key)；<br/><br/>return mustache . render(str，变量)；<br/> } <br/> <br/>抛出新错误(` Strings data 没有定义为:" $ { key } " `)；<br/> }，<br/>}；<br/> } <br/> <br/>导出接口 LocaleStringProps extends React。html attributes&lt;any&gt;{<br/>-strKey:string；<br/>+strKey:string keys；<br/>作为？:JSX 之钥。内在要素；<br/>变量？:任何；<br/> } <br/> <br/>导出函数 LocaleString(props:LocaleStringProps):React。ReactElement { const { strKey，as，variables，...rest } =道具；<br/>const { getString } = useLocaleStrings()；<br/>const Component = as | | " span "；<br/> <br/>返回&lt;组件{...rest} &gt; {getString(strKey，variables)}&lt;/Component&gt;；<br/> }</p><p>经过这一更改后，您应该能够使用 TypeScript 对存在字符串进行自动完成和验证。</p><figure class="w-richtext-figure-type- "/><figure class="w-richtext-figure-type- "/><figure class="w-richtext-align-center w-richtext-figure-type-video"><p>此外，您可以将字符串生成集成到您的构建系统中。每当“strings.yaml”文件发生变化时，这将自动生成类型。我已经用一个<a href="https://vitejs.dev/guide/api-plugin.html" target="_blank"> vitejs 插件</a>在这里完成了<a href="https://github.com/vkbansal/string-externalisation/blob/1038cee182be3015f92c1b48d3922638422882c7/vite.config.js#L8" target="_blank">。</a></p></figure><p>结论</p><h2>我希望您会发现这很有用，并将它作为您自己实现的起点。对于那些错过了第 1 部分的人，你可以在这里找到它:<a href="https://harness.io/blog/continuous-delivery/externalizing-strings-in-react-1/" target="_blank">在 React-Part 1</a>中具体化字符串。</h2><p>编码快乐！</p><p>Happy coding!</p></div></div>    
</body>
</html>