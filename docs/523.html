<html>
<head>
<title>Migrating to Bazel as a Build Tool - Why We Left Maven | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>迁移到 Bazel 作为构建工具——为什么我们离开 Maven | Harness</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/migrating-bazel-build-tool#0001-01-01">https://www.harness.io/blog/migrating-bazel-build-tool#0001-01-01</a></blockquote><div><p>我们与 Maven 一起回顾了我们面临的挑战，为什么我们决定选择 Bazel，我们如何迁移，以及我们看到了什么结果。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>在 Harness，我们完整的代码库在一个 GitHub repo 中。它由大约 500 万行代码和 100 多个相互依赖的模块组成。我们开始观察到构建时间每周都在增加，而我们现有的构建工具(Maven)无法随着我们不断增长的需求而扩展。在这篇博文中，我们将回顾我们在 Maven 上面临的挑战，为什么我们决定使用 Bazel，我们如何迁移，以及我们看到了什么结果。</p><h2>Maven 的挑战</h2><ul role="list"><li><strong>缺乏增量构建支持</strong> <em> — </em>当我们对数百个模块中的一个进行小的改动时，Maven 通常需要干净的构建。作为一个快速发展的组织，我们以很快的速度加入了新的模块。随着代码的增加，每次构建所花费的时间会显著增加。</li><li><strong>本地开发问题</strong> —对于本地开发来说，分支切换然后重新构建整个项目是一个棘手的问题。开发人员必须等待大约 20-25 分钟，项目才能同步。</li><li><strong>单元测试作业所花费的时间</strong> —持续集成中的最大时间是单元测试作业所花费的时间。当开发人员做了一个小的改变时，理想情况下，它应该只运行依赖单元测试。但是 Maven 执行所有的单元测试，不管代码有什么变化。例如:如果开发人员更新了自述文件，就不需要运行任何单元测试。但是开发者不得不等待所有的测试通过。我们分三批运行单元测试:单元测试-0、单元测试-1 和单元测试-2。随着代码和单元测试的增加，单元测试工作所花费的时间也在增加。</li></ul><figure class="w-richtext-figure-type- "/><p>在这个关键时刻，我们意识到我们需要寻找一个替代方案来满足我们未来的需求。</p><h2>为什么是巴泽尔？</h2><p>Bazel 是谷歌在 2015 年开发的开源构建工具。它用于构建和测试软件。我们选择 Bazel 作为以下属性的构建系统:</p><ul role="list"><li><strong>快</strong>:<em>T3】巴泽尔是<em>快</em>。通过分析依赖图，Bazel 确切地知道需要重建什么。Bazel 缓存所有以前完成的工作，只重建需要的部分。此外，Bazel 可以并行构建我们的项目。例如，如果我们有三个名为 A、B 和 C 的模块，其中 A 依赖于 B and B，而 C 依赖于它，如果你在模块 B 中做了更改，Bazel 将只构建模块 A 和 B，而不是 C</em></li><li><strong>正确/可重现的构建</strong> : <em> </em>如果你用相同的参数构建相同的代码，它将总是输出相同的构建。</li><li><strong>更少的间歇性测试失败</strong> : Bazel 在沙箱中运行测试。碰撞的机会非常少，这导致间歇性测试失败的可能性更小。</li></ul><h2><strong>概念验证(POC) </strong></h2><p>为了证实这一点，我们从 Maven 中取出了两个模块——模块 A 和 B，其中 B 依赖于 A(B-&gt; A)——并在那里测试了 Bazel 的变化。我们还在 GCP 上创建了一个缓存桶。以下是我们的发现:</p><ol role="list"><li><strong>第一次运行两个模块</strong> —我们观察到两个模块测试都在没有任何缓存的情况下运行。</li><li><strong>在模块 A 中进行更改</strong> <em> — </em>两个模块都已构建，所有测试都已运行。</li><li><strong>在模块 B 中进行更改</strong> <em> — </em>在这种情况下，缓存了模块 A，只构建了模块 B。模块 B 的测试运行，而模块 A 的测试被缓存。与上述两个用例相比，整个过程花费的时间更少。</li><li><strong>任何模块都没有变化</strong> <em> — </em>没有构建模块。模块 A 和 B 都被缓存了。两个模块的测试也被缓存。在上述所有案例中，耗时最短。为了测试缓存，我们还在模块 b 的一个测试中添加了一个 sleep 语句。在没有缓存的情况下，测试运行接近 30 秒，而在有缓存的情况下，只需不到一秒。我们知道有些模块需要很长时间来构建和运行测试。通过缓存，我们节省了大量时间。因此，我们决定从 Maven 搬到 Bazel。</li></ol><h2>迁移</h2><p>我们在迁移时面临的挑战之一是我们有 100 多个模块要迁移。一次性迁移所有这些模块是不可能的。因此，我们决定采用混合方法。这里，“混合方法”意味着我们同时使用了 Maven 和 Bazel。转换成 Bazel 的模块是通过 Bazel 构建的，其余的是通过 Maven 构建的。我们将在这篇博客的后半部分讨论这个问题。</p><p>在这里，我们将讨论如何将一个简单的模块从 Maven 迁移到 Bazel。</p><h3><strong>工作空间</strong></h3><p>我们可以将其与 Maven 中的中心 pom.xml 文件进行比较。在 Bazel 中，这个文件位于项目的根层，我们在这里定义外部依赖项，类似于我们在 Maven 的 pom.xml 中的做法。</p><figure class="w-richtext-figure-type- "/><p>对于外部 Maven 依赖项，我们使用 rules_jvm_external。这是一个外部库，它以传递方式获取这些依赖项。</p><p>添加依赖项时遵循的模式是:groupId:artifactId:version</p><p><strong>例子:</strong></p><p>在下图中，首先，我们加载 rules_jvm_external。然后，我们使用<br/> maven_install 来获取外部 maven 依赖项。</p><figure class="w-richtext-figure-type- "/><h3>BUILD .巴塞尔协议</h3><p>这个文件可以在模块级和文件级创建。由于我们的代码库包含许多文件，我们决定采用模块级 Bazel 迁移，这意味着我们在模块级创建了 BUILD.bazel 文件。<br/></p><figure class="w-richtext-figure-type- "/><p><br/> BUILD.bazel 可定义如下:</p><ul role="list"><li><strong>java _ library</strong>:<em/>这是 Bazel 中的一个 java_rule，编译一组 Java 源文件，创建一个 jar。</li><li><strong>名称</strong>:该目标的唯一名称。将用于在构建时引用此目标。</li><li><strong> @maven </strong> : <em> </em>这里 maven 是我们在 WORKSPACE 中定义的目标的名称。通过组合 groupId 后跟 artifactId 并以 _ 分隔来引用依赖关系。我们需要更换每一个。groupId 和 artifactId 中的 with _ in。</li><li><strong> srcs </strong> : <em> </em>我们希望包含在这个目标中并一起构建的一组 Java 源文件。</li><li><strong>deps</strong>:<em/>src 的所有依赖关系都在 deps 下定义。它可以有外部依赖项，也可以有项目中的其他目标。</li></ul><p>创建 BUILD.bazel 文件后，我们可以运行下面的命令来构建这个目标:</p><p>bazel 构建路径到目录:模块</p><p>这里，path_to_directory 是从项目根目录到 Build.bazel 文件目录的相对路径。</p><h2>迁移过程中的障碍</h2><p>在这里，我们将讨论从 Maven 迁移到 Bazel 时所面临的挑战。我们还将讨论应对挑战的解决方案。</p><h3>大型代码库</h3><p>我们有一个庞大的代码库和 100 多个相互依赖的模块。因此，我们不能一次性迁移整个存储库。</p><p>如前所述，我们需要一个允许迭代迁移的策略，并且不会对当前的开发工作产生太大影响。为此，我们提出了一种方法，我们称之为混合方法。</p><p><strong>混合方法</strong>:我们有一个要求，我们要迁移到 Bazel 的模块只能依赖于 Bazel 模块(它可以依赖于外部库，但不能依赖于本地 Maven 模块)。因此，我们从独立/叶模块开始迁移。</p><ul role="list"><li>我们创建了一个脚本，并将这个脚本挂在 Maven 的 pom.xml 文件中。因此，当我们运行 Maven 构建时，首先执行这个脚本，它构建所有的 Bazel 模块并在本地 Maven 存储库中安装工件(在我们的例子中是~ ~/. m2/repository)。</li><li>然后，Maven 继续构建 Maven 模块，这些模块可以依赖于 Bazel 模块。Maven 将 Bazel 模块视为外部依赖项。由于 Bazel 模块的构件已经安装在本地 Maven repo 中，Maven 只是进行构建，而不关心这些依赖项是外部库还是 Bazel 构建的构件。</li></ul><p>有了这个策略，我们能够在不影响<a href="https://harness.io/blog/developer-productivity/" target="_blank">开发人员生产力</a>的情况下迭代地迁移模块。</p><h3>运行所有单元测试</h3><p>Bazel 对于在一个目标中运行一组单元测试没有任何内置的规则。开发人员必须为每个单元测试文件编写一个目标。考虑到我们的代码库，我们将不得不编写大量的单元测试目标。那将是重复的工作，并且会使我们的构建文件非常大并且不可维护。</p><p>为了克服上述问题，我们编写了一个宏，当我们运行 Bazel 操作时，它为每个单元测试文件初始化 java_test 规则。这使得我们的 BUILD.bazel 文件更小、更干净、更易于维护。如果我们想要为所有的单元测试改变一个参数，我们可以简单地在宏中做这个改变，它将会为所有的测试目标反映出来。</p><figure class="w-richtext-figure-type- "/><p>在上面的宏中，我们有 runtime_deps = ["tests"]。这里的“tests”是一个 java_library 目标，它应该包含运行该模块的单元测试的所有依赖项。</p><p>下面是运行 Bazel 测试的命令:<br/> bazel 测试//relative _ path _ to _ module _ directory:fqn _ of _ test _ class</p><h3>固定单元测试</h3><p>最大的挑战之一是在将模块从 Maven 迁移到 Bazel 之后修复测试。90%的失败测试都是因为路径问题。Bazel 在自己的私有沙箱中运行测试——因此，当您的测试依赖于您的资源文件时，它会失败，因为您的文件可能不在沙箱中。</p><p>在每个资源文件夹中，我们都创建了一个 BUILD.bazel 文件。如果任何测试需要任何资源文件，测试目标将依赖于此目标。</p><figure class="w-richtext-figure-type- "/><h3>检查样式</h3><p>Bazel 没有对 checkstyle 的内置支持，所以我们需要手动集成它和其他静态检查。首先，我们使用 checkstyle 外部 jar 和我们的自定义 checkstyle 规则创建了 java_binary。</p><figure class="w-richtext-figure-type- "/><p>然后，我们在 Bazel 中创建了一个<strong> genrule </strong>,它接受 checkstyle 二进制文件，并在应用 checkstyle 参数后形成一个 shell 命令来执行该二进制文件。</p><figure class="w-richtext-figure-type- "/><p>现在，我们可以从模块级构建文件中调用这个 genrule，对该模块中的所有文件运行 checkstyle。</p><p><em>加载("//工具/检查样式:规则。bzl "，" checkstyle") </em></p><p><em> checkstyle() </em></p><p>我们可以使用 Bazel build 命令运行检查，如下所示:</p><p>bazel 构建相对路径到模块目录:checkstyle</p><p>同样，pmd 检查也可以集成到 Bazel 上。</p><h2>我们从 Maven 迁移到 Bazel 后的体验</h2><p>在完全从 Maven 迁移到 Bazel 之后，我们面临着正反两方面的问题。Maven 面临的挑战已经在 Bazel 迁移中介绍过了。</p><p>然而，在 Bazel 迁移之后，我们面临着一些新的问题。我们将在下面讨论优点和缺点。</p><h4><strong>优点</strong></h4><ul role="list"><li><strong>单元测试作业:</strong>测试作业的运行有了显著的改进。现在，单元测试工作所花费的时间取决于开发人员进行更改的模块。截止到 7 月 21 日，我们拥有单元测试工作的以下时间记录:</li></ul><figure class="w-richtext-figure-type- "><figcaption><em>Stats for unit-tests-0</em></figcaption></figure><figure class="w-richtext-figure-type- "><figcaption><em>Dashboard</em></figcaption></figure><ul role="list"><li><strong>跨分支工作的本地开发人员</strong>:当我们在多个分支上工作时，如果我们切换分支并进行同步，那么 Bazel 不会再次编译/同步整个回购，如果我们之前已经同步过它。Bazel 获取以前缓存的结果，只编译那些需要的结果。这样，开发人员可以很容易地同时在多个分支上工作。</li><li><strong>较少间歇性测试失败</strong>:<strong>T3】Bazel 在沙箱中运行测试，因此发生碰撞的几率很小。这降低了间歇性测试失败的可能性。</strong></li></ul><h4><strong>缺点</strong></h4><ul role="list"><li><strong>对 IntelliJ Bazel 插件</strong>的支持较少:与 Maven 插件相比，用于 IntelliJ 的<strong> </strong> Bazel 插件对特性的支持较少。Maven 已经足够成熟，可以添加对 IntelliJ 的支持，而 Bazel 是一项非常年轻的技术，要达到这种支持水平还需要一些时间。</li><li><strong>第一次项目同步需要更多时间</strong> : <strong> <em> </em> </strong> Bazel 工作在高粒度上，因此它有大量的动作要执行。它生成构建图，这有助于确定在更改后要重建什么。所有这些动作都会消耗一些时间，使得 Bazel 中的第一次/干净构建很慢。但是，Bazel 中的增量/无操作构建要快得多，这使得我们的整体构建更快。</li></ul><h2>结论</h2><p>我们对从 Maven 迁移到 Bazel 后得到的结果感到兴奋。迁移帮助我们提高了开发人员的工作效率，这帮助我们显著提高了构建和测试时间。</p><p>看起来你喜欢技术性的深潜！如果你对进一步阅读感兴趣，请查看我们在<a href="https://harness.io/blog/bugs-data-driven-quality/" target="_blank">上的文章:“多少个 bug 太多了?”？利用数据驱动的质量管理方法</a>和<a href="https://harness.io/blog/event-driven-architecture-redis-streams/" target="_blank">使用 Redis 流的事件驱动架构</a>。</p><p>本文由 Prashant Sharma 和 Brijesh Dhakar 合作撰写。</p><p>Prashant Sharma 是 Harness 的一名软件后端工程师。他是负责实施和迁移到 Bazel 的团队的核心成员，并参与构建线束管道的新迭代。</p><p>Brijesh Dhakar 是一名热爱技术的软件工程师。他在 Harness 工作，构建首要的软件交付平台来解决整个行业的问题。</p></div></div>    
</body>
</html>