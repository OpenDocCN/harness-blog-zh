<html>
<head>
<title>Migrating to Bazel as a Build Tool - Why We Left Maven | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>迁移到Bazel作为构建工具——为什么我们离开Maven | Harness</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/migrating-bazel-build-tool#0001-01-01">https://www.harness.io/blog/migrating-bazel-build-tool#0001-01-01</a></blockquote><div><p>我们与Maven一起回顾了我们面临的挑战，为什么我们决定选择Bazel，我们如何迁移，以及我们看到了什么结果。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>在Harness，我们完整的代码库在一个GitHub repo中。它由大约500万行代码和100多个相互依赖的模块组成。我们开始观察到构建时间每周都在增加，而我们现有的构建工具(Maven)无法随着我们不断增长的需求而扩展。在这篇博文中，我们将回顾我们在Maven上面临的挑战，为什么我们决定使用Bazel，我们如何迁移，以及我们看到了什么结果。</p><h2>Maven的挑战</h2><ul role="list"><li><strong>缺乏增量构建支持</strong> <em> — </em>当我们对数百个模块中的一个进行小的改动时，Maven通常需要干净的构建。作为一个快速发展的组织，我们以很快的速度加入了新的模块。随着代码的增加，每次构建所花费的时间会显著增加。</li><li><strong>本地开发问题</strong> —对于本地开发来说，分支切换然后重新构建整个项目是一个棘手的问题。开发人员必须等待大约20-25分钟，项目才能同步。</li><li><strong>单元测试作业所花费的时间</strong> —持续集成中的最大时间是单元测试作业所花费的时间。当开发人员做了一个小的改变时，理想情况下，它应该只运行依赖单元测试。但是Maven执行所有的单元测试，不管代码有什么变化。例如:如果开发人员更新了自述文件，就不需要运行任何单元测试。但是开发者不得不等待所有的测试通过。我们分三批运行单元测试:单元测试-0、单元测试-1和单元测试-2。随着代码和单元测试的增加，单元测试工作所花费的时间也在增加。</li></ul><figure class="w-richtext-figure-type- "/><p>在这个关键时刻，我们意识到我们需要寻找一个替代方案来满足我们未来的需求。</p><h2>为什么是巴泽尔？</h2><p>Bazel是谷歌在2015年开发的开源构建工具。它用于构建和测试软件。我们选择Bazel作为以下属性的构建系统:</p><ul role="list"><li><strong>快</strong>:<em>T3】巴泽尔是<em>快</em>。通过分析依赖图，Bazel确切地知道需要重建什么。Bazel缓存所有以前完成的工作，只重建需要的部分。此外，Bazel可以并行构建我们的项目。例如，如果我们有三个名为A、B和C的模块，其中A依赖于B and B，而C依赖于它，如果你在模块B中做了更改，Bazel将只构建模块A和B，而不是C</em></li><li><strong>正确/可重现的构建</strong> : <em> </em>如果你用相同的参数构建相同的代码，它将总是输出相同的构建。</li><li><strong>更少的间歇性测试失败</strong> : Bazel在沙箱中运行测试。碰撞的机会非常少，这导致间歇性测试失败的可能性更小。</li></ul><h2><strong>概念验证(POC) </strong></h2><p>为了证实这一点，我们从Maven中取出了两个模块——模块A和B，其中B依赖于A(B-&gt; A)——并在那里测试了Bazel的变化。我们还在GCP上创建了一个缓存桶。以下是我们的发现:</p><ol role="list"><li><strong>第一次运行两个模块</strong> —我们观察到两个模块测试都在没有任何缓存的情况下运行。</li><li><strong>在模块A中进行更改</strong> <em> — </em>两个模块都已构建，所有测试都已运行。</li><li><strong>在模块B中进行更改</strong> <em> — </em>在这种情况下，缓存了模块A，只构建了模块B。模块B的测试运行，而模块A的测试被缓存。与上述两个用例相比，整个过程花费的时间更少。</li><li><strong>任何模块都没有变化</strong> <em> — </em>没有构建模块。模块A和B都被缓存了。两个模块的测试也被缓存。在上述所有案例中，耗时最短。为了测试缓存，我们还在模块b的一个测试中添加了一个sleep语句。在没有缓存的情况下，测试运行接近30秒，而在有缓存的情况下，只需不到一秒。我们知道有些模块需要很长时间来构建和运行测试。通过缓存，我们节省了大量时间。因此，我们决定从Maven搬到Bazel。</li></ol><h2>迁移</h2><p>我们在迁移时面临的挑战之一是我们有100多个模块要迁移。一次性迁移所有这些模块是不可能的。因此，我们决定采用混合方法。这里，“混合方法”意味着我们同时使用了Maven和Bazel。转换成Bazel的模块是通过Bazel构建的，其余的是通过Maven构建的。我们将在这篇博客的后半部分讨论这个问题。</p><p>在这里，我们将讨论如何将一个简单的模块从Maven迁移到Bazel。</p><h3><strong>工作空间</strong></h3><p>我们可以将其与Maven中的中心pom.xml文件进行比较。在Bazel中，这个文件位于项目的根层，我们在这里定义外部依赖项，类似于我们在Maven的pom.xml中的做法。</p><figure class="w-richtext-figure-type- "/><p>对于外部Maven依赖项，我们使用rules_jvm_external。这是一个外部库，它以传递方式获取这些依赖项。</p><p>添加依赖项时遵循的模式是:groupId:artifactId:version</p><p><strong>例子:</strong></p><p>在下图中，首先，我们加载rules_jvm_external。然后，我们使用<br/> maven_install来获取外部maven依赖项。</p><figure class="w-richtext-figure-type- "/><h3>BUILD .巴塞尔协议</h3><p>这个文件可以在模块级和文件级创建。由于我们的代码库包含许多文件，我们决定采用模块级Bazel迁移，这意味着我们在模块级创建了BUILD.bazel文件。<br/></p><figure class="w-richtext-figure-type- "/><p><br/> BUILD.bazel可定义如下:</p><ul role="list"><li><strong>java _ library</strong>:<em/>这是Bazel中的一个java_rule，编译一组Java源文件，创建一个jar。</li><li><strong>名称</strong>:该目标的唯一名称。将用于在构建时引用此目标。</li><li><strong> @maven </strong> : <em> </em>这里maven是我们在WORKSPACE中定义的目标的名称。通过组合groupId后跟artifactId并以_分隔来引用依赖关系。我们需要更换每一个。groupId和artifactId中的with _ in。</li><li><strong> srcs </strong> : <em> </em>我们希望包含在这个目标中并一起构建的一组Java源文件。</li><li><strong>deps</strong>:<em/>src的所有依赖关系都在deps下定义。它可以有外部依赖项，也可以有项目中的其他目标。</li></ul><p>创建BUILD.bazel文件后，我们可以运行下面的命令来构建这个目标:</p><p>bazel构建路径到目录:模块</p><p>这里，path_to_directory是从项目根目录到Build.bazel文件目录的相对路径。</p><h2>迁移过程中的障碍</h2><p>在这里，我们将讨论从Maven迁移到Bazel时所面临的挑战。我们还将讨论应对挑战的解决方案。</p><h3>大型代码库</h3><p>我们有一个庞大的代码库和100多个相互依赖的模块。因此，我们不能一次性迁移整个存储库。</p><p>如前所述，我们需要一个允许迭代迁移的策略，并且不会对当前的开发工作产生太大影响。为此，我们提出了一种方法，我们称之为混合方法。</p><p><strong>混合方法</strong>:我们有一个要求，我们要迁移到Bazel的模块只能依赖于Bazel模块(它可以依赖于外部库，但不能依赖于本地Maven模块)。因此，我们从独立/叶模块开始迁移。</p><ul role="list"><li>我们创建了一个脚本，并将这个脚本挂在Maven的pom.xml文件中。因此，当我们运行Maven构建时，首先执行这个脚本，它构建所有的Bazel模块并在本地Maven存储库中安装工件(在我们的例子中是~ ~/. m2/repository)。</li><li>然后，Maven继续构建Maven模块，这些模块可以依赖于Bazel模块。Maven将Bazel模块视为外部依赖项。由于Bazel模块的构件已经安装在本地Maven repo中，Maven只是进行构建，而不关心这些依赖项是外部库还是Bazel构建的构件。</li></ul><p>有了这个策略，我们能够在不影响<a href="https://harness.io/blog/developer-productivity/" target="_blank">开发人员生产力</a>的情况下迭代地迁移模块。</p><h3>运行所有单元测试</h3><p>Bazel对于在一个目标中运行一组单元测试没有任何内置的规则。开发人员必须为每个单元测试文件编写一个目标。考虑到我们的代码库，我们将不得不编写大量的单元测试目标。那将是重复的工作，并且会使我们的构建文件非常大并且不可维护。</p><p>为了克服上述问题，我们编写了一个宏，当我们运行Bazel操作时，它为每个单元测试文件初始化java_test规则。这使得我们的BUILD.bazel文件更小、更干净、更易于维护。如果我们想要为所有的单元测试改变一个参数，我们可以简单地在宏中做这个改变，它将会为所有的测试目标反映出来。</p><figure class="w-richtext-figure-type- "/><p>在上面的宏中，我们有runtime_deps = ["tests"]。这里的“tests”是一个java_library目标，它应该包含运行该模块的单元测试的所有依赖项。</p><p>下面是运行Bazel测试的命令:<br/> bazel测试//relative _ path _ to _ module _ directory:fqn _ of _ test _ class</p><h3>固定单元测试</h3><p>最大的挑战之一是在将模块从Maven迁移到Bazel之后修复测试。90%的失败测试都是因为路径问题。Bazel在自己的私有沙箱中运行测试——因此，当您的测试依赖于您的资源文件时，它会失败，因为您的文件可能不在沙箱中。</p><p>在每个资源文件夹中，我们都创建了一个BUILD.bazel文件。如果任何测试需要任何资源文件，测试目标将依赖于此目标。</p><figure class="w-richtext-figure-type- "/><h3>检查样式</h3><p>Bazel没有对checkstyle的内置支持，所以我们需要手动集成它和其他静态检查。首先，我们使用checkstyle外部jar和我们的自定义checkstyle规则创建了java_binary。</p><figure class="w-richtext-figure-type- "/><p>然后，我们在Bazel中创建了一个<strong> genrule </strong>,它接受checkstyle二进制文件，并在应用checkstyle参数后形成一个shell命令来执行该二进制文件。</p><figure class="w-richtext-figure-type- "/><p>现在，我们可以从模块级构建文件中调用这个genrule，对该模块中的所有文件运行checkstyle。</p><p><em>加载("//工具/检查样式:规则。bzl "，" checkstyle") </em></p><p><em> checkstyle() </em></p><p>我们可以使用Bazel build命令运行检查，如下所示:</p><p>bazel构建相对路径到模块目录:checkstyle</p><p>同样，pmd检查也可以集成到Bazel上。</p><h2>我们从Maven迁移到Bazel后的体验</h2><p>在完全从Maven迁移到Bazel之后，我们面临着正反两方面的问题。Maven面临的挑战已经在Bazel迁移中介绍过了。</p><p>然而，在Bazel迁移之后，我们面临着一些新的问题。我们将在下面讨论优点和缺点。</p><h4><strong>优点</strong></h4><ul role="list"><li><strong>单元测试作业:</strong>测试作业的运行有了显著的改进。现在，单元测试工作所花费的时间取决于开发人员进行更改的模块。截止到7月21日，我们拥有单元测试工作的以下时间记录:</li></ul><figure class="w-richtext-figure-type- "><figcaption><em>Stats for unit-tests-0</em></figcaption></figure><figure class="w-richtext-figure-type- "><figcaption><em>Dashboard</em></figcaption></figure><ul role="list"><li><strong>跨分支工作的本地开发人员</strong>:当我们在多个分支上工作时，如果我们切换分支并进行同步，那么Bazel不会再次编译/同步整个回购，如果我们之前已经同步过它。Bazel获取以前缓存的结果，只编译那些需要的结果。这样，开发人员可以很容易地同时在多个分支上工作。</li><li><strong>较少间歇性测试失败</strong>:<strong>T3】Bazel在沙箱中运行测试，因此发生碰撞的几率很小。这降低了间歇性测试失败的可能性。</strong></li></ul><h4><strong>缺点</strong></h4><ul role="list"><li><strong>对IntelliJ Bazel插件</strong>的支持较少:与Maven插件相比，用于IntelliJ的<strong> </strong> Bazel插件对特性的支持较少。Maven已经足够成熟，可以添加对IntelliJ的支持，而Bazel是一项非常年轻的技术，要达到这种支持水平还需要一些时间。</li><li><strong>第一次项目同步需要更多时间</strong> : <strong> <em> </em> </strong> Bazel工作在高粒度上，因此它有大量的动作要执行。它生成构建图，这有助于确定在更改后要重建什么。所有这些动作都会消耗一些时间，使得Bazel中的第一次/干净构建很慢。但是，Bazel中的增量/无操作构建要快得多，这使得我们的整体构建更快。</li></ul><h2>结论</h2><p>我们对从Maven迁移到Bazel后得到的结果感到兴奋。迁移帮助我们提高了开发人员的工作效率，这帮助我们显著提高了构建和测试时间。</p><p>看起来你喜欢技术性的深潜！如果你对进一步阅读感兴趣，请查看我们在<a href="https://harness.io/blog/bugs-data-driven-quality/" target="_blank">上的文章:“多少个bug太多了?”？利用数据驱动的质量管理方法</a>和<a href="https://harness.io/blog/event-driven-architecture-redis-streams/" target="_blank">使用Redis流的事件驱动架构</a>。</p><p>本文由Prashant Sharma和Brijesh Dhakar 合作撰写。</p><p>Prashant Sharma是Harness的一名软件后端工程师。他是负责实施和迁移到Bazel的团队的核心成员，并参与构建线束管道的新迭代。</p><p>Brijesh Dhakar是一名热爱技术的软件工程师。他在Harness工作，构建首要的软件交付平台来解决整个行业的问题。</p></div></div>    
</body>
</html>