<html>
<head>
<title>What Is an Artifact Repository? | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>什么是工件库？装具</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/what-is-artifact-repository#0001-01-01">https://www.harness.io/blog/what-is-artifact-repository#0001-01-01</a></blockquote><div><p>工件存储库安全地存储在构建和部署过程中生成的工件。立即了解关键注意事项！</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>工件存储库是软件开发过程中不可或缺的一部分，这一点经常被遗忘并被认为是理所当然的。在整个构建过程中，工件被创建，随着持续集成过程的完成，新的工件被生产和存储，允许持续交付过程通过不同的<a href="https://harness.io/blog/deployment-environments/" target="_blank">环境</a>将工件引入生产。工件是交付过程的生命线，其中具有执行的、一致的和可持续的结果依赖于深思熟虑的工件管理。版本控制、安全性和依赖项管理只是刚刚开始触及CI/CD过程中提供的主要好处的表面。</p><h2>什么是工件库？</h2><p>工件存储库的核心功能是安全地存储生成的工件。这些工件用于构建期间的优化，以及最终的发布。容器映像、二进制工件、java工件和软件包只是需要管理的工件类型的几个例子。这是一个不同于源代码管理的功能，因为工件被作为不同的对象来处理和版本化。</p><figure class="w-richtext-figure-type- "/><h2>工件仓库的用例</h2><p>为了简单起见(以及您的时间，亲爱的读者)，我们将关注您将在现代DevOps中遇到的两个最常见的高级用例。使用的工具可能重叠，也可能完全不同。</p><h3>构建工件</h3><p>在最复杂的软件系统的情况下，一个构建包括多个阶段、许多依赖项和多个组件，以生产用于部署的工件。构建工具提供了一个框架来管理这些依赖关系，并优化将源代码转化为已编译的二进制工件的过程。值得注意的构建工具包括Maven、Gradle、Make、Bazel，以及许多特定于语言和用例的工件管理工具。</p><h3>部署工件</h3><p>与中间工件不同，部署工件被版本化、安全化，并作为单一的事实来源集中起来。通常配置为远程存储库，这些存储库用作从CI到CD的交接点。容器图像正迅速成为最流行的格式之一；尽管是二进制，像舵图等配置也很常见。现在最流行的存储库包括DockerHub、ECR、JFrog等等。</p><h2>工件仓库的主要考虑事项</h2><p>让我们来看看在围绕什么样的存储库能够满足您的需求做出决策时，您应该寻找的一些最重要的品质。</p><h3>集中式与分布式</h3><p>出于安全和效率的原因，在哪里设置存储库很重要。有集中式模型、利用本地缓存的模型和分散/公共模型。为了管理和简化，一个集中的远程存储库可以更密切地跟踪正在使用的软件，并简化发布过程。集中化的代价是潜在的低性能，在不同的区域推拉工件可能需要更长的时间。</p><p>本地管理的存储库可能性能更高，但也会带来管理服务器、软件和存储的开销。随着云提供商变得越来越普遍，他们提供的一个好处是能够在不同的区域集中和托管数据，以帮助提高性能。</p><h3>版本支持</h3><p>除了命名约定之外，元数据(如日期、版本和其他常见属性)的正确存储提供了正确的文档和可追溯性。与失宠的特定实践相反，离散的工件减少了部署错误代码的风险，或者减少了审计部署了什么以及何时部署的能力的损失。</p><h3>许可</h3><p>分层安全性是最佳实践，保护工件的许多方法之一是控制它们的存储和分发方式。基于角色的访问控制 (RBAC)应该规定谁可以在哪个存储库中存储工件，以及谁可以提取相同的工件。</p><h3>可审计性</h3><p>版本符合权限。可审计性意味着对访问、工件历史以及影响工件的任何其他事件有完整的书面记录。</p><h3>扫描</h3><p>作为设计良好的软件交付过程的一部分，您的工件存储库提供了一个方便的瓶颈，就在代码进入生产之前。如果所有上传到服务器的东西都必须通过一个存储库(没有专门的修补程序)，那么在交付之前，运营部门就有能力仔细检查可交付产品的每一个方面。这可能包括寻找易受攻击的库、恶意代码、验证许可证使用等的安全扫描。</p><h3>软件材料清单(SBOM)</h3><p>材料清单(BOM)已经成为现代物理产品制造的一个组成部分。随着软件变得越来越复杂，越来越依赖于第三方库，软件团队没有时间去编译和理解构建复杂系统的每一个组件。将所有信息汇集在一起的过程跨越了软件开发，并且存储库提供了最后的大门，用于对构建用于生产的软件的每个组件进行完整的清点。</p><h2>工件储存库类型</h2><p>这里没有办法创建一个详尽的列表，因为可能的工件数量无穷无尽。有针对特定工件的同类最佳工具，也有通用的包存储库管理器。以下是您将会看到的最常见类别的简短列表。</p><h3>容器图像</h3><p>在一个越来越多的dockerized的世界中，这个类别很快成为开发团队的首要考虑。容器的主要好处是能够将所有的代码和依赖项作为一个整体运输，而它的缺点是潜在的大型工件和运输漏洞隐藏在几个抽象层之下。此类别中的最佳工具解决了层的正确存储，并提供了扫描潜在漏洞的能力。</p><h3>构建存储库</h3><p>Maven仓库是一个流行的例子。它们既可以在本地用于中间工件，也可以远程使用，包括许多公开可用的回购。</p><h3>应用程序包存储库</h3><p>包管理工具，如Pip、npm、Ivy等。依赖于各种特定于语言/技术的包管理器，比如PyPi和npm库。</p><h2>有哪些工件库管理工具？</h2><p>这里有一个你将会在今天的团队中看到的不同工具的例子。考虑到这个主题的广度，这些并不都是相互竞争的工具，而是涉及工件管理不同方面的工具。</p><h3>阿帕奇Maven</h3><p>Maven最常用于Java，尽管它也可以用于支持其他语言。Maven主要负责构建软件和管理依赖关系。在Maven项目中，依赖项和其他构建信息是在XML文件中描述的。作为构建过程的一部分，Maven将从远程Maven资源库下载库。</p><figure class="w-richtext-figure-type- "/><h3>巴泽尔</h3><p>它由谷歌在2015年发布，通过使用依赖关系图分析，以极快的速度和出色的依赖关系管理迅速走红。在Harness，我们最近<a href="https://harness.io/blog/migrating-bazel-build-tool/" target="_blank">从Maven切换到Bazel </a>以加速我们的开发过程。简而言之，作为一个快速发展的组织，Maven提供的许多依赖管理并不适合我们的需求。在Bzlmod的帮助下，Bazel还允许使用外部依赖项，包括公共的和私有的。</p><h3>Docker图像存储库</h3><p>很难在这里选择一个。每个云提供商都在亚马逊的ECR、谷歌的GCR和Azure的ACR中提供自己的服务。如果这些都不是你的答案，还有很多很棒的工具。JFrog Artifactory提供了过多的包格式，Dockerhub是默认的存储库(这是它的名字！)，而VMWare的Harbor是一个考虑到安全性而构建的开源选项。</p><h2>CI/CD中的工件管理</h2><p>一些简单但重要的最佳实践。</p><h3>安全第一</h3><p>CI/CD最近在一份报告中被<a href="https://research.nccgroup.com/2022/01/13/10-real-world-stories-of-how-weve-compromised-ci-cd-pipelines/" target="_blank">确定为恶意行为者的主要目标之一，因为其对系统和最终工件的访问级别很高。在设计管道时要考虑安全性，不要在事后添加！</a></p><h3>自动化一切</h3><p>自动化允许重复性并减少手工劳动。手动流程中的微小不一致会使您面临流程崩溃以及审核失败的风险。</p><h3>不要重新发明轮子</h3><p>CI/CD中的工件管理已经解决了很多次。不要编写以后必须维护的定制集成。</p><figure class="w-richtext-figure-type- "/><h2>结论</h2><p>今天的构建过程变得越来越复杂，有许多关于保护您的软件材料清单、适当的测试、速度和资源的有效使用的考虑——而所有这些都<em>而不是</em>给已经被要求比以往更快交付的团队增加了额外的工作。</p><p>你的构建工具支持所有这些野心吗？Harness CD集成了所有同类最佳的工件存储库，Harness CI自动化了管理构建工具的麻烦。同时让您专注于满足客户的需求。<a href="https://app.harness.io/auth/#/signup" target="_blank">今天就来试试</a>。</p></div></div>    
</body>
</html>