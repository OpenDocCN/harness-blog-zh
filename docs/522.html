<html>
<head>
<title>What Is ChartMuseum, and How Do We Use it in CD? | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>什么是ChartMuseum，我们如何在CD中使用它？装具</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/what-is-chart-museum#0001-01-01">https://www.harness.io/blog/what-is-chart-museum#0001-01-01</a></blockquote><div><p>有时候，舵轮图是不够的，我们需要一点帮助。进入ChartMuseum。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>通过部署可扩展的内部和外部基础设施和解决方案，利用连续交付使组织能够更快地对市场和客户做出响应。为了构建这些解决方案，Kubernetes集群启动并运行后安装的第一批包之一可能是Helm。</p><h2>什么是头盔？</h2><p>Helm是第一个在Kubernetes上运行的应用程序包管理器。它允许用户通过方便的舵图描述应用程序结构，并使用简单的命令管理它。这是服务器端应用程序定义、存储和管理方式的巨大转变。</p><p>使用Helm这样的包管理器可以减少编排包管理器中定义的步骤的重复和复杂性。Helm中的图表是Helm运行的主要格式。Helm Chart是描述一组Kubernetes资源的文件集合。像其他基于惯例的包管理器格式一样，舵图遵循一个目录结构/树。舵图可以存档并发送到舵图存储库。Helm是一个安装在Kubernetes集群外部的客户端，它利用kubectl来连接和交互Kubernetes集群。这些图表可以很容易地存储在图表库中。</p><p>图表存储库是一个HTTP服务器，它包含一个名为index.yaml的文件，也可以包含一些打包的图表。当您第一次构建图表存储库并准备上传图表时，存储库将生成一个名为index.yaml的文件。存储库索引(index.yaml)是根据存储中找到的包动态生成的。该文件包含图表的元数据，当新图表上传到存储库时，这些元数据将被写入该文件。它将在部署时用于获取图表，因为它包含所有必需的信息。如果您存储自己版本的index.yaml，它将被完全忽略——所以这一点要记住！</p><p>如果需要协调不止一个Kubernetes资源，并且有多个配置不同的集群，那么就有充分的理由利用Helm。软件供应商和开源项目都可以通过使用Helm resources作为客户将应用程序安装到Kubernetes集群的一种方式而受益。</p><h2>什么是ChartMuseum？</h2><p>考虑到以上所有的好处，人们可能会问为什么需要图表博物馆。让我们从了解什么是ChartMuseum开始。</p><p>ChartMuseum是一个用Go (Golang)编写的开源Helm Chart知识库，支持云存储后端，包括谷歌云存储、亚马逊S3、微软Azure Blob存储、阿里云OSS存储和Openstack对象存储。它用于存储和提供舵图，以将应用程序部署到Kubernetes集群。ChartMuseum执行图表管理工具的任务。当图表上传到云商店时，ChartMuseum就像一个二进制程序一样获取和维护图表信息。</p><h2>图表博物馆的好处</h2><p>当我们看一看使用Helm的局限性时，我们可以观察到，当我们设置存储库来存储图表时，Helm只支持基于HTTP的存储库，不支持<a href="https://harness.io/blog/secrets-management-ci-cd/" target="_blank"> Secrets </a>，这导致Helm无法处理OAuth。在ChartMuseum的情况下，当它运行时，有一个本地图表服务器在您选择的端口上启动，它具有处理和存储凭证的能力。这允许进行身份验证。它还处理更多的API，而Helm只能处理少数API。</p><figure class="w-richtext-figure-type- "/><p>当Chart Museum启动时，它会公开一个API，您可以使用它来操作和获取图表。Helm不是这样的，因为它需要获取index.yaml文件来列出可用的图表。如果用户删除了index.yaml文件，他们将无法根据请求获取图表。为了解决这个问题，当index.yaml被删除并重新生成时，ChartMuseum将在名为index-cache.yaml的存储中保存一个状态文件，用于缓存优化。该文件仅供内部使用，但可用于迁移到简单存储。</p><p>它做得非常好的另一件事是index.yaml文件的转换。详细说明:为了获取可用图表列表，Helm真正理解的唯一文件是index.yaml文件。在云后端的情况下，它可以像S3桶一样用作图表存储库，当我们开始将图表上传到S3桶时，它会生成一个index-cache.yaml(不像其他基于HTTP的repos，它们会生成一个index.yaml文件)。这个文件包含图表元数据，但是index-cache.yaml不能被Helm理解，因为它只能理解像index.yaml这样的文件。</p><p>在这种情况下，ChartMuseum扮演了一个伟大的调解人。当Helm调用获取图表存储库的索引细节时，它会访问ChartMuseum，因为Helm无法直接访问S3存储桶(它无法对其进行身份验证并理解协议)。因此，ChartMuseum调用S3存储桶，并使用存储机密的功能对其进行验证并获取index-cache.yaml。但由于Helm无法理解这个index-cache.yaml文件，ChartMuseum将其转换为Helm可以理解的格式，并向其发送所有详细信息。</p><h2>我们如何利用图表博物馆</h2><p>当我们计划部署存储在像GCS或S3这样的云存储库中的舵图时，我们需要ChartMuseum的帮助。当我们创建一个将被用作图表存储库的S3连接器，然后在我们的服务中添加该连接器时，后台进程将如下所示:</p><p>1.首先选择能够执行任务的代表。然后它下载ChartMuseum库二进制文件(类似于kubectl二进制文件的下载方式)并运行ChartMuseum。</p><p>2.ChartMuseum一旦启动，就在一个带有公开API的端口上运行，该API可用于从存储库中获取图表。</p><figure class="w-richtext-figure-type- "/><p>3.赫尔姆然后在这个港口与海图博物馆联系。对于Helm来说，ChartMuseum只是一个HTTP服务器，帮助它访问云回购端点并向其进行身份验证。</p><p>4.一旦ChartMuseum完成了对云回购的认证，它就会获取索引文件并发送给Helm。这导致图表列表显示在Harness' end上。</p><figure class="w-richtext-figure-type- "/><p>5.获取图表列表后，ChartMuseum在委托上停止。Repo在本地从委托中移除，就像从缓存文件中删除条目一样。整个过程如下所示:</p><figure class="w-richtext-figure-type- "/><p>ChartMuseum支持各种各样的后端，如GCS、S3、微软Azure和Openstack，而Helm不支持将它们用作图表存储库所需的协议。对于云提供的后端，还存在一层额外的安全性，这需要使用Secrets &amp; OAuth对端点进行身份验证。目前Helm Repo的标准是使用匿名HTTP或者HTTP基本认证，所以Helm并不了解什么是秘密，如何使用秘密。Helm本身并不是一个可行的选择，因为它无法理解不同云后端使用的各种协议。它也无法对他们进行身份验证。这就是海图博物馆发挥关键作用的地方。</p><p>ChartMuseum确实有一些内部缓存，可以在停止后保留数据。我们在与ChartMuseum相关的Harness端没有任何缓存。</p><h2>常见问题</h2><p>当使用ChartMuseum时，我们确实会遇到一些与图表未按预期获取相关的常见问题。这会导致用户界面出错。让我们来看看可能发生的常见错误。</p><h3>图表博物馆未启动</h3><p>我们注意到ChartMuseum最常见的问题是，当代表在后台从云报告中获取图表时，Helm需要与ChartMuseum通信以获得这些细节。代理在后台运行ChartMuseum，我们必须等待它完成。</p><p>ChartMuseum作为基于HTTP的服务器运行在Helm用来与Repos通信的端口上。当ChartMuseum启动时，虽然进程已经启动，但是端口并没有分配给服务器。这导致上面的错误出现。</p><p>可以通过将连接器重新添加到服务中来解决此错误。当然，这将要求代理创建一个新任务，并再次启动ChartMuseum服务器，然后从那里分配端口。</p><h3>超时设定</h3><p>与上述问题类似，当我们在服务级别上链接一个连接器以从云存储库中获取图表时，可能会发生超时。这些超时可能与存储库或其上的index.yaml文件的大小有关。</p><p>当ChartMuseum与cloud Repo通信时，我们有一个特定的超时时间。如果我们在分配的时间内没有得到响应，就会导致超时。</p><h2>结论</h2><p>正如在这篇简短的文章中所看到的，使用Helm对于我们在Kubernetes中处理应用程序有很多好处。随着ChartMuseum的加入，存储和版本控制我们的应用程序包变得轻而易举。此外，部署这个工具很简单，这就是为什么我们有各种各样的客户端能够使用他们选择的多个云后端来存储舵图。</p><p>关于头盔的进一步阅读，请查看我们的<a href="https://harness.io/blog/helm-vs-kustomize/" target="_blank">头盔vs. Kustomize </a>博客，以及我们的<a href="https://harness.io/blog/what-is-helm/" target="_blank">什么是头盔</a>的文章，其中包含了如何启动你的第一个头盔部署的教程。如果你还没有注册线束，今天就可以自由地<a href="https://app.harness.io/auth/#/signup/" target="_blank">注册</a>-开始是免费的。来成为火箭飞船的一部分吧！</p><p>干杯！</p></div></div>    
</body>
</html>