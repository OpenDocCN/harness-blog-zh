<html>
<head>
<title>Top 5 Java Logging Frameworks | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>5大Java日志框架| Harness</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/top-5-java-logging-frameworks#0001-01-01">https://www.harness.io/blog/top-5-java-logging-frameworks#0001-01-01</a></blockquote><div><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>日志记录是几乎每个服务器端应用程序的一个由来已久的固有部分。这是应用程序以持久可读的方式输出实时状态的主要方法。一些应用程序可能一天只记录几兆字节，而其他应用程序可能在几个小时内记录几十亿字节或更多的数据。</p><p>由于日志记录通常需要IO将数据写入磁盘(阻塞或异步)，因此这是有代价的。当在短时间内记录大量数据时，该成本会迅速增加。我们决定深入了解一些当今领先的日志引擎的速度。</p><p>大多数开发人员记录数据有三个主要原因——</p><ol role="list"><li>监控——查看代码在吞吐量、规模、安全性等方面的表现..</li><li>调试——访问导致代码失败的状态(变量、堆栈跟踪等)。OverOps帮助开发人员调试登台和生产服务器，并理解代码崩溃和线程冻结的原因。</li><li>分析——利用应用程序中的实时数据，得出关于其使用方式的结论。</li></ol><p>在门面后面。如今，大多数库都在代码的关键点内置了日志记录，以提供对其操作的可见性。为了简化这一过程并防止不同的库在同一个JVM中使用多种日志记录方法，将代码从底层引擎中分离出来的日志记录facades已经成为最前沿的技术。当我们分析排名前100的Java软件库时，SLF4J成为了当今开发人员使用的主要日志门面。</p><h2>竞争</h2><p>我们决定挑选五个当今最著名的伐木引擎，看看它们在一些比赛中表现如何。现在，在您拿出火把和干草叉之前，我想澄清一下，重点不是说哪一个更好，而是给出一些常见日志记录任务的引擎之间吞吐量差异的感觉。</p><h2>参赛者们</h2><ol role="list"><li>Log4J</li><li>Log4J2</li><li>回溯</li><li>SLF4J简单测井(SLF4J SL)</li><li>Java实用程序日志记录(7月)</li></ol><h2>这场比赛</h2><p>我们想看看这些引擎在一组标准日志记录活动中的表现如何。每个日志记录操作都包括一个时间戳和一个线程ID作为其上下文。</p><p>这些是比赛:</p><ol role="list"><li>记录字符串常量</li><li>记录。POJO的toString()值</li><li>记录可抛出对象</li><li>记录不带时间/tid上下文的字符串常量</li></ol><h2>赛道</h2><p>我们决定每场比赛举行五次预赛，以确定最佳成绩，测量完成的伐木作业数量。在每个测试中，我们给日志引擎一个在一分钟内跨10个线程执行的任务(测试分别运行)。然后，我们取出偏差最大的两次预赛，并对其余三次的结果进行平均。</p><p>在每个单独的日志操作之间，我们给CPU一些工作来在日志操作之间留出一些空间(检查一个小的随机数是否是质数)。这些引擎都使用默认配置在SLF4J之后运行。基准测试在Amazon m1.large EC2实例上运行。</p><p>更新:在我们最初的测试中，Log4J2配置了一个%C合格的类布局，这增加了它的开销。在@RemkoPopma的建议下，我们将配置更新为%c (logger name ),以符合其他配置，这给了Log4J2相当大的性能提升，如下所示。这绝对是值得注意的事情，并且真正突出了记录上下文数据的成本。</p><h2>竞赛# 1–字符串常量</h2><p>在这场竞赛中，引擎记录了一个字符串常量以及线程和时间戳上下文。Log4J显然是这里的赢家，能够比JUL多写270%的行，比logback多写12.5%，比SLF4J SL多写52%。有趣的是，在我们改变Log4J2的配置之前，它可以写4X(！)更少的行，交换机将其提升#3，写入的行仅比logback少30%。</p><h2>第二场比赛。toString()</h2><p>在这场比赛中，引擎正在记录一个POJO(通过其。toString)以及线程和时间戳上下文。这里的结果非常接近，Log4J2以25%的优势(变化后)排名第一，而SLF4J SL排名第二。Log4J和Logback并列第三，JUL以SLF4J SL 88%的吞吐量获得银牌。</p><h2>比赛# 3–可投掷</h2><p>在这场竞赛中，引擎记录一个异常对象和一个描述字符串以及线程和时间戳上下文。在这场比赛中，Log4J2火了，以超过3X(！)乘以行数，与第5位的SLF4J SL进行比较。</p><p>Log4J和Logback也远远落在后面，记录的行数还不到我们尊敬的获胜者的一半。与我们的获胜者相比，JUL排名第二，记录了82%的行–不算太坏。</p><h2>第四场比赛(赤脚跑步)。toString()减去上下文</h2><p>在处理服务器日志时，每个条目的上下文(例如线程ID、类上下文、时间戳等)几乎与条目本身的内容一样重要。在之前的比赛中，我们使用了两个最常见的上下文元素，您可以在大多数服务器日志条目中找到——线程ID和时间戳。我们认为在不使用任何引擎的上下文附加器的情况下，通过运行. toString() race来分析这些开销会很有趣。</p><p>Log4J2是这里的赢家(会议变更后，获得180%的提升)，Logback和JUL都明显领先25%。SLF4J SL落后。令人困惑的是，在五场不同的预赛中，SLF4J SL使用附加装置比没有附加装置做得更好(很想在评论中听到你的想法)。</p><p>Log4J经历了最大的提升，吞吐量增加了15%。JUL虽然在这场竞赛中的表现不如Log4J或Log4J2，但在有和没有上下文数据的情况下都给出了几乎完全相同的结果。</p></div></div>    
</body>
</html>