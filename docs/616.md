# 5 大 Java 日志框架| Harness

> 原文：<https://www.harness.io/blog/top-5-java-logging-frameworks>

日志记录是几乎每个服务器端应用程序的一个由来已久的固有部分。这是应用程序以持久可读的方式输出实时状态的主要方法。一些应用程序可能一天只记录几兆字节，而其他应用程序可能在几个小时内记录几十亿字节或更多的数据。

由于日志记录通常需要 IO 将数据写入磁盘(阻塞或异步)，因此这是有代价的。当在短时间内记录大量数据时，该成本会迅速增加。我们决定深入了解一些当今领先的日志引擎的速度。

大多数开发人员记录数据有三个主要原因——

1.  监控——查看代码在吞吐量、规模、安全性等方面的表现..
2.  调试——访问导致代码失败的状态(变量、堆栈跟踪等)。OverOps 帮助开发人员调试登台和生产服务器，并理解代码崩溃和线程冻结的原因。
3.  分析——利用应用程序中的实时数据，得出关于其使用方式的结论。

在门面后面。如今，大多数库都在代码的关键点内置了日志记录，以提供对其操作的可见性。为了简化这一过程并防止不同的库在同一个 JVM 中使用多种日志记录方法，将代码从底层引擎中分离出来的日志记录 facades 已经成为最前沿的技术。当我们分析排名前 100 的 Java 软件库时，SLF4J 成为了当今开发人员使用的主要日志门面。

## 竞争

我们决定挑选五个当今最著名的伐木引擎，看看它们在一些比赛中表现如何。现在，在您拿出火把和干草叉之前，我想澄清一下，重点不是说哪一个更好，而是给出一些常见日志记录任务的引擎之间吞吐量差异的感觉。

## 参赛者们

1.  Log4J
2.  Log4J2
3.  回溯
4.  SLF4J 简单测井(SLF4J SL)
5.  Java 实用程序日志记录(7 月)

## 这场比赛

我们想看看这些引擎在一组标准日志记录活动中的表现如何。每个日志记录操作都包括一个时间戳和一个线程 ID 作为其上下文。

这些是比赛:

1.  记录字符串常量
2.  记录。POJO 的 toString()值
3.  记录可抛出对象
4.  记录不带时间/tid 上下文的字符串常量

## 赛道

我们决定每场比赛举行五次预赛，以确定最佳成绩，测量完成的伐木作业数量。在每个测试中，我们给日志引擎一个在一分钟内跨 10 个线程执行的任务(测试分别运行)。然后，我们取出偏差最大的两次预赛，并对其余三次的结果进行平均。

在每个单独的日志操作之间，我们给 CPU 一些工作来在日志操作之间留出一些空间(检查一个小的随机数是否是质数)。这些引擎都使用默认配置在 SLF4J 之后运行。基准测试在 Amazon m1.large EC2 实例上运行。

更新:在我们最初的测试中，Log4J2 配置了一个%C 合格的类布局，这增加了它的开销。在@RemkoPopma 的建议下，我们将配置更新为%c (logger name ),以符合其他配置，这给了 Log4J2 相当大的性能提升，如下所示。这绝对是值得注意的事情，并且真正突出了记录上下文数据的成本。

## 竞赛# 1–字符串常量

在这场竞赛中，引擎记录了一个字符串常量以及线程和时间戳上下文。Log4J 显然是这里的赢家，能够比 JUL 多写 270%的行，比 logback 多写 12.5%，比 SLF4J SL 多写 52%。有趣的是，在我们改变 Log4J2 的配置之前，它可以写 4X(！)更少的行，交换机将其提升#3，写入的行仅比 logback 少 30%。

## 第二场比赛。toString()

在这场比赛中，引擎正在记录一个 POJO(通过其。toString)以及线程和时间戳上下文。这里的结果非常接近，Log4J2 以 25%的优势(变化后)排名第一，而 SLF4J SL 排名第二。Log4J 和 Logback 并列第三，JUL 以 SLF4J SL 88%的吞吐量获得银牌。

## 比赛# 3–可投掷

在这场竞赛中，引擎记录一个异常对象和一个描述字符串以及线程和时间戳上下文。在这场比赛中，Log4J2 火了，以超过 3X(！)乘以行数，与第 5 位的 SLF4J SL 进行比较。

Log4J 和 Logback 也远远落在后面，记录的行数还不到我们尊敬的获胜者的一半。与我们的获胜者相比，JUL 排名第二，记录了 82%的行–不算太坏。

## 第四场比赛(赤脚跑步)。toString()减去上下文

在处理服务器日志时，每个条目的上下文(例如线程 ID、类上下文、时间戳等)几乎与条目本身的内容一样重要。在之前的比赛中，我们使用了两个最常见的上下文元素，您可以在大多数服务器日志条目中找到——线程 ID 和时间戳。我们认为在不使用任何引擎的上下文附加器的情况下，通过运行. toString() race 来分析这些开销会很有趣。

Log4J2 是这里的赢家(会议变更后，获得 180%的提升)，Logback 和 JUL 都明显领先 25%。SLF4J SL 落后。令人困惑的是，在五场不同的预赛中，SLF4J SL 使用附加装置比没有附加装置做得更好(很想在评论中听到你的想法)。

Log4J 经历了最大的提升，吞吐量增加了 15%。JUL 虽然在这场竞赛中的表现不如 Log4J 或 Log4J2，但在有和没有上下文数据的情况下都给出了几乎完全相同的结果。