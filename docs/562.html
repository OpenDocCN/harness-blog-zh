<html>
<head>
<title>Kubernetes Application Deployment Strategies | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Kubernetes应用部署策略|利用</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/kubernetes-application-deployment-strategies#0001-01-01">https://www.harness.io/blog/kubernetes-application-deployment-strategies#0001-01-01</a></blockquote><div><p>了解将生产就绪的容器化应用程序部署到Kubernetes的滚动、金丝雀版本或蓝/绿部署之间的区别。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>当您准备将生产就绪的容器化应用程序部署到Kubernetes时，您需要选择一个部署策略。您可以选择滚动(默认)、金丝雀发布或蓝/绿部署。开发人员通常使用这些部署策略，作为在生产环境中平稳、安全地推出新代码变更的一种方式。Kubernetes使部署新版本的应用程序变得容易。这篇博文探讨了这三种常用的应用程序部署方法之间的差异:滚动、金丝雀和蓝/绿。让我们看看这些Kubernetes部署策略提供了什么，以及何时应该使用它们。</p><h2>滚动部署</h2><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>滚动部署是将更新部署到生产应用程序的连续过程，这是Kubernetes应用程序部署策略的默认设置。通常，您将不断地以滚动的方式向所有节点部署新的代码更改。这个过程包括部署应用程序的新版本，然后是一个监控/等待期。在此等待期间，您将监控生产节点的运行状况以发现异常。如果一切正常，您将继续下一组节点，然后下一组节点，直到所有节点都用新代码更新。</p><p>滚动部署策略是一种以滚动方式将新代码变更持续部署到生产中所有节点的方法。Harness平台使开发人员可以轻松地使用滚动部署策略，从而以最小的风险部署他们的软件。</p><p>‍</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>‍</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>一旦设置好配置，您就可以应用更改并运行管道，您应该会看到滚动部署策略按照您指定的方式得到执行。</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"/><p>点击了解有关滚动部署<a href="https://ngdocs.harness.io/article/xsla71qg8t-create-a-kubernetes-rolling-deployment">的更多信息。</a></p><h2>金丝雀部署</h2><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>Canary版本是一种管理风险的方法，它通过分阶段向产品推出新的代码或配置更改。Canary发布是多阶段部署的第一个阶段，在这个阶段，您将一小部分新变更部署到您的用户子集。金丝雀发布基本上是一个受控的展示，可以帮助您最小化风险。金丝雀发布策略非常适合在不影响每个用户的情况下测试产品中的新代码变更。它允许组织将新功能部署到其整体用户群的一小部分，并监控他们的行为以识别潜在的问题和初始响应/反馈。如果一切看起来都很好，组织可以继续向更大比例的用户进行多阶段部署。这是开发人员用来确保新版本没有破坏应用程序的一种技术，也用于监控生产系统的健康状况。</p><p>Harness平台支持canary部署策略，只需点击几下鼠标即可轻松配置。</p><p>假设您已经用所有其他需求配置了您的管道，在部署的执行阶段，您可以如下所示指定部署策略类型。</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>‍</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>‍</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>‍</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>一旦设置好配置，您就可以应用更改并运行管道。您应该看到canary部署策略按照您指定的方式执行。</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>点击了解更多关于金丝雀部署的信息<a href="https://ngdocs.harness.io/article/17wrdeuv0x-canary-deployment-step">。</a></p><h3>蓝色/绿色部署</h3><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>蓝/绿部署策略是指创建两个不同但相似的环境。一个环境(蓝色)运行当前的应用程序版本，另一个环境(绿色)运行新的应用程序版本。然后，您逐渐将用户流量从蓝色环境转移到绿色环境，而不会影响服务。蓝/绿部署策略在业内得到了很好的实践，因为两种环境几乎完全相同，所以它降低了停机风险。此外，使用blue/green，您可以在高峰时间进行部署，而不必担心用户流量，而不必等到用户流量减少时再部署新代码。</p><p>Harness通过轻松地将其配置到您的应用程序部署策略，帮助您实现蓝/绿部署目标。</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>‍</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>‍</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>选择蓝色/绿色部署的阶段部署。</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>‍</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>您可以应用这些更改，并保存和运行管道来执行我们的蓝/绿部署。</p><p>‍</p><figure class="w-richtext-figure-type-image w-richtext-align-fullwidth"/><p>‍</p><p>点击了解有关蓝/绿部署的更多信息<a href="https://ngdocs.harness.io/article/mog5tnk5pi-create-a-kubernetes-blue-green-deployment">。</a></p><h2>结论</h2><p>生产就绪的Kubernetes部署需要仔细的规划和执行。您可以通过选择适合您正在部署的应用程序类型的部署策略来实现这一点。选择正确的部署策略还取决于您所拥有的架构，如单片、微服务或无服务器。每种部署策略都有其自身的优势，因此选择一种适合您的应用程序和团队需求的策略至关重要。此外，这些部署策略有助于组织维持正常运行时间，并收集客户的初步反馈。它们还降低了将错误代码或错误特性部署到产品中的风险。您还应该有一个现代化的交付平台，如Harness，它可以通过为您提供所有的部署策略选项来轻松处理您的部署。</p><p>要了解关于Harness如何帮助您进行部署的更多信息，请访问<a href="https://harness.io/products/continuous-delivery">https://harness.io/products/continuous-delivery</a></p></div></div>    
</body>
</html>