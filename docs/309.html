<html>
<head>
<title>Terraform 201: What It Is, Tutorial, and More | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Terraform 201:它是什么，教程和更多|线束</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/terraform-201-tutorial#0001-01-01">https://www.harness.io/blog/terraform-201-tutorial#0001-01-01</a></blockquote><div><p>在本文中，我们将介绍HashiCorp Terraform，这是一个基础设施即代码(IAC)工具，它加速了云计算世界中开发人员和工程团队的工作。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>在本文中，我们将介绍HashiCorp Terraform，这是一个<a href="https://harness.io/blog/devops/infrastructure-as-code/" target="_blank">基础设施即代码(IAC) </a>工具，它加速了云计算世界中开发人员和工程团队的工作。与AWS CloudFormation一样，HashiCorp Terraform使您能够使用代码定义基础架构的理想状态，并将这些更改部署到您的AWS帐户、Google Cloud项目和其他解决方案中(稍后将详细介绍)。让我们深入一些核心用例、概念和一些需要注意的警告。</p><h2>地形教程</h2><h3>地形状态</h3><p>首先，让我们谈谈Terraform如何跟踪它所管理的基础设施。有人可能会问，“Terraform如何知道需要做出哪些改变？”</p><p>通常情况下，亚马逊S3或谷歌云存储桶被用作Terraform所管理内容的真实来源。对于大多数项目，不建议使用本地状态，因为您的基础结构状态记录可能会在磁盘故障期间丢失。</p><p>如果您选择使用亚马逊S3，强烈建议在您指定为“远程状态”的存储桶上启用S3对象版本控制，以防将来出现任何问题。</p><p>Terraform命令，如`<strong> terraform plan </strong>`、`<strong> terraform apply </strong>`，以及伤脑筋的`<strong> terraform destroy </strong>`将利用远程状态下记录的内容，同时terraform将理想状态(您编写的terraform代码)与现实进行协调，从您的代码正在与之交互的云提供商或SaaS API的角度来看。</p><h3>Terraform核心概念</h3><p>既然我们已经从较高的层次上介绍了Terraform远程状态，那么让我们来讨论一下存在于其中的资源的类型，以及当他们对基础设施代码进行更改时，如何操作状态。</p><h4>Terraform文件扩展名</h4><p>以下是一些原生Terraform文件扩展名的简要介绍:</p><p><strong> *。tf </strong> <br/>正如您将在下面看到的，扩展名为. tf的文件被处理为“基础设施声明”文件。Terraform对这些文件的命名相当灵活，尽管建议遵循HashiCorp的<a href="https://www.terraform.io/docs/language/modules/develop/structure.html">标准模块文档</a>。这样做将确保新工程师尽快加入您的IAC Git库。<br/></p><p><strong> *。tfvars </strong> <br/>遵循标准的模块文档约定，根模块的变量在variables.tf中定义，它作为模块的默认值。假设默认情况下，您希望RDS备份保留时间设置为7天，但是在生产环境中，您希望保留14天。<br/> <br/>下面是variables.tf对象定义变量的样子:</p><p>变量" web app _ rds _ backup _ retention _ days " {<br/>description = "保留RDS备份的天数"<br/>type = Number<br/>default = 7<br/>}</p><p>要覆盖该值，您需要创建一个production.tfvars或类似名称的文件，并添加一行，如下所示:</p><p>webapp _ rds _备份_保留期_天数=14</p><p><strong> *.tf.json </strong>虽然Terraform有自己的本地语言(HCL)，但它也支持基于JSON的配置。<br/></p><p><strong> *。tpl </strong> <br/>不赘述，tpl文件是模板文件，可以由Terraform以优雅且可重用的方式进行插值。Terraform提供了遍历所提供的list()并动态生成IAM策略资源块等功能。如果你感兴趣的话，这里有一些关于这个主题的进一步阅读材料。</p><h4>部署更改</h4><p>要在当前工作目录中部署(或应用)更改，我们可以使用如下命令。根据您是否正在考虑使用Terraform工作空间或环境，您可以将tfvars文件作为`<strong> terraform apply </strong>'的一部分传入。</p><p>#拉出任何模块并连接到后端远程状态<br/> terraform init <br/> <br/> #可选，因为terraform首先应用计划并提示批准<br/> terraform计划<br/> <br/> #协调现实vs状态vs cwd代码<br/> terraform应用</p><p>值得注意的是，terraform init通常需要在第一次在目录中应用之前调用，或者如果对根模块所依赖的模块进行了修改。</p><p>如果您的团队有多名工程师将为您的Terraform代码库做出贡献，请考虑使用Atlantis或HashiCorp的Terraform Cloud等解决方案，以一致且优雅的方式协调您的基础架构部署。</p><h4>捕捉语法错误和格式</h4><p>当用其他语言编码时，你有多少次在CI中推送代码却看到林挺检查失败？对我来说太多次了！</p><p>嗯，有了Terraform，我们可以在本地对我们的代码进行一些抽查，以确保它处于CI的良好状态。以下是您可以运行的几个命令:</p><ol role="list"><li>格式化您的代码</li><li>捕捉语法错误</li><li>验证我们的假设</li></ol><p>#缩进和完整性检查代码<br/> #写入STDOUT的任何文件名都已格式化<br/> terraform fmt <br/> <br/> #验证cwd中的terraform语法<br/> terraform验证</p><h4>提供者/扩展性</h4><p>你以前可能听说过有人使用Terraform来管理他们的AWS、Google Cloud和Azure基础设施。这可以立即引发这样的想法:“他们如何及时跟上所有最新的API更新？”</p><p>名为Terraform的出色的基础设施代码工具的基础是无数的子组件，它们处理与每个特定云提供商的交互。HashiCorp称这些为Terraform供应商。</p><p>重点介绍一些常用的流行提供程序，以及供您阅读的文档链接:</p><p>AWS- <a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs" target="_blank"> https://registry。terra形态。io/providers/hashi corp/AWS/latest/docs</a><br/>Google-<a href="https://registry.terraform.io/providers/hashicorp/google/latest/docs" target="_blank">https://registry。terra形态。io/providers/hashi corp/Google/latest/docs</a>T5】azure RM-<a href="https://registry.terraform.io/providers/hashicorp/azurerm/latest" target="_blank">https://registry。terra形态。io/提供商/哈希公司/azure RM/最新</a></p><p>为了开始在AWS帐户中创建资源，您需要在providers.tf中添加一个提供者块，如下所示:</p><p>提供商" AWS " {<br/>version = " ~&gt;2 . 54 . 0 "<br/>region = " us-east-2 "<br/>}</p><p>在上面的例子中，Terraform和AWS SDK将通过通常的AWS凭证提供者链过程来查找AWS凭证以验证请求。在这种情况下，我们退回到使用~/中的[default]配置文件。AWS/凭据。</p><p>如果您需要将您的资源部署到多个客户或地区，我们可以为提供商起别名，并挑选出我们希望在这些配置环境中部署的特定Terraform资源。这里一个很好的用例是在另一个AWS帐户托管的Route53区域中创建记录。</p><h4>数据源——想想“读者”</h4><p>数据源的概念非常有趣，也是一个经常争论的话题。这里增加的基本价值是，您可以让Terraform“查询”您选择的特定资源的提供者。</p><p>在完美的世界中，你的AWS、GCP或Azure云环境中的每一个资源都将在一个中心位置进行管理，即在Terraform中。</p><p>事实上，在大多数情况下，老牌公司都会实施一种混合基础架构管理模式。例如，您的AWS帐户中的VPC可能是手动或通过CloudFormation创建的，但您希望使用Terraform将资源部署到所述VPC中。</p><p>记住这个VPC场景，在Terraform中，您可能需要为特定VPC内的子网标识专用子网id。当然，您可以添加一个Terraform输入变量，并在prod.tfvars中手动提供覆盖列表，但是这个新时代完全是关于动态基础设施的！</p><p>为了完成动态查找，我们可以像这样使用“<strong> aws_subnet_ids </strong>”数据源，并简单地传入VPC的ID和一个明确标识私有子网的标记。确定您所考虑的数据源的文档范围是很重要的，因为筛选字段有一些限制。下面是上述查找在HashiCorp配置语言中的样子:</p><p>变量" vpc_id" {} <br/> <br/>数据" AWS _ subnet _ ids " " private " {<br/>VPC _ id = var . VPC _ id<br/><br/>tags = {<br/>subnet _ type = " private "<br/>}<br/>}</p><p>关于这个数据源以及其他数据源的更多信息，请查看HashiCorp最新的<a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/subnet_ids" target="_blank">文档</a>。</p><h4>资源——思考“创造者”</h4><p>资源，资源，资源——这很容易是Terraform的面包和黄油，你将最大程度地利用它们。</p><p>想要在您的AWS帐户中创建新的EC2实例吗？这将与<a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/instance" target="_blank"> aws_instance资源</a>一起使用，就像这样:</p><p>资源" AWS _ instance " " web " {<br/>ami = " ami-12 E4 cf D5 "<br/>instance _ type = " T2。微"<br/> tags = { <br/> Name = "基本EC 2实例示例"<br/> } <br/> }</p><p>想在Datadog中创建新的监视器吗？使用Datadog Terraform提供程序，您可以将`<a href="https://registry.terraform.io/providers/DataDog/datadog/latest/docs/resources/monitor" target="_blank"><strong>Datadog _ monitor</strong></a>`资源部署到您的Datadog帐户中。</p><p>想要在您的开发或生产租户中创建新的Auth0应用程序吗？没问题，有Terraform提供者和相应的资源支持！</p><p>我认为Terraform的可集成性是最大的卖点之一。它不仅仅是一个基础设施代码解决方案；它能够管理大量SaaS/PaaS解决方案中的资源！通常，这些外部系统和我们托管应用程序的基础设施之间存在依赖关系。</p><h4>模块-地形分类</h4><p>现在我们已经介绍了模块的构建块:数据源、资源和输入变量，让我们来谈谈如何使用Terraform模块保持我们的Terraform代码干燥和可重用！</p><p>首先，值得指出的是，在Terraform 0.13之前，模块有一些特别令人遗憾的限制。没有可用于模块的计数参数。作为副作用，您会在Github等上发现大量的模块，这些模块实现了大量的“enablement”变量来控制模块中每个单独资源的创建。我过去称这些为“管道”变量，因为我们从调用代码中传递它们(你想在那里利用模块)。这使得使用模块变得很麻烦，因为您需要大量的变量来控制基本的创建行为。</p><p>好吧，如果你刚刚开始使用Terraform，我很高兴地宣布，情况不再是这样了！</p><p>人们可以把Terraform模块看作是Terraform的类。假设您经常将一个特定的架构部署到您的AWS环境中，它由一个RDS实例和Route53记录组成。我们可以将所有内容封装到一个模块中，而不是在您想要部署的每个Terraform根模块中单独调用每个资源。和通常的根模块一样，我们定义Terraform输入变量、提供者及其版本需求、资源，甚至数据源！</p><p>您可能会想，“这听起来很酷，但是我必须自己编写所有的自定义内容吗？”</p><p>幸运的是，像大多数开源社区一样，有大量的预构建模块。将模块库从GitHub分支到您的企业组织中可能是有意义的，但是还有另一个选择:Terraform registry。</p><p>在你创建一个复杂的模块之前，仔细阅读Terraform注册中心的社区支持的预建模块是值得的。如果您确实创建了一个定制模块，请考虑将其分解到一个定制的g it存储库中，或者至少分解到一个具有适当划分的目录结构的通用“terraform-modules”存储库中。</p><p>版本控制你的Terraform代码和模块(真的有什么区别吗？)对于使我们能够快速行动并能够在事情不按计划进行时审计变更是至关重要的。我强烈推荐使用<a href="https://semver.org/" target="_blank">语义版本控制</a>来保持事情正常。关于这个主题，最后一个要分享的想法是(这有时会在软件开发中引起共鸣):考虑其他可能想要使用你的模块的工程师。避免在小版本或补丁版本中进行破坏性更改。<a href="https://github.com/terraform-docs/terraform-docs" target="_blank"> Terraform-docs </a>还可以通过自动更新模块中的README.md来帮助维护，作为CI的一部分或预提交挂钩。</p><h4>函数-基本库函数</h4><p>正如大多数其他语言一样，Terraform提供了一个标准函数库，您可以使用它对输入变量和任何其他需要传递的数据进行修改。在本文中，我们将介绍一些日常可能会用到的常用函数。</p><p>下面是一个使用format()函数连接KMS键描述的示例:</p><p>locals {<br/>key _ description = format("用于%s环境的加密密钥"，var.environment) <br/> } <br/> <br/>变量"环境" { <br/> description = "环境的名称。"<br/>type = string<br/>}<br/><br/>resource " AWS _ kms _ key " " fintech " {<br/>description = local . key _ description<br/>}</p><p>您可能遇到的另一个常见场景是JSON被期望作为资源的参数。让我们看看如何为SQS队列适当地编码重驱动策略，因为那里需要JSON。</p><p>资源" AWS _ SQS _ queue " " my-queue " {<br/>name = " example-TF-queue "<br/>message _ retention _ seconds = 86400<br/>receive _ wait _ time _ seconds = 10<br/>redrive _ policy = jsonencode({<br/>deadLetterTargetArn = var . dlq _ arn<br/>maxReceiveCount = 5<br/>})<br/>}</p><p>有关使用Terraform提供的内置函数的更多信息，请查看Hashicorp的<a href="https://www.terraform.io/docs/language/functions/index.html" target="_blank">函数文档</a>。我强烈推荐查看一下<a href="https://www.terraform.io/docs/language/functions/cidrsubnet.html" target="_blank">的IP网络功能</a>，当动态分割你的VPC子网中的IP地址时，它真的会派上用场。</p><h4>输出</h4><p>有时，将所有资源放在一个单一的Terraform根模块中会导致terraform应用过于缓慢，因此许多工程团队逻辑上将他们的Terraform代码划分到多个目录中。考虑RDS实例和ECS服务任务定义的例子，其中包括环境变量。你可能希望这些彼此隔离，因此，这就是Terraform输出发挥作用的地方。</p><p>输出可以让你...从一个Terraform状态输出数据，然后将其导入另一个状态。这对于RDS主机名、VPC对象等等来说非常方便。较新版本的Terraform现在允许您导出整个模块，而不仅仅是原始数据类型、列表、地图等。</p><h3>结论</h3><p>如您所见，Terraform提供了丰富的功能来支持部署、维护和与您的基础设施交互。仔细考虑如何将资源分组到不同的根模块中，你会发现Terraform非常容易使用和维护。试着让你的Terraform代码尽可能的简洁，并且在处理一大群贡献者的时候利用自动化来处理应用</p><p>这就结束了我们对Terraform的201研究。我们希望这对您有所帮助，如果您有任何问题或意见(或者甚至希望我们做一个Terraform 301！)请伸手。不要忘记通过<a href="https://harness.io/demo" target="_blank">今天预订您的演示</a>来查看Harness的强大Terraform集成。</p><p>马库斯</p></div></div>    
</body>
</html>