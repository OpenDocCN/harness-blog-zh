# Oracle Java Mission Control:终极指南|工具

> 原文：<https://www.harness.io/blog/oracle-java-mission-control>

Java Mission Control 的完整指南，这是一个从 Java 7U40 开始提供的 JDK GUI 工具。

## 1.介绍

本文将描述 Java Mission Control——一个自 Java 7u40 以来就可用的 JDK GUI 工具，以及 Java 飞行记录器。

## 2.Java 任务控制

[Oracle Java Mission Control](http://www.oracle.com/technetwork/java/javaseproducts/mission-control/java-mission-control-1998576.html) 是从 Java 7u40 开始在 Oracle JDK 中提供的工具。该工具源自 JRockit JVM，在那里它已经存在了多年。JRockit 和它的 JMC 版本在由两位 JRockit 高级开发人员撰写的 [Oracle JRockit:权威指南](http://www.amazon.com/gp/product/B005CGIXLU/ref=as_li_tl?ie=UTF8&camp=1789&creative=390957&creativeASIN=B005CGIXLU&linkCode=as2&tag=javaperfor07e-20&linkId=6KCRVS5KCRLI2KIK)中有很好的描述(也可以访问 [Marcus Hirt 博客](http://hirt.se/blog/)——你应该在那里寻找任何 JMC 新闻)。

‍
Oracle JMC 可用于两个主要目的:

*   监控多个正在运行的 Oracle JVMs 的状态
*   Java 飞行记录器转储文件分析

## 3.JMC 许可证

当前的 JMC 许可(参见“补充许可条款”[此处](http://www.oracle.com/technetwork/java/javase/terms/license/index.html))允许您自由使用 JMC 进行开发，但如果您想在生产中使用它，则需要购买商业许可。

## 4.实时过程监控

您可以通过在主窗口的 JVM 浏览器选项卡中右键单击 JVM 并选择“启动 JMX 控制台”菜单选项来连接到 JVM。您将看到以下屏幕。这里没有什么特别的，只要注意“+”按钮，它允许你在这个屏幕上添加更多的计数器。

### 4.1 事件触发器

触发器允许您运行各种操作，以响应特定 JMX 计数器超过阈值并(可选)在给定时间段内保持在阈值以上的情况。例如，您可以在长时间的高 CPU 活动的情况下触发 JFR 记录，以便了解是什么组件导致了它(并且您不限于单个记录！).

‍
注意，触发器可以在任何 JMX 计数器上工作(你看到“添加…”按钮了吗？)–您可以设置比标准发行版更多的触发器，并将设置导出到磁盘上。您甚至可以使用自己的应用程序 JMX 计数器。

转到“规则详情”窗口中的“操作”选项卡，在此您可以指定在发生事件时您想要执行的操作。

请注意，如果你想正确使用 JFR，你需要至少在 Java 7 update 40 中运行你的应用程序——我无法记录任何来自 Java7u40 之前的 JREs 的事件(也许这是一个错误或某些 JRE 版本之间的不兼容…)。

### 4.2 内存选项卡

下一个选项卡——“Memory”将为您提供关于应用程序堆和垃圾收集的摘要信息。请注意，您可以运行完整的 GC 并从该页面请求堆转储(在屏幕截图中突出显示)。但本质上，这个页面只是一个漂亮的 UI，围绕着其他来源提供的功能。

### 4.3 螺纹选项卡

此选项卡允许您查看应用程序中正在运行的线程列表及其当前堆栈转储(每秒更新一次)。它还可以让您看到:

*   线程状态–运行或阻塞/等待
*   锁定名称
*   如果线程被死锁
*   线程被阻塞的次数
*   每线程 CPU 使用率！
*   给定线程自启动以来分配的内存量

请记住，您必须打开 CPU 分析、死锁检测和内存分配跟踪，以便在实时模式下获得这些信息:

## 5.使用 Java 飞行记录器

Java 飞行记录器(在本文的其余部分我们称之为 JFR)是 JMC 的一个特性。从用户的角度来看，您使用固定的录制时间/最大录制文件大小/最大录制长度(您的应用程序可以在此之前完成)运行 JFR，并等待录制完成。然后你在 JMC 分析它。

### 5.1 如何经营 JFR

您需要向您想要连接的 JVM 添加以下两个选项:
*-XX:+UnlockCommercialFeatures-XX:+flight recorder*

*‍* 文档声称您可以从 Java 7u4 连接到任何 JVM，但是我无法从这些 JVM 中获得任何有用的信息。

‍
要记住的第三件事是，默认情况下，JVM 只允许在安全点进行堆栈跟踪。因此，在某些情况下，您可能会有不正确的堆栈跟踪信息。 [JFR 文档](https://users/lex/Desktop/jmc%20(1)/tools/docs.oracle.com/javacomponents/jmc-5-5/jfr-runtime-guide/about.htm#sthref10)告诉你如果你想要更精确的堆栈跟踪，再设置两个参数(你不能在运行的 JVM 上设置这些参数):

‍
*-xx:+unlock diagnosticvmoptions-xx:+debignonsafepoints*
‍

最后，如果您想要尽可能多的文件 I/O、Java 异常和 CPU 概要信息可用，请确保您已经启用了所选的参数，并将它们的阈值设置为“1 ms”。

### 5.2 JFR 初始屏幕

JFR 记录的初始屏幕包含记录期间的 CPU 和堆使用情况图表。把它当作你过程的概述。在这个(和其他 JFR 屏幕)上，您应该注意到的唯一一件事是能够通过任何图表选择一个时间范围进行分析。勾选“同步选择”复选框，在每个窗口上保持相同的时间范围-这将允许您只检查在此范围内发生的事件。

‍
在这个屏幕上还有一个更有趣的特性:底部的“JVM 信息”标签包含了在被分析的 JVM 中设置的所有 JVM 参数值。您可以通过 *-XX:+PrintFlagsFinal* JVM 选项获得它们，但是通过 UI 远程获得它们更方便:

### 5.3 Java 飞行记录器存储器选项卡

内存选项卡提供以下信息:

*   机器 RAM 和 Java 堆的使用情况(您很容易猜到在记录过程中是否发生了交换或过多的 GC)。
*   垃圾收集——清理的时间、原因、持续时间和空间大小。
*   内存分配–TLAB 内部/外部，按类/线程/堆栈跟踪。
*   堆快照–类名占用的内存数量

本质上，这个选项卡将允许您检查应用程序中的内存分配率，它对 GC 施加的压力，以及哪些代码路径导致了意外的高分配率。JFR 也有自己非常特殊的特性——它允许分别跟踪 TLAB 和全局堆分配(TLAB 分配要快得多，因为它们不需要任何同步)。
一般来说，如果满足以下条件，你的应用会变得更快:

*   它分配更少的对象(按数量和分配的 RAM 量)
*   旧的(完整的)垃圾收集更少，因为它们更慢，并且需要停止整个世界(至少一段时间)
*   您已经最小化了非 TLAB 对象分配

让我们看看如何监控这些信息。“Overview”选项卡显示了关于内存消耗/分配/垃圾收集的一般信息。

你可以在这里看到“提交堆”离“保留堆”有多远。它显示了在输入峰值的情况下你有多少余量。蓝线(“已用堆”)显示有多少数据正在泄漏/留在老一代中:如果您的 saw 模式每一步都在上升，那么您的老一代正在增长。每一步的最低点大约显示了老一代中的数据量(其中一些可能符合垃圾收集的条件)。截图上的模式告诉我们，一个应用程序只分配了寿命较短的对象，这些对象是由年轻一代 GC 收集的(可能是一些无状态的处理)。

‍
你也可以检查“tlabs 的分配率”字段——它显示了每秒分配了多少内存(还有一个名为“对象的分配率”的计数器，但一般来说应该很低)。126 Mb/秒(在示例中)对于批处理来说是一个相当平均的速率(与硬盘读取速度相比)，但对于大多数交互式应用来说是相当高的。您可以使用这个数字作为整体对象分配优化的指标。

‍
以下三个标签:“垃圾收集”、“垃圾收集时间”和“垃圾收集配置”是不言而喻的，可以作为垃圾收集原因和垃圾收集导致的最长暂停时间(影响应用延迟)的信息来源。

### 5.4 Java 飞行记录器分配选项卡

“分配”选项卡为您提供所有对象分配的信息。您应该转到“新 TLAB 中的分配”选项卡。在这里，您可以看到每个类(分配了哪些类实例)、每个线程(哪些线程分配了大多数对象)或每个调用堆栈(将其视为全局分配信息)的对象分配配置文件。

#### 5.4.1 按类别分配

让我们看看您能从这些选项卡中找到什么。第一个(在上面的截图中)，“按类分配”让你看到哪些类被分配的最多。在中间的选项卡中选择一个类型，您将获得该类实例的所有分配的分配统计信息(带有堆栈跟踪)。

‍
这里你应该做的第一个检查是你是否能找到任何“无用”的对象分配:任何原始的包装器，比如 Integer 或 Double(这通常表明使用了 JDK 集合)， *java.util.Date* ，*Java . util . Gregorian calendar*，模式，任何格式化器，等等。我在最近的文章的第二部分[中写了一些内存调优的提示。“堆栈跟踪”选项卡将让您找到要改进的代码。](http://java-performance.info/over-32g-heap-java#hints)

‍
另一个需要检查的问题是过多的对象分配。不幸的是，这里不能给出一般的建议——你应该用你的常识来理解“过度”在你的应用中意味着什么。常见的问题是无用的防御性复制(对于只读客户端)和过度使用 String.substring，因为 String 类在 [Java 7u6](http://java-performance.info/changes-to-string-java-1-7-0_06/) 中发生了变化。

#### 5.4.2 按线程分配

如果您的应用程序中有几种数据处理类型的线程(或者您可以区分哪些任务由哪些线程运行)，那么“按线程分配”选项卡可能会很有意思——在这种情况下，您可以计算出每个线程的对象分配:

#### 分配配置文件

如果您的所有线程都是一致的(或者您只有一个数据处理线程),或者您只是想查看高级分配信息，那么直接转到“分配配置文件”选项卡。在这里，您将看到在所有线程中的每个调用堆栈上分配了多少内存。

该视图允许您找到给内存子系统带来最大压力的代码路径。您应该在这里区分预期分配和超额分配。例如，如果从方法 A 多次调用方法 B，而方法 B 在其中分配了一些内存，并且方法 B 的所有调用都保证返回相同的结果，这意味着您过度调用了方法 B。最后，小心那些强迫你创建可重用对象池的优化——只有当每个线程只有不超过一个存储对象时，你才应该池化/缓存对象(众所周知的例子是*thread local<date format>*)。

### 5.5 Java 飞行记录器代码标签

JFR 视图中的下一个大选项卡是“代码”选项卡。对 CPU 优化有用:

overview 选项卡为您提供了两个视图:“Hot packages”，您可以在其中查看每个 Java 包花费的时间，以及“Hot classes”，它允许您查看应用程序中 CPU 开销最大的类。

‍
“热包”视图可能是有用的，如果你使用一些第三方库，你很少控制，你想为你的代码(一个包)，第三方代码(几个其他包)和 JDK(几个更多的包)的 CPU 使用情况总结。同时，我称之为“CIO/CTO 视图”，因为它不是交互式的，并且不能让你看到这些包中的哪些类是错误的。作为一名开发人员，您最好对该选项卡中的大多数其他表格使用过滤:

#### 5.5.1 热门方法/调用树选项卡

“Hot Methods”和“Call Tree”选项卡是几乎任何 Java 分析器都提供的普通视图。它们显示了你的应用程序的热点——你的应用程序花费了大部分时间的方法，以及通向这些热点的代码路径。你通常应该从“热方法”标签开始你的应用程序 CPU 调整，然后在“调用树”标签中检查整体情况是否足够正常。

‍
你应该知道，所有“低影响”的评测器都使用采样来获取 CPU 性能分析。采样分析器定期对所有应用程序线程进行堆栈跟踪转储。通常的采样周期是 10 毫秒。通常不建议将此时间缩短至 1 ms 以下，因为采样影响将开始变得明显。
‍

因此，您将看到的 CPU 配置文件在统计上是有效的，但并不精确。例如，您可能很不幸地在采样间隔遇到了一些很少被调用的方法。这种情况时有发生…如果您怀疑分析器向您显示了不正确的信息，请尝试重新组织“热”方法——将方法内联到最热路径上的调用者中，或者相反，尝试将方法分成两部分——从分析器视图中删除一个方法就足够了。

#### 例外选项卡

“Exceptions”选项卡是“Code”视图中的最后一个选项卡，在一般优化情况下值得注意。抛出 Java 异常非常慢并且它们的使用必须严格限制在高性能代码中的异常场景。

‍
Exceptions 视图将为您提供记录期间抛出的异常数量的统计数据，以及它们的堆栈跟踪和详细信息。浏览“概述”选项卡，检查您是否看到:

*   任何意外的异常
*   意外数量的预期异常

如果您看到任何可疑的情况，请转到“异常”选项卡并检查异常的详细信息。尽量至少去掉数量最多的。

### 5.6 JFR 螺纹标签

“JFR 螺纹”选项卡为您提供以下信息:

*   CPU 使用率/线程数图表
*   每线程 CPU 配置文件–类似于代码选项卡上的配置文件，但基于每线程
*   争用——哪些线程被哪些线程阻塞了，阻塞了多长时间
*   延迟——是什么导致应用程序线程进入等待状态(您将在这里清楚地看到一些 JFR 开销)
*   锁实例——导致线程争用的锁

我不会在本文中详细介绍这个选项卡，因为您只需要这个选项卡来进行非常高级的优化，比如锁剥离、原子/易变变量、非阻塞算法等等。

### 5.7 JFR 输入/输出选项卡

I/O 选项卡应该用于检查应用程序中的文件和套接字输入/输出。它让您看到应用程序正在处理哪些文件，读/写大小是多少，以及完成 I/O 操作需要多长时间。您还可以在应用程序中查看 I/O 事件的顺序。

‍
和大多数其他 Java 飞行记录器标签一样，你需要自己解释这个标签的输出。这里有一些你可以问自己的问题:

*   我是否看到了任何意外的 I/O 操作(在我不希望在这里看到的文件上)？
*   我是否多次打开/读取/关闭同一个文件？
*   读/写块大小是预期的吗？它们是不是太小了？

请注意，如果您使用 SSD，强烈建议将“文件读取阈值”JFR 参数(您可以在开始 JFR 记录时设置)降低到 1 毫秒。使用默认的 10 ms 阈值，您可能会错过 SSD 上的太多 I/O 事件。I/O“概述”选项卡很棒，但与以下 4 个专门的选项卡相比，它不提供任何额外的信息。4 个专门的选项卡(文件读/写、套接字读/写)彼此相似，所以让我们只看其中的一个——“文件读”。

这里有 3 个标签页:“按文件”、“按线程”、“按事件”。前两个选项卡按文件和线程对操作进行分组。最后一个选项卡简单地列出了所有 I/O 事件，但是如果您正在调查对特定文件进行了哪些操作(按“路径”过滤)，或者如果您想弄清楚是否对短数据块进行了读取请求(按“读取的字节”排序)，这会损害应用程序的性能，那么它可能会非常有用。一般来说，您应该总是缓冲磁盘读取，以便只有文件尾读取会短于缓冲区大小。

‍
注意，I/O 信息也是通过采样收集的，所以 I/O 选项卡中会遗漏一些(或很多)文件操作。这在顶级固态硬盘上尤其明显。

‍
还有一个相关的屏幕，可以让你通过不同的字段对 I/O(和其他一些)事件进行分组。例如，您可能想要找出多少次读取操作已经读取了给定数量的字节(并检查它们的堆栈跟踪)。转到 JFR 视图左侧的“事件”选项卡，然后转到最后一个名为“直方图”的选项卡。

‍
在这里你可以通过可用的列过滤/排序/分组各种事件。每个 JFR 事件都有一个相关的堆栈跟踪，因此您可以看到所选事件的堆栈跟踪信息:

有一个基本的性能调优领域没有被 JFR 覆盖:内存使用反模式，比如重复的字符串或容量巨大的几乎为空的集合。JFR 不会向您提供这样的信息，因为您需要一个堆转储来进行这样的分析。这就是你需要一个名为“JOverflow Analysis”的 JMC 插件的地方