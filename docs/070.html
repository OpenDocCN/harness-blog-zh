<html>
<head>
<title>Rancher Rio vs Harness - Filming my Journey | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>牧场主里约vs马具-拍摄我的旅程|马具</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/rancher-rio-vs-harness#0001-01-01">https://www.harness.io/blog/rancher-rio-vs-harness#0001-01-01</a></blockquote><div><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>牧场主Rio是由T2牧场主T3开发的微型PaaS T1。两年前在<a href="https://www.slideshare.net/cyberblackvoom/whats-rio-112779732">被引入野外</a>，牧场主Rio正在被开发，以帮助在<a href="https://kubernetes.io/"> Kubernetes平台</a>中消除复杂性。Kubernetes作为一个平台有一个我称之为可插入的观点，如果你不喜欢关于某个功能如何工作的观点，你可以通过一个新的提供商来改变这个观点。例如，如果您不喜欢<a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/">入口控制器</a>，请切换到另一个提供商，如<a href="https://istio.io/"> Istio </a>或<a href="https://github.com/containous/traefik"> Traefik </a>。<br/></p><p>有了所有的选择，你会发现自己涉水通过几乎不断变化的意见，因为Kubernetes生态系统移动相当快。在本地使用你的网络浏览器访问你编写的应用程序似乎很容易，但是在Kubernetes的世界里，你需要通过几个层次来展示你的服务和增加方法的复杂性，例如,<a href="https://harness.io/2020/02/service-mesh-fundamentals/">服务网格</a>增加了基础设施的复杂性。输入<a href="https://github.com/rancher/rio"> Rancher Rio </a>让你起床，开始完成看似简单的目标，就像轻松完成工作一样。<br/></p><p>Harness平台和Racher Rio当然有不同的目标。我真的想用一双全新的眼睛去看看牧场主里奥。Harnes是一个平台，旨在协调众多基础设施和提供商之间的信心建设步骤。Rancher Rio旨在简化您在Kubernetes的启动和运行工作。让我们来看看牧场主里奥。</p><h3>去里约热内卢</h3><p>Rancher Rio的安装过程非常简单。类似于我们围绕<a href="https://harness.io/2020/02/spinnaker-vs-harness-filming-my-journey/"> Spinnaker </a>和<a href="https://harness.io/2020/03/jenkins-x-vs-harness-filming-my-journey/"> Jenkins X </a>所做的比较，安装和部署工作负载的基本目标。<br/></p><figure class="w-richtext-align-center w-richtext-figure-type-image"/><p>虽然牧场主Rio确实更关注实际的Kubernetes部署，但它将属于一个有助于实现持续部署的伟大工具，而不是像Harness一样的持续交付。当你自己看的时候，一定要访问项目页面的<a href="https://rio.io/">工作原理</a>部分。我喜欢Rancher Rio的一点是，它可以方便地访问您的终端，并且能够站起来启动<a href="https://linkerd.io/"> LinkerD UI </a>。<br/></p><p>展望建立信任的步骤，牧场主Rio采用了一种基于<a href="https://github.com/rancher/rio/blob/v0.6.0/docs/continuous-deployment.md">拉请求的方法</a>，即<a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests"> PR </a>是核心资源或流程编排。这将Rancher Rio定位为一个部署引擎，但是您需要告诉Rancher Rio您希望您的部署在何时何地移动，并且您需要构建一个复杂的<a href="https://www.atlassian.com/git/tutorials/making-a-pull-request">拉动请求</a>。<br/></p><p>转到一个线束示例，为了实现自动化和成功的部署，我们需要接触的不仅仅是<a href="https://harness.io/2020/03/how-to-use-version-control-systems-to-deliver-better/">源代码控制</a>。利用也可以帮助协调发布策略和活动。<br/></p><figure class="w-richtext-figure-type- "/><p>并非所有部署都是同等创建的。拥有像<a href="https://harness.io/2019/07/continuous-delivery-102/">金丝雀发布</a>这样的发布策略是一种安全机制，可以确保对发布的信心。金丝雀版本是线束平台的原生版本。下图显示了一只金丝雀没有被提升，原因是自动判断呼叫风险太大，无法通过。这是由设计决定的，因为线束是基于约定的。<br/></p><figure class="w-richtext-figure-type- "/><p>目前，即使是在里约热内卢的牧场主手动制作一只金丝雀，也只是模仿在T21精心制作一只金丝雀的步骤。<br/></p><h3>命令</h3><p>这些命令中的大多数都可以在<a href="https://github.com/rancher/rio#quick-start"> Rancher Rio QuickStart </a>中找到。文档中有一个<a href="https://github.com/rancher/rio/blob/v0.6.0/docs/quick-start.md">第二快速入门</a>展示了更多关于从<a href="https://docs.docker.com/engine/reference/builder/">docker文件</a>构建的内容。我利用<a href="https://eksctl.io/"> EKSCTL </a>让<a href="https://aws.amazon.com/eks/">亚马逊EKS </a>集群启动并运行。</p><p>##Rio命令<br/>#创建EKS集群<br/> eksctl创建集群\ <br/> -名称rio-grande \ <br/> -版本1.15 \ <br/> -地区us-east-1 \ <br/> -节点组-名称standard-workers \ <br/> -节点类型t3.xlarge \ <br/> -节点2 \ <br/> -节点-最小1 \ <br/> -节点-最大3 \ <br/>-node-ami auto<br/>#删除EKS集群<br/> eksctl删除Cluster-name = Rio-grande-region = us-east-1<br/>#安装Rio<br/># https://github . com/rancher/Rio #快速启动<br/>#下载<br/>curl-sfL https://Get . Rio . io | sh-<br/>#设置<br/> rio安装<br/>#验证Pods<br/>Rio-n Rio-系统Pods</p><h3>吊带，可持续输送</h3><p>Harness平台是专为实现您的持续交付目标而构建的。将<a href="https://harness.io/2020/01/continuous-delivery-vs-continuous-deployment/">持续部署与</a>持续交付相比较，持续交付协调了安全和成功部署所需的所有建立信任的步骤。想象这是“连续的决策”,在SDLC过程中建立信心，并自动做出决定。请随意观看<a href="https://harness.io/try-continuous-delivery-as-a-service-for-free/">驾驭测试</a>以便今天就开始，不要忘记报名参加我们即将推出的<a href="https://harness.io/events/university-virtual">虚拟驾驭大学</a>。<br/></p><p>干杯！<br/></p><p>-拉维<br/></p></div></div>    
</body>
</html>