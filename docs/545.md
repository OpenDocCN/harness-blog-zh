# 带 Sonarqube 覆盖的 Bazel 吊带

> 原文：<https://www.harness.io/blog/bazel-sonarqube-coverage>

在本文中，我们将介绍如何在 Harness 中将 Bazel 和 Sonarqube 一起用于代码覆盖，以及如何使用它。

软件开发以光速进行。每天都有成千上万的代码行添加到代码库中，我们应该始终验证这些代码行是作为应用程序的一部分执行的，还是仅仅位于源代码中。

为了检查新代码或修改后的代码是否正在执行，开发人员编写单元测试。单元测试确保新的或修改后的代码在成为主存储库的一部分之前，在通过和失败的情况下都能按预期工作。

## 巴泽尔是什么？

Bazel 是 Google 开发的构建工具。谷歌在内部使用这个工具，它被称为 Blaze，来构建他们的应用程序。这是最新的开源构建工具，目前正在其上进行大量开发。但是 Bazel 最好的特性是增量构建，其中 Bazel 识别源代码中发生了什么变化，并只构建这一部分——它将其余部分保存在缓存中，并简单地从那里读取。换句话说，你的第一次构建需要时间，但是之后，每一次增量构建都需要更少的时间——除非你清空了你的缓存。

有关如何开始使用 Bazel 的更多信息，请点击[此处](https://bazel.build/docs/build)。

## 什么是代码覆盖率？

正如简介中提到的，每天都有数千行代码添加到代码库中。验证所有代码都作为应用程序的一部分运行是非常重要的。理想情况下，源代码中不应该有一行代码没有被使用——这不是好的编码实践。

代码覆盖率是软件行业中使用的一个术语，用来表示在通过和失败的情况下有多少代码正在执行并且是可达的，以及有多少代码在任何情况下都是不可达的。此外，它揭示了你的测试的有效性。这个值可以由测试用例生成，比如单元测试。执行测试用例所覆盖的行生成您的覆盖率。几乎所有的软件公司都对代码覆盖率设定了最低 80%的门槛。然而，对于一些证券和金融公司来说，这个覆盖率可以达到 100%。

让我们看一个例子来说明这个百分比意味着什么。假设您的源文件中有十行代码，并且您的代码覆盖率最低为 80%。这意味着在您添加/修改的十行代码中，只有八行可以通过测试用例达到，还有两行在任何情况下都无法达到。

## 为什么代码覆盖率是必要的？

应该计算代码覆盖率，因为它可以让您深入了解源代码中的问题，以及如何改进它。对于大型项目，将代码覆盖率提高到 70-80%以上意味着您的应用程序保持了代码质量。

1.**覆盖率洞察**:这揭示了进入代码库的代码中有多少百分比是实际上可达到的，并且在那些不可达到的代码的基础上，可以识别出并对其采取必要的行动。

2.**漏洞**:任何人都可以在任何时间以任何方式利用无法访问的额外代码。因此，一旦您识别出不必要地成为代码库一部分的代码，您就可以将其移除以保护您的应用程序。

3.**测试用例**:覆盖率低的数字不能只来自额外的代码。然而，它们可能来自不充分的测试用例。这意味着开发人员可以识别和编写更多的测试用例来覆盖未覆盖的行，并使代码覆盖率更接近定义的阈值。此外，这给了代码在各种情况下如何工作的信心。

4.代码质量:增加代码覆盖率有助于发现问题。这给了团队对他们测试的信心，并且提高了代码质量。

这些只是考虑代码覆盖的一些原因。还有许多其他重要的原因。

## Harness 如何计算代码覆盖率？

市场上许多知名的工具都会生成代码覆盖率报告。[sonar cube](https://www.sonarqube.org/)是业界最受认可的工具之一，Harness 使用它。Sonarqube 可以生成多种类型的报告——不仅仅是代码覆盖率报告:代码重复、代码气味和带有风险级别的 bug 列表。以下是声纳服务器报告表的截图。

不幸的是，到目前为止，Bazel 和 Sonarqube 之间还没有直接的整合。因此，在 Harness 中，我们使用第三方代码——更像是一个解析器——来集成 Bazel 和 Sonarqube。

Bazel 有自己的算法，通过对源代码运行测试用例来生成覆盖率。反过来，Bazel 生成 LCOV 格式的覆盖报告，这与 Sonarqube 格式不同。因此，我们使用解析器将 LCOV 格式的文件转换成 Sonarqube 能够理解的格式。然后，我们将该文件上传到 Sonarqube 服务器，在一个度量风格的表格中显示各种报告。

到目前为止，用 Bazel 和 Sonarqube 进行代码覆盖是一项昂贵且耗时的工作。因此，在 Harness 中，我们定期运行这些覆盖率数字——而不是作为 GitHub pull 请求的一部分——然后向功能所有者发送报告。

## Bazel 和 Sonarqube 的集成是如何工作的？

Bazel 有自己的算法，用命令“ ***bazel 覆盖率<模块名>*** ”生成 **LCOV** 格式的覆盖率数字。这意味着不需要在 Bazel 文件中写入任何额外的内容。然而，为了与 Sonarqube 集成，必须在 Bazel 文件中定义几个 Bazel 目标。一个目标完成所有的解析操作并创建 sonar cube 理解的文件，另一个目标将报告发送给 sonar cube 服务器。以下步骤是实现这种集成的高级解释。

1.在代码库中创建一个文件夹来存储前面提到的第三方代码片段。Bazel 将从这些源文件中创建一个可运行的目标来完成集成。

2.在模块级别创建一个 Bazel 目标。我假设您有一个 monorepo，其中托管了多个模块。这个目标将获取关于您的源文件、测试用例以及模块名称的信息。

sq _ Project(
name = " sq _ My Component "，
Project _ key = " com。举例。项目:组件"、
Project _ name = "我的项目::组件"、
srcs =[
"//path/to/Component:Java _ srcs "、
、
targets =[
"//path/to/Component:Component "、
、
test _ srcs =["//path/to/Component

3.在项目的根级别创建一个 Bazel 目标，其中包含 Sonar 服务器中的项目名称以及作为项目名称一部分的模块列表。

sonar cube(
name = " target name "，
srcs = []，
coverage _ report = ":coverage _ report "，
modules = get _ sonar cube _ targets _ separated()，
project_key = "portal 项目密钥"，
project_name = "portal 项目名称"，
scm_info = [":git"]，
sq _ properties _ filename = " Sany-filename . properties "，
tags =[" tags

4.最后，运行“***”bazel run<target name>-dsonar . HOST . URL = $ { sonar _ HOST _ URL }-dsonar . log in = $ { SONAR _ AUTH _ TOKEN }***”，使用 SONAR 服务器 DNS 名称或 IP，以及认证令牌将报告发送到 SONAR 服务器。

## 结论

向客户交付软件需要许多不同的组件，它们都有一个共同的目标——一个成功的高质量的产品。代码覆盖率本身不能被认为是决定代码质量的度量标准。然而，它应该被认为是实现高质量代码的重要部分。

每天考虑代码覆盖率不仅让 QA 工程师了解代码，也让开发人员从测试用例的角度了解代码。此外，它有助于消除漏洞，并保持源代码整洁，没有多余或不需要的代码行。

想继续读下去？在另一篇文章中了解我们为什么将[从 Maven 切换到 Bazel](https://harness.io/blog/continuous-integration/migrating-bazel-build-tool/) 。