# 利用这些先进的 GC 技术提高应用程序性能| Harness

> 原文：<https://www.harness.io/blog/improve-application-performance-advanced-gc-techniques>

应用程序性能是我们最关心的问题，垃圾收集优化是取得微小但有意义的进步的好地方。

应用程序性能是我们最关心的问题，垃圾收集优化是取得微小但有意义的进步的好地方。

自动垃圾收集(以及 JIT HotSpot 编译器)是 JVM 中最先进、最有价值的组件之一，但是许多开发人员和工程师对垃圾收集(GC)、它的工作方式以及它对应用程序性能的影响都不太熟悉。

第一，GC 到底是干什么用的？垃圾收集是堆中对象的内存管理过程。当对象被分配到堆中时，它们会经历几个收集阶段——通常很快，因为堆中大多数对象的生命周期都很短。

垃圾收集事件包含三个阶段——标记、删除和复制/压缩。在第一阶段，GC 运行整个堆，将所有东西标记为活动(被引用)对象、未被引用对象或可用内存空间。然后删除未引用的对象，并压缩剩余的对象。在分代垃圾收集中，对象“老化”,并通过其生命中的 3 个空间进行提升——伊甸园、幸存者空间和终身(旧)空间。移动也是压实阶段的一部分。

不过说够了，让我们开始有趣的部分吧！

## 了解 Java 中的垃圾收集(GC)

自动化 GC 的一大好处是开发人员不需要真正理解它是如何工作的。不幸的是，这意味着许多开发人员不明白它是如何工作的。理解垃圾收集和许多可用的 GC，有点像了解 Linux CLI 命令。从技术上讲，你并不需要使用它们，但是知道并习惯使用它们会对你的工作效率产生重大影响。

就像 CLI 命令一样，有一些绝对的基础知识。ls 命令查看父文件夹中的文件夹列表，mv 命令将文件从一个位置移动到另一个位置，等等。在 GC 中，这些类型的命令相当于知道有不止一个 GC 可供选择，并且 GC 可能会导致性能问题。当然，还有很多东西需要学习(关于使用 Linux CLI 和垃圾收集)。

学习 Java 的垃圾收集过程的目的不仅仅是为了那些不必要的(和无聊的)谈话的开始者，而是为了学习如何有效地实现和维护正确的垃圾收集过程，使其在您的特定环境中具有最佳的性能。知道垃圾收集会影响应用程序的性能是最基本的，有许多高级技术可以增强垃圾收集的性能并降低其对应用程序可靠性的影响。

## GC 性能问题

### 1.内存泄漏

了解了堆结构和垃圾收集是如何执行的，我们知道内存使用量会逐渐增加，直到发生垃圾收集事件，然后使用量又降了下来。被引用对象的堆利用率通常保持稳定，因此下降的量应该大致相同。

在内存泄漏的情况下，每个 GC 事件都会清除一小部分堆对象(尽管留下的许多对象并不在使用中)，因此堆利用率会继续增加，直到堆内存满了，并且会引发 OutOfMemoryError 异常。这是因为 GC 只将未引用的对象标记为删除。因此，即使被引用的对象不再被使用，它也不会从堆中被清除。有一些有用的编码技巧可以防止这种情况，我们稍后会谈到。

### 2.连续的“停止世界”事件

在某些场景中，垃圾收集可以调用 Stop the World 事件，因为当它发生时，JVM 中的所有线程(以及在其上运行的应用程序)都被停止，以允许 GC 执行。在健康的应用程序中，GC 执行时间相对较短，并且不会对应用程序性能产生大的影响。

然而，在次优情况下，停止世界事件会极大地影响应用程序的性能和可靠性。如果 GC 事件需要停止全局暂停并花费 2 秒钟来执行，则该应用程序的最终用户将会经历 2 秒钟的延迟，因为运行该应用程序的线程被停止以允许 GC。

当内存泄漏发生时，连续停止世界事件也是有问题的。由于每次执行 GC 都会清除更少的堆内存空间，所以剩余内存填满的时间也更短。当内存满时，JVM 触发另一个 GC 事件。最终，JVM 将重复运行 Stop the World 事件，从而导致严重的性能问题。

### 3.CPU 使用率

这一切都归结于 CPU 的使用。持续的 GC / Stop the World 事件的一个主要症状是 CPU 使用率的激增。GC 是一项计算量很大的操作，因此会占用过多的 CPU 资源。对于运行并发线程的 GC 来说，CPU 使用率可能会更高。为您的应用程序选择正确的 GC 将对 CPU 的使用产生最大的影响，但是还有其他方法可以优化这方面的性能。

从这些围绕垃圾收集的性能问题中，我们可以理解，不管 GC 有多先进(而且它们正在变得相当先进)，它们的致命弱点仍然是一样的。冗余和不可预测的对象分配。要提高应用程序的性能，选择正确的 GC 是不够的。我们需要知道这个过程是如何工作的，我们需要优化我们的代码，这样我们的 GC 就不会占用过多的资源或者导致应用程序过多的暂停。

## 分代 GC

在我们深入研究不同的 Java GCs 及其性能影响之前，理解分代垃圾收集的基础很重要。分代式 GC 的基本概念是基于这样一种思想，即对一个对象的引用在堆中存在的时间越长，它被标记为删除的可能性就越小。通过用一个形象的“年龄”来标记对象，它们可以被分离到不同的存储空间，以便被 GC 标记为不太频繁地删除。

当一个对象被分配到堆中时，它被放在所谓的伊甸园空间中。这是对象开始的地方，在大多数情况下，这是它们被标记为删除的地方。在该阶段幸存的对象“庆祝生日”并被复制到幸存者空间。

伊甸园和幸存者空间组成了所谓的年轻一代。这是大部分动作发生的地方。当(如果)年轻一代中的对象达到一定年龄时，它被提升到终身(也称为旧)空间。根据年龄划分对象内存的好处是 GC 可以在不同的层次上运行。

次要 GC 是只关注年轻一代的集合，实际上完全忽略了终身空间。一般来说，年轻一代中的大多数对象都被标记为删除，不需要大规模或完全的 GC(包括老一代)来释放堆上的内存。当然，必要时会触发大规模或全面的垃圾收集。

在此基础上优化 GC 操作的一个快速技巧是调整堆区域的大小，以最好地满足应用程序的需求。

### 收集器类型

有许多可用的 GC 可供选择，尽管 G1 成为 Java 9 中的默认 GC，但它最初是用来替代低暂停的 CMS 收集器，因此使用吞吐量收集器运行的应用程序可能更适合使用当前的收集器。对于 Java 垃圾收集器来说，理解操作上的差异和性能影响上的差异仍然很重要。

### 连续的

串行收集器是最简单的，也是最不可能使用的，因为它主要是为单线程环境(例如 32 位或 Windows)和小堆设计的。这个收集器可以垂直扩展 JVM 中的内存使用，但是需要几个主要/完整的 GC 来释放未使用的堆资源。这导致频繁的 Stop the World 暂停，这使得它在面向用户的环境中使用起来毫无意义。

### 平行的

顾名思义，这个 GC 使用并行运行的多线程来扫描和压缩堆。尽管并行 GC 使用多线程进行垃圾收集，但它仍然会在运行时暂停所有应用程序线程。并行收集器最适合需要优化以获得最佳吞吐量的应用程序(吞吐量收集器),并且可以承受更高的 exchange 延迟。

### 低暂停收集器

大多数面向用户的应用程序需要低暂停 GC，这样用户体验就不会受到长时间或频繁暂停的影响。这些 GC 都是关于优化响应性(时间/事件)和强大的短期性能。

### 并发标记清除(CMS)

与并行收集器类似，并发标记清除(CMS)收集器利用多线程来标记和清除(删除)未引用的对象。但是，该 GC 仅在两种特定情况下启动停止世界事件:

1.  当初始化根(从线程入口点或静态变量可到达的老一代中的对象)或 main()方法的任何引用的初始标记时，等等
2.  当应用程序在算法同时运行时改变了堆的状态，迫使它返回并做一些最后的处理，以确保它标记了正确的对象

### G1

垃圾优先收集器(通常称为 G1)利用多个后台线程来扫描它划分为多个区域的堆。它的工作方式是扫描那些包含最多垃圾对象的区域，以便首先回收它们，并给它们命名(垃圾优先)。

这种策略减少了在后台线程完成扫描未使用的对象之前耗尽堆的机会，在这种情况下，收集器必须停止应用程序。G1 收集器的另一个优点是它可以在运行中压缩堆，这是 CMS 收集器只在完全停止世界收集时才会做的事情。

## 提高 GC 性能

应用程序性能直接受到垃圾收集的频率和持续时间的影响，这意味着垃圾收集过程的优化是通过减少这些指标来完成的。有两种主要的方法可以做到这一点。首先，通过调整年轻代和老代的堆大小，其次，降低对象分配和提升的速率。

就调整堆大小而言，这并不像人们预期的那样简单。合乎逻辑的结论是，增加堆大小会降低 GC 频率，同时增加持续时间，而减少堆大小会降低 GC 持续时间，同时增加频率。

然而，事实是，一次小规模 GC 的持续时间并不依赖于堆的大小，而是依赖于收集后存活下来的对象的数量。这意味着对于主要创建短期对象的应用程序，增加年轻一代的规模实际上可以减少 GC 的持续时间和频率。但是，如果增加年轻一代的大小会导致幸存者空间中需要复制的对象显著增加，那么 GC 暂停将需要更长时间，从而导致延迟增加。

## 编写 GC 高效代码的 3 个技巧

### 提示#1:预测收集容量

所有标准的 Java 集合，以及大多数定制和扩展的实现(比如 Trove 和 Google 的 Guava)，都使用底层数组(要么基于原语，要么基于对象)。由于数组的大小一旦分配就不变，因此在许多情况下，向集合中添加项可能会导致旧的基础数组被丢弃，以支持更大的新分配的数组。

大多数集合实现都试图优化这种重新分配过程，并将其保持在摊销的最小值，即使没有提供预期的集合大小。但是，通过在构造时为集合提供预期的大小，可以获得最佳结果。

### 技巧#2:直接处理流程

例如，在处理数据流(如从文件中读取的数据或通过网络下载的数据)时，通常会看到如下内容:

###### byte[]File data = readFileToByteArray(新文件("我的文件。txt "))；

产生的字节数组可以被解析成 XML 文档、JSON 对象或协议缓冲区消息，这是几个常见的选项。

当处理大文件或大小不可预测的文件时，这显然是一个坏主意，因为如果 JVM 实际上不能分配整个文件大小的缓冲区，它会将我们暴露给 OutOfMemoryErrors。

更好的方法是使用适当的 InputStream(在本例中是 FileInputStream)并将它直接输入解析器，而不是先将整个内容读入一个字节数组。所有主要的库都公开 API 来直接解析流，例如:

###### file inputstream fis = new file inputstream(文件名)；
MyProtoBufMessage msg = MyProtoBufMessage . parse from(fis)；

### 技巧 3:使用不可变对象

不变性有很多优点。一个很少得到应有关注的问题是它对垃圾收集的影响。

不可变对象是这样一种对象，它的字段(在我们的例子中特别是非基元字段)在构造后不能被修改。

不可变性意味着不可变容器引用的所有对象在容器构造完成之前都已创建。用 GC 术语来说:容器至少和它所保存的最年轻的引用一样年轻。这意味着当在年轻一代上执行垃圾收集周期时，GC 可以跳过位于老一代中的不可变对象，因为它肯定知道它们不能引用正在被收集的一代中的任何东西。

要扫描的对象越少，意味着要扫描的内存页面越少，要扫描的内存页面越少，意味着 GC 周期越短，意味着 GC 暂停时间越短，整体吞吐量越好。

注意，不可变对象本身并不能帮助你使用 GC。如果一个应用程序必须不断地创建新的不可变对象，那么由于不断地创建对象，它可能会运行更长的 GC 周期。注意应用程序将如何使用不可变对象，希望它们被提升到永久堆空间。