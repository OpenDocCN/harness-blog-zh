<html>
<head>
<title>Git Branching in Harness | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>线束中的Git分支|线束</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/git-branching#0001-01-01">https://www.harness.io/blog/git-branching#0001-01-01</a></blockquote><div><p>Git分支提供了一种简单的方法来进行配置更改，并减少了开发、测试和维护CI/CD管道的时间。找出方法。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>版本控制系统引入了跟踪文件版本的概念，并通过分支、修改、测试，然后在批准和CI检查后合并到主分支来单独进行更改。</p><figure class="w-richtext-figure-type- "/><p>Git体验支持分支概念，在这种情况下，我们可以遵循类似的线束实体范例，如管道、连接器等。我们可以从主分支分叉，在不破坏其他分支的情况下进行更改，隔离测试，然后将其合并回主分支——就像任何其他代码更改一样。</p><p>要求</p><figure class="w-richtext-figure-type- "/><h2>我们对Git分支有以下要求:</h2><p>丰富的用户体验，每种实体类型都有单独的部分。</p><ol role="list"><li>支持实体的分页和高级过滤。</li><li>渲染实体的低延迟。</li><li>提供相同的体验，即使禁用了Git体验。</li><li>挑战和解决方案</li></ol><figure class="w-richtext-figure-type- "/><figure class="w-richtext-figure-type- "/><h2>为了满足这些要求，我们面临以下挑战:</h2><p>Git是基于文件系统的存储。要在每次有人提供过滤器时从Git中检索数据，您必须扫描Git中的所有文件，然后解析它们以满足UI请求。这将导致长时间的等待。</p><ul role="list"><li>即使我们将Git的状态保持在利用中，将从 Git到利用的变化<em>对齐也是一个挑战。</em></li><li>用户可以在不改变配置的情况下继续创建分支，有时他们不希望这些分支处于束缚中。</li><li>作为缓存的MongoDB</li></ul><h3>为了优化，我们使用Mongo作为缓存，解析所有的实体，并将它们保存在数据库中。这让我们克服了从g it获取数据时可能会遇到的性能瓶颈。</h3><p>Git Webhooks</p><h3>因为所有的Git提供者都有针对Git上不同事件的webhooks，所以我们用它们来更新我们的Mongo。一旦启用了Git体验，我们就在Git中自动注册webhook。这导致Harness在Git中接收不同种类的事件。</h3><p>收到事件后，我们将它们排队，然后异步更新我们的系统。例如，当我们收到一个分支创建事件时，我们更新显示在UI中的分支列表。类似地，当我们收到一个分支删除事件时，我们从Harness Mongo缓存中删除该分支。此外，当我们接收到推送事件时，我们获取提交中每个文件的内容，并更新线束实体。</p><p>为了优化分支和回购过滤器，我们将它们与其他数据一起存储在我们的实体中。</p><p>分行入围名单</p><h3>Git中任何新分支的创建并不总是意味着配置的改变。我们提供按需同步，以防用户想要同步特定分支。在触发同步时，我们提取该分支的每个实体，解析它们，然后将它们存储在Mongo中。</h3><p>用户体验</p><figure class="w-richtext-figure-type- "/><h2>我们为想要从Harness UI添加/修改实体的用户提供了类似于git提供者的用户体验。</h2><p>Git操作的用户凭据</p><h3>为了识别用户对Harness的提交，我们使用了用户概要的概念。在用户配置文件下，我们有一个源代码管理器，用户必须提供他们的个人访问令牌来对Git进行任何更改。SCM对于审计对项目及其管道、连接器等进行变更的人员非常有用。这也有助于遵守回购中设定的分支规则。</h3><p>分支分叉和PR创建</p><figure class="w-richtext-figure-type- "/><h3>当从Harness UI推送至Git时，我们为用户提供了推送至新分支或现有分支的能力，以及创建PR。这将有助于用户分叉分支，并在合并之前得到审查。此外，这将允许其他人继续从主分支处理管道，而配置更改仍在审查中。</h3><p>实体列表</p><figure class="w-richtext-figure-type- "/><h3>为了让用户在多回购场景下有一个无缝的体验，我们列出了默认的分支实体，然后用户可以按回购分支筛选得到实体。此外，在多个分支的情况下，用户可以对任何分支进行筛选，查看所有实体，并应用高级筛选器。</h3><p>跨分支机构交换实体</p><figure class="w-richtext-figure-type- "/><h3>为了在分支之间无缝切换并进行比较，我们允许用户在任何实体的细节部分切换分支。</h3><p>结论</p><figure class="w-richtext-figure-type- "><figcaption>Pipeline in Main Branch</figcaption></figure><figure class="w-richtext-figure-type- "><figcaption>Same Pipeline in Develop Branch</figcaption></figure><h2>Git同步和Git分支为现代DevOps解决方案带来了巨大的潜力。它们提供了一种简单的方法来进行配置更改，并帮助开发人员减少开发、测试和维护CI/CD管道的总时间。特别是，分支可以让一个分支中的所有配置变更在投入生产之前被隔离测试。此外，它使他们不会因为不正确的配置更改而阻止任何人。</h2><p>和我们一起推进你的阅读之旅！看看我们是如何利用<a href="https://harness.io/blog/harness-gitops-deployments/" target="_blank"> GitOps </a>的。如果你错过了姐妹文章，<a href="https://harness.io/blog/git-sync-experience/" target="_blank"> Git同步体验</a>，现在可以随意阅读。</p><p><em>本文由阿比纳夫·辛格、阿卡什·纳加拉詹、拉玛·图马拉和迪帕克·帕坦卡尔合作撰写。</em></p><p><em>本文由阿比纳夫·辛格、阿卡什·纳加拉詹、拉玛·图马拉和迪帕克·帕坦卡尔合作撰写。</em></p></div></div>    
</body>
</html>