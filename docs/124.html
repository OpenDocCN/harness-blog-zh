<html>
<head>
<title>How Harness Gets Ship Done With Zero Downtime and CD | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在零停机时间和CD |吊带的情况下完成运输</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/how-harness-gets-ship-done-with-zero-downtime-and-continuous-delivery#0001-01-01">https://www.harness.io/blog/how-harness-gets-ship-done-with-zero-downtime-and-continuous-delivery#0001-01-01</a></blockquote><div><p>零停机时间的CD:让我们从Harness工作流引擎的简化架构概述开始。立即了解更多信息。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>这是工程师对我们如何实现零停机、零影响部署的看法。让我们从与本主题相关的Harness工作流引擎的简化架构概述开始。</p><h2>概观</h2><p>Harness有一个名为<strong> <em> Manager </em> </strong>的关键组件，负责编排管道和工作流的执行。管理器是一个横向扩展的多租户服务，它与<strong> <em>代表</em> </strong>协调工作流步骤的执行。</p><p>委托是在客户的前提下运行的管理流程。这是Harness架构的一个关键部分，它使Harness能够在客户环境中编排复杂的工作流，而无需访问客户资源(只有客户代表需要访问客户资源)。</p><p>下面是一个管道执行示例:</p><figure class="w-richtext-figure-type- "/><p>图中的每个方框代表一个州。对于与客户资源交互的状态，执行需要经理和客户代表之间的沟通。因为只有代表可以访问客户资源，所以他们是做实际工作的人。</p><p>下面的框图说明了一个这样的状态的执行流程。方块<strong> M </strong>代表管理进程，方块<strong> D </strong>代表委托进程。</p><figure class="w-richtext-figure-type- "/><ol role="list"><li>执行/通知事件已排队</li><li>事件出列并由管理器处理</li><li>[如果需要],经理创建一个任务[对代表执行]</li><li>任务由经理处理</li><li>任务被分配给代理人。委托开始执行。</li><li>将任务状态报告委托给经理</li></ol><p>如果状态机不处于终端状态，流程返回步骤1。</p><h2>主要挑战</h2><p>Manager是一个多租户服务，运行在一个集群中。委托是在客户处运行的独立流程。可能会有数千个委托流程(每个客户有多个委托)，随着我们的发展，这一数字还会增加一个数量级。代表们坐在不同环境和不同网络连接质量的客户场所。虽然作为中央服务的管理器可以更可靠、更快速地升级，但是代理的升级过程需要不同的时间来收敛。这给我们的升级过程带来了独特的挑战。</p><p>为了可靠地执行，要求执行中涉及的所有进程相互兼容。</p><p>以下两个图表显示了执行中涉及不兼容版本的情况(颜色代表服务的特定版本):</p><figure class="w-richtext-figure-type- "/><p><br/> <br/> <strong>上图描述了一个场景，其中代表使用的版本不同于经理。</strong> <br/></p><figure class="w-richtext-figure-type- "/><p><br/> <strong>上图描述了一个场景，其中一个管理器实例与另一个管理器实例的版本不同。</strong></p><p>此外，对于Harness SaaS，在任何给定时间都有许多客户正在执行工作流。在客户没有持续活动的情况下，永远没有升级线束的好时机。当我们升级Harness本身时，我们需要确保这些执行不受影响。</p><h2>我们的方法:支持多个活动版本</h2><p>为了实现无缝升级，我们采用了支持多个活动版本的方法。执行中涉及的所有实体都知道它们的版本；并且只有兼容的版本才参与执行。</p><p>下图说明了这一点。请注意，彩色实体是版本感知的。从管理器到委托的调用被版本化(使用HTTP头),队列和任务实体被版本化，以便只有兼容的管理器进程才能处理它们。</p><figure class="w-richtext-figure-type- "/><p><br/> <br/>让我们放大到经理端实现。下图描述了Manager的流量，这是一个Kubernetes部署。它有一个负载平衡器、入口控制器、Kubernetes服务和管理器单元。</p><figure class="w-richtext-figure-type- "/><p><br/>我们为我们部署的每个管理器版本创建特定于版本的部署、服务和入口对象。由于基于HTTP头的入口规则，来自代理的流量到达相同版本的管理器pod。此外，我们还有一个主要服务，它每次指向一个特定版本的管理器pod。所有客户流量都流向主服务。</p><p>当需要部署一个新版本时，我们让旧版本保持运行，同时在管理者和代表端启动新版本(在上图中以绿色显示)(这类似于<a href="https://harness.io/blog/istio-support-for-blue-green-and-canary/" target="_blank">蓝绿色</a>，但更灵活，因为它可以有两个以上的活动版本)。</p><p>所有现有的执行都在以前的版本上继续进行，没有中断。由于主服务仍然指向旧版本，因此还没有客户请求命中新版本。这使代表们有充分的机会使用新版本来启动流程，并向新经理注册。</p><p>当验证完成时，新版本已准备就绪，可以为客户请求提供服务，所有代表的连接都已建立。此时，主服务被更新以指向新版本，并且来自用户的新呼叫开始去往新版本。见下图。</p><figure class="w-richtext-figure-type- "/><p><br/>请注意，我们将长期保留旧版本的管理器和代理。在旧版本上开始的执行在同一版本上继续进行。这些执行可能需要几个小时才能完成(例如，带有验证的长管道，触发Jenkins作业，并等待它们完成)。</p><p>保留旧版本给了我们额外的即时回滚能力。由于旧版本的所有代理仍然运行并连接到旧版本的管理器，回滚只需要将主服务翻转回旧版本的管理器。这为我们节省了启动前面讨论的委派流程的预热时间。</p><p>在代理端，我们有类似的并行运行多个版本的能力。代理盒上的代理[称为观察者]获取所需版本的目标状态，并确保这些版本在代理盒上启动并运行。每个委托进程都使用基于HTTP头的路由连接到相应版本的管理器。</p><figure class="w-richtext-figure-type- "/><p>虽然我们有一种机制可以一次保持多个版本活动，但为了操作简单，在任何给定的时间都保持两个版本(n+1版本展示拆除n-1)。</p><p>当然，我们使用Harness来部署Harness，下面显示了我们自己的部署的执行:</p><figure class="w-richtext-figure-type- "/><p><br/>部署步骤是:</p><ol role="list"><li>拆卸经理/代表的n-1版本</li><li>部署n+1版本</li><li>验证n+1上的服务健康状况</li><li>将主开关切换到n+1</li></ol><p>这种机制使我们能够实现零停机时间，随时升级线束。我们的生产部署每天进行一次。回滚机制在过去4周内使用了两次。</p><p>我们在不断发展我们的系统，并乐于分享我们的知识。</p><p>普内特&amp;布雷特。</p></div></div>    
</body>
</html>