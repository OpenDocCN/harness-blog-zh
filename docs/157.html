<html>
<head>
<title>Tutorial: [Monitoring and Observability] How to Send Kubernetes Delegate Logs to Splunk | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>教程:[监控和可观察性]如何将Kubernetes委托日志发送到Splunk | Harness</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/tutorial-kubernetes-delegate-logs-splunk#0001-01-01">https://www.harness.io/blog/tutorial-kubernetes-delegate-logs-splunk#0001-01-01</a></blockquote><div><p>所以…你活在梦里，对吗？您的工作负载在Kubernetes上运行，您的SRE/监控/可观察性技术体系中有Splunk。最棒的是:你是一个快乐的线束用户。很自然，您决定将Harness委托作为K8s StatefulSet运行。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>所以…你活在梦里，对吗？您的工作负载在<strong> Kubernetes </strong>中运行，您的SRE/监控/可观察性<strong>技术栈</strong>中有<strong> Splunk </strong>。最棒的是:你是一个快乐的<strong>线束</strong>用户。</p><p>很自然，您决定将Harness委托作为K8s StatefulSet运行。您正在阅读来自<a href="http://kubernetes.io/" target="_blank"> Kubernetes.io </a>的这个<a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/" target="_blank">惊人的文档</a>，但是您仍然不确定如何实现一个好的日志转发设计。</p><p>别担心，我高贵的SRE。集成离你只有一个文件描述符了！啊，自动字段检测+去除可能干扰事件的颜色和其他控制字符。</p><p>系好安全带。</p><h2>辅导的</h2><h3>要求</h3><h3>第一步</h3><p>让我们配置我们的Splunk HEC，然后将令牌作为机密存储在Harness中。</p><p>1-) HEC UI -示例:</p><figure class="w-richtext-figure-type- "/><p>2-)然后是安全存储的令牌(我们在Splunk的HEC设置中获得的那个):<br/></p><figure class="w-richtext-figure-type- "/><p>这样，您可以看到index=harness_deployed_apps将成为我们的代理日志的主目录。</p><h3>第二步</h3><p>好了，是时候给<a href="https://github.com/splunk/splunk-connect-for-kubernetes/tree/develop/helm-chart/splunk-connect-for-kubernetes/charts/splunk-kubernetes-logging" target="_blank"> Splunk </a>配置线束了。</p><p>您可以看到，这是一个非常容易理解的Splunk管理的掌舵图。要更深入地了解该机制，请查看README.md。</p><p>在这一步中，我们创建了一个<strong>服务</strong>:</p><figure class="w-richtext-figure-type- "/><p>魔术从这里开始:</p><p><br/> 1-)让我们创建一个指向Splunk项目的源回购:</p><figure class="w-richtext-figure-type- "/><p>2-)回到服务UI——让我们链接一下那个叫做splunk-kubernetes的漂亮的掌舵图——日志记录如下:</p><p><br/> <strong>分支:</strong>主<br/> <strong>文件/文件夹路径:</strong>Helm-chart/splunk-connect-for-kubernetes/charts/splunk-kubernetes-logging/<br/><strong>Helm版本:</strong> v3</p><figure class="w-richtext-figure-type- "/><p>好吧，看起来不错！</p><h3>第三步</h3><p>我们将使用Harness强大的覆盖引擎，这样我们就不需要管理那个项目的分叉。我们可以通过覆盖缺省值(GH项目中的值)中的一些条目来完成所有需要的步骤。</p><p>重要:Harness Delegate Pod将输出日志，因此我们只需很少的定制就可以使用它。</p><p>你可以阅读<a href="https://github.com/splunk/splunk-connect-for-kubernetes/blob/develop/helm-chart/splunk-connect-for-kubernetes/charts/splunk-kubernetes-logging/values.yaml"> values.yaml </a>来确认你是否需要改变什么。您可能还需要请Splunk管理员与您一起查看，但这非常简单！</p><p><strong>这是我的超驰部分，在线束UI: </strong></p><p># Local splunk配置<br/>SPLUNK:<br/># Configurations<strong>for</strong>HEC(HTTP<strong>Event</strong>Collector)<br/>HEC:<br/># host是必需的，应由用户提供<br/>host:"&lt;SPLUNK _ HEC _ HOSTNAME&gt;"<br/># port<strong>to</strong>HEC，<strong>可选</strong>， <strong>默认</strong> 8088 <br/>端口:【8088】<br/>#令牌是必需的，应由用户<br/>令牌提供<strong>:" $ { secrets . getvalue(" splunk _ HEC _ delegate _ logs ")} "<br/>#协议有两个选项:" http "和" https "，<strong>默认</strong>是" https" <br/>协议:" http" <br/> # indexName告诉哪个索引<strong> <strong>如果</strong>它<em>不存在，将使用“主”。</em><br/>index name:" harness _ deployed _ apps "<br/><br/>fluentd:<br/># path<strong>of</strong>log files，<strong>default</strong>/var/log/containers/*。日志<br/>路径:/var/log/containers/* <strong>委托</strong> *。日志<br/></strong></strong></p><h3>第四步</h3><p>嘿，让我们使用props.conf来删除任何可能影响Splunk搜索头可读性的着色日志字符。</p><p>为了使这更容易，我将把我们的Harness委托源类型(Splunk)映射到一个非常好的SED命令，在“System Local”中。这对我们会有用的！您的Splunk管理员可能有一个Deployer + Apps +等来为您组织它。</p><p>让我们继续前进！</p><p>1-)如果你没有从初始值YAML改变太多，这是我们的源类型:<br/></p><figure class="w-richtext-figure-type- "/><p>2-)请编写这个文件:</p><p>vim /opt/splunk/etc/ <strong>系统</strong> / <strong>本地</strong> /props.conf <br/></p><p>3-)让我们添加我们非常聪明和神奇的sed命令:</p><p>[kube:container:Harness-delegate-instance]<br/>SEDCMD-Harness = s/\ x1B \[[0-9<em>；]*[a-zA-Z]//g</em>T3】</p><h3>第五步</h3><p>现在让我们部署它！我将使用一个非常简单的滚动部署！</p><p>这是这样的:</p><figure class="w-richtext-figure-type- "/><h3>最后一档</h3><p>好了，是时候检查这是否有效了。我会跳进我的搜索头实验室。</p><p>我将运行一个错误的Splunk查询，但是我是我的实验室集群中唯一的一个。所以，没有伤害！这里:</p><figure class="w-richtext-figure-type- "/><h2>结果:</h2><p>看起来太棒了！让我们部署一个虚拟的NGINX，然后我们可以放置我们众所周知的TaskID来确保我们没有做任何疯狂的事情:</p><figure class="w-richtext-figure-type- "/><p>让我们得到我们的任务ID:</p><figure class="w-richtext-figure-type- "/><p>我很幸运拥有这一系列技术！看看这个:</p><figure class="w-richtext-figure-type- "/><p>有任何问题或意见吗？让我知道-我总是乐意帮忙。</p><p>加百列</p></div></div>    
</body>
</html>