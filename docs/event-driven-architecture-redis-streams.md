# 使用 Redis 流的事件驱动架构| Harness

> 原文：<https://www.harness.io/blog/event-driven-architecture-redis-streams>

事件驱动架构使用事件在各种独立的微服务之间进行通信。看看我们如何在 Harness 实现它。

现代软件业发展迅速。在一个单一的世界中，很容易将所有东西放在同一台机器上，将应用程序状态存储在几个数据库(关系/非关系)中，并横向扩展服务器。随着规模和用例种类的增加，该行业开始适应并引入微服务——一个服务完成一项集中的工作，并与其他服务进行足够的通信以启动工作。

多个服务的状态转移是如何发生的？一个简单的答案是让每个服务公开 REST 端点，并在需要时对相关服务进行 HTTP 调用。这对于某些类型的应用程序肯定会很好，但不是所有的。如果您的应用程序同步通信(用户-服务以及服务-服务通信)，就不需要额外的复杂性，您可以只依赖 HTTP 调用。然而，从长远来看，处理这种模式可能具有挑战性，原因如下:

*   每个服务都需要知道如何与所有其他服务对话。
*   你如何处理单一服务降级？
*   如果 HTTP 调用失败，您会重试多少次？

这些是事件驱动架构通过确保每个服务都在做它应该做的事情和应该做的时间，从根本上试图解决的一些问题。

事件驱动架构使用事件在各种独立的微服务之间进行通信。它使应用程序能够在这些事件发生时采取行动。

## 实现事件驱动的架构

实现事件驱动架构有多种选择。其中一些是:

*   阿帕奇卡夫卡
*   Redis 流
*   云选项，例如:
*   谷歌发布/订阅
*   AWS 事件桥

可以根据您的使用案例的生产时间、采用难易程度、消息排序、弹性、事件重放、持久性、重试次数、最少/最多一次交付、成本等来选择最合适的一个。

我们将在这篇博客中使用 Redis 流讨论 Harness 的事件驱动架构。在深入到事件驱动架构之前，理解什么是 Redis 和 Redis 流是很重要的。

## Redis 是什么？

Redis 是一个开源的内存数据结构存储，用作数据库、缓存和消息代理。

Redis 的重要特征:

*   特性丰富: Redis 可以在缓存、分布式锁定、发布订阅、实时分析、地理空间查询等方面提供帮助。
*   **生产级**:除了适应各种用例的灵活性之外，Redis 还提供了各种部署方法，以便在生产中使用本机高可用性&可扩展性解决方案。
*   **简单:【Redis 入门只需三个命令(其他操作系统中等效可用)。
    $ brew 安装 redis
    $ brew 服务启动 redis
    $ redis-cli**
*   **广泛的客户端支持:**你可以通过 [40 多个客户端](https://redis.io/clients)以你喜欢的语言连接到 Redis(很多都是官方维护的)。

## Redis 流

Redis Streams 是一种仅附加的数据结构，有助于各种流用例，如实时消息传递(RTM)、消息代理等。在深入 Redis 流之前，让我们先看一下 Redis 为服务间通信提供的另一个结构:Redis Pub/Sub。

### 发布/订阅

Redis 发布/订阅实现了发布/订阅消息传递范例。让我们用多个终端窗口来玩一玩。打开四个终端选项卡，并在所有选项卡中输入 redis-cli。我们将从一个窗口(Redis 客户端)发布到一个频道，并从其他三个窗口订阅该频道。

如您所见，第一个客户端正在频道 1 上发布消息“hello world”。其他三个客户端无休止地订阅 channel1，并接收通过发布者发送的消息。这里需要注意的是，subscribe 命令是一个永远阻塞的操作，它会无休止地等待新消息出现在通道上。

**关于发布/订阅需要注意的关键事项:**

*   仅限扇出。所有活跃用户立即获得所有消息。
*   任何消息都不会保存在内存中(一次性发送或最多一次发送)。
*   如果客户端在消息发布后订阅，则不会传递之前的消息。

### 流

Redis Streams 是在 Redis 5.0 中作为一种新的数据结构引入的，它模拟了一种类似只附加日志文件的结构。注意 Redis Streams 和 Apache Kafka 之间的关键区别在于，Streams 在 Redis 中仅仅是一个具有高级操作的仅附加列表数据结构，而另一方面，Kafka 是一个由各种组件组成的完整平台。让我们讨论一下可以在流上执行的操作:

1.  向流中添加数据(返回唯一 ID)
    XADD * key 1 value 1 key 2 value 2
2.  从流中读取数据
    xdread BLOCK<BLOCK time out>COUNT<COUNT>STREAMS<stream name>id>
3.  消费者群体
4.  创建组
    XGROUP 创建<流名称>组名称> $
5.  以消费者身份读取
    xread GROUP GROUP<GROUP name><consumer name>COUNT<COUNT>STREAMS<stream name>>
6.  确认具有特定 ID 的消息
    XACK<stream name>group name>ID>
7.  范围查询
    XRANGE<stream name><start-id><end-id>
8.  截断流
    XTRIM<stream name>MAXLEN<MAXLEN>

#### **有溪流的酒馆/酒馆**

发布可以通过 XADD channel1 *消息“hello world”来实现

订阅可以通过 XREAD 块 5000 STREAMS channel1 $实现，然后在这个循环中不断传递最后获取的 id。

#### **随流阅读的消费群体**

1.  推送消息至流媒体
    XADD channel1 *消息“hello world”
2.  创建消费群
    XGROUP 创建频道 1 group1 0-0
3.  作为组的消费者从流中读取消息
    XREADGROUP 组组 1 消费者 1 计数 5 个流通道 1 > #读取组 1 的未读消息

其他命令如 XPENDING、XCLAIM、XTRIM 等。在 [Redis 流介绍页面](https://redis.io/topics/streams-intro)中讨论。

**关于流需要注意的关键事项:**

*   消息传递的拉机制。
*   消息的持久性，直到被显式截断。
*   消费者群体可以在某个 ID 之后获取消息。
*   消息需要显式确认，否则消息将留在等待重新传递的队列中。

## 利用事件驱动架构

我们在 Harness 最近为即将到来的发布转移到了微服务世界。多个服务发布事件，其他服务通过监听特定的流来驱动最终用户的功能，从而有选择地使用这些事件。

### 为什么 Redis 流优于其他选项？

*   **基础设施设置**:我们的基础设施中已经有 Redis 用于其他用例，比如缓存和分布式锁定。这使我们能够专注于更快的交付，因为本地、暂存和本地环境不需要任何特殊处理。
*   **消息规模**:基于我们对服务中各种用例的估计，我们发现我们最初的规模大约是每分钟几千条消息。一开始就引入卡夫卡或类似的新工具将会矫枉过正。然而，我们的终端用户 API 是通用的，因此后端数据存储可以在稍后阶段进行切换，只需对采用者进行最小的更改。
*   **吞吐量:**由于 Redis 是一个内存中的数据存储，它为我们提供了一个非常快速的后端，这有助于流消费者在消息发布时立即采取行动。

### 履行

我将让您先睹为快，只需一个 Redis 实例和几行代码就可以轻松启动并运行它:

下面是上面代码的[要点](https://gist.github.com/raj454raj-harness/4bb5ef25bf3b590f14c95add15e6ccff)。

### 挑战

当使用 Redis 流在 Harness 实现事件驱动架构时，我们面临以下一些挑战:

*   监控:
*   可用于监控流的命令:
*   **XINFO，XLEN:** 可用于对溪流进行基本监控。
*   **内存使用量:**可用于每个流的内存使用量(开销很大)。
*   除了以上所述，检查流架构的其他一些方面有点棘手——消费者群体离流的头部有多远，消费/确认的速度，等等。-并且可能需要在其上实现定制的监控应用程序。
*   持久性:
*   由于 Redis 是一个内存中的数据存储库，持久化大量事件的成本会很高。需要主动监控来记录事件的流入。
*   有几种方法可以确保总内存使用量不会达到峰值:
*   **事件有效载荷大小**:获取流的总内存使用量(memory usage)除以流的长度(XLEN)。确保这个指标在任何版本发布后都不会急剧增加(如果流的大小很大，这在 Redis 服务器上代价很高)。
*   **流长度**:您可以使用带有 MAXLEN 或 MINID 参数的 XADD 命令来确保流始终被限制，并且最早的条目被自动清除(XTRIM 用于手动被动截断)。
*   弹性:
*   对于 Redis Streams，从您的架构设计开始，您将不得不担心一些事情:
*   Redis 的部署(最好是托管解决方案或自托管 [Sentinel](https://redis.io/topics/sentinel) 部署，以实现高可用性)。
*   [行首阻塞](https://en.wikipedia.org/wiki/Head-of-line_blocking):您将不得不使用 XAUTOCLAIM(或者 XPENDING 和 XCLAIM 的组合)来找出由于消费者处理中的任何错误而被再次处理的消息。为了避免这样的问题，根据一个度量标准(传递计数/第一次传递后经过的时间/自定义度量标准)，您需要将消息放在流的顶部，因为新消息可能会等待处理。该消息可以被完全遗忘或者被存储在第二存储器中用于进一步分类。

## 结论

我们通过使用 Redis Streams 实现了一个事件驱动的架构，并且已经在生产中部署了几个月了。与 Apache Kafka 等高级解决方案相比，Redis Streams 是实现事件驱动架构的一个更轻量级的解决方案。您需要根据您的用例以及您期望从事件驱动架构中获得的特性来决定哪一个是最佳实现。

看来你喜欢阅读技术深度潜水！如何阅读我们关于[大规模性能架构特征标志](https://harness.io/blog/architecting-feature-flags-performance/)或[审计跟踪 201:技术深度探讨](https://harness.io/blog/audit-trails-technical/)的文章？

感谢您的阅读，我希望您对在您的项目中使用 Redis 流感到兴奋！

-拉吉