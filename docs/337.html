<html>
<head>
<title>GraphQL Tutorial - How to Interact w/ Harness API using Python | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>GraphQL教程-如何使用Python | Harness与Harness API交互</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/graphql-python-api#0001-01-01">https://www.harness.io/blog/graphql-python-api#0001-01-01</a></blockquote><div><p>答案永远是Python。在本教程中，我们将学习如何使用Python与Harness API进行交互。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>我们不断地向GraphQL添加新的实体，这使得与Harness的编程交互变得非常有趣。</p><p>自然地，我们开始看到以编程方式与Harness GraphQL交互的多个用例，以获得诸如“每个服务有多少个实例？好的，那么每个服务的环境呢？”</p><p>我对壳剧本上瘾了。简单又强大。但是，根据复杂性以及如何操作GraphQL结果集，阅读代码(并支持它)可能会成为一场噩梦。因此，我花了一些时间寻找一种方法来自动理解这种交互的HTTP方面，同时我可以轻松地操作dictionary/JSON集合。</p><p>当然，答案是Python。当我介绍<a href="https://github.com/graphql-python/gql" target="_blank"> GQL模块</a>时，我将与您一起探索这个发现。我不会强制执行pep-8、异常处理等。这篇博客文章只是给你一个很好的介绍这种方法。</p><h2>要求</h2><p>我将在教程中探讨这一点。但是，如果您想直接测试我的项目，我们需要在运行时设置一些环境变量。可以跟着这个<a href="https://github.com/gabrielcerioni/harness_instanceStats_gql_to_csv/blob/main/README.md" target="_blank"> README.md </a>做参考！</p><h2>辅导的</h2><h3>第一步</h3><p>需要进口什么？对于本例，我导入了以下内容:</p><p><strong>导入</strong>OS<br/>T3】导入 csv <br/> <strong>导入</strong>日志<br/> <br/> <strong>从</strong> gql <strong>客户端导入</strong>gql<br/>从 gql.transport.requests <strong>导入</strong> RequestsHTTPTransport <br/></p><p>您可以通过运行以下命令来解决所有依赖关系:</p><p>python 3-m pip安装-r https://raw。githubusercontent。com/gabrielcerioni/harness _ instance stats _ gql _ to _ CSV/main/requirements。文本文件（textfile）</p><h3>第二步</h3><p>让我们定义一个简单的日志记录器和一个“常量”,我将从环境变量中获取:</p><p>伐木。基本配置(format = ' %(ASC时间)s-%(级别名)s-%(消息)s '，级别=日志记录.INFO) <br/> <br/> API _ KEY = OS。环境。get(' HARNESS _ graph QL _ API _ KEY)<br/>API _ ENDPOINT = OS。环境。get('线束_图形QL _端点')<br/> OUTPUT _ CSV _ NAME _ CONST = OS。环境。get(' HARNESS _ GQL _ CSV _ NAME ')</p><h3>第三步</h3><p>我不想把这段代码写得太长，所以我就开门见山了。让我们定义一个好的通用<strong>查询</strong>函数来处理GraphQL:</p><p>def generic _ graphql _ query(query):<br/>req _ headers = {<br/>' x-API-KEY ':API _ KEY<br/>}<br/><br/>_ transport = RequestsHTTPTransport(<br/>URL = API _ ENDPOINT，<br/> headers=req_headers，<br/> use_json=True，<br/> ) <br/> <em> <br/> #使用定义的传输创建一个graph QL客户端</em><br/>Client = Client(transport = _ transport，fetch_schema_from)</p><p>我们也可以做一些非常类似于运行<strong>突变</strong>的事情:</p><p>def generic _ graphql _ mutation(mutation _ query，params):<br/>req _ headers = {<br/>' x-API-KEY ':API _ KEY<br/>}<br/><br/>_ transport = RequestsHTTPTransport(<br/>URL = API _ ENDPOINT，<br/> headers=req_headers，<br/> use_json=True，<br/> ) <br/> <em> <br/> #使用定义的传输</em> <br/>客户端创建一个graph QL客户端</p><h2>真实用例</h2><p>让我们从客户那里探索两个真实的使用案例。</p><h3>用例1</h3><p><strong>客户陈述:</strong>我需要按服务和环境为所有部署的实例生成(按需)CSV报告。我还需要服务ID来确保我计算正确。</p><p><strong>结果项目(我还在增强这个):</strong><a href="https://github.com/gabrielcerioni/harness_instanceStats_gql_to_csv" target="_blank">GitHub-gabrielcerioni/harness _ instance stats _ gql _ to _ csv:</a>这是一个简单的Python，它将instanceStats GraphQL查询解析为CSV。</p><p>至此，我还需要两个函数:</p><ul role="list"><li>一个用于检索简单的instanceStats结果集；</li><li>另一个得到它并把所有东西都放在UTF-8 CSV上。</li></ul><p>差不多就是这样:</p><p><strong>def get _ all _ instances _ by _ Service _ by _ env</strong>():<br/>query = ' ' ' {<br/>实例统计(分组依据:[{实体聚合:服务}，{实体聚合:环境}]){ <br/>...在堆叠的数据上{ <br/>数据点{<br/>key {<br/>name<br/>id<br/>}<br/>values {<br/>key {<br/>name<br/>}<br/>value<br/>}<br/>}<br/>}<br/>}<br/>}<br/>} ' ' '<br/>generic _ query _ result = generic _ graph QL _ query(query)<br/><br/><strong>return</strong><br/>  result _ list中 Service _ item <strong>的<br/><br/><strong>:<br/>instances =[]<br/>Service _ Name = Service _ item[' key '][' Name ']<br/>Service _ ID = Service _ item[' key '][' ID ']<br/><br/>Instance _ environments = Instance _ environments dict writer(output _ file，fieldnames=clean_dict_list[0]. 按键()，)<br/> fc。写头()<br/> fc。writerows(clean _ dict _ list)<br/><br/><strong>return</strong>(clean _ dict _ list)<br/></strong></strong></p><p>然后，我们可以轻松地协调“主”入口点中的一切:</p><p>if _ _ name _ _ = = ' _ _ main _ _ ':<br/>logging . info("启动程序...")<br/> <br/> logging.info("检索您当前的instanceStats GraphQL查询结果集...")<br/>result _ from _ query = get _ all _ instances _ by _ service _ by _ env()<br/>logging . info(" Done！")<br/> <br/> logging.info("展开嵌套dict中的所有行-然后将其放在CSV上:{0} "。format(OUTPUT _ CSV _ NAME _ CONST))<br/>parsed _ result _ set = parse _ result _ to _ CSV(result _ from _ query)<br/>logging . info(" Done！在此输出列表内容:")<br/>print(parsed _ result _ set)<br/><br/>logging . info("程序已退出！祝你愉快！”)<br/></p><h3>用例2</h3><p><strong>客户陈述:</strong>我需要从我的帐户生成所有用户的输出。但是我有很多，这个会无限分页。请尽快帮助和处理此事！</p><p><strong>结果项目(我还在增强这个):</strong><a href="https://github.com/gabrielcerioni/harness_graphql_labs" target="_blank">GitHub-gabrielcerioni/Harness _ graph QL _ Labs:</a>Gabs CSE-Harness-graph QL Labs-Python。</p><p>我的GH项目有一个虚拟加载器，但是我不建议运行它！我们可以关注一个将查询所有用户的函数，但它也知道如何处理GraphQL偏移/分页:</p><p><strong>def get _ harness _ account _ users</strong>():<br/>offset = 0<br/>has _ more = True<br/>total _ user _ list =[]<br/><br/><strong>while</strong>has _ more:<br/>query = ' ' ' {<br/>users(限制:100 offset:' ' '+str(offset)+' ' '){<br/>pageInfo {<br/>total<br/>limit<br/>hasMore<br/>offset<br/>}<br/>nodes {<br/>name<br/>}<br/>}<br/>} ' ' '<br/><br/>generic _ query _ result = generic _ graph QL _ query(query)<br/>loop _ user _ list = generic _ query _ result[" users "][" nodes "]【T25</p><p>然后，我们可以有这个非常简单的入口点:</p><p>if _ _ name _ _ = = ' _ _ main _ _ ':<br/>logging . info("启动程序...")<br/> <br/> logging.info("从你的Harness账户获取所有用户")<br/>result _ from _ query = get _ Harness _ Account _ users()<br/>logging . info(" Done！您的帐户中有{0}个用户！"。format(len(result _ from _ query))<br/>print(" "<br/>logging . info("在您的STDOUT上打印用户列表")<br/><br/>print(result _ from _ query)<br/><br/>logging . info("程序已退出！")<br/> <br/></p><h2>结果</h2><p>下面是我们可以期待看到的，特别是对于用例1:</p><figure class="w-richtext-figure-type- "/><p>希望这对你们有帮助！我们只看了两个用例，但是还有很多可以帮助我们的。</p><p>一如既往，如果你有任何问题，给我发消息！我很乐意帮忙。</p><p>加布里埃尔</p></div></div>    
</body>
</html>