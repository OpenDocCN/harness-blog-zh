# Java 与本地代理的对比——以及它如何影响您的代码

> 原文：<https://www.harness.io/blog/java-vs-native-agents>

Java 和本地代理之间的区别以及它将如何影响您的代码和应用程序。

**在安装代理之前您应该知道什么，以及它如何影响您的代码**

当构建一个可扩展的服务器端应用程序时，我们花费了大量的时间来考虑如何在生产中监控、操作和更新我们的代码。一种新的工具已经发展到可以帮助 Java 和 Scala 开发人员做到这一点。它们中的许多都建立在外部代码在运行时与 JVM 集成的最强大的方式之一上——Java 代理。

‍
代理是操作系统本地或 Java 库(我们将在下面描述它们的区别), JVM 为它们提供了普通应用程序代码所不具备的功能。为了了解这些工具有多基础，让我们来看看我们使用的几个依赖于它们的工具:

*   **评测器**使用 Java 代理修改目标框架的代码，以注入收集性能指标的新代码。这包括独立或托管服务，如 NewRelic 或 YourKit
*   JRebel 通过构建一种在运行时不需要重启 JVM 就能提供类的平滑热交换的技术，将它带到了一个新的高度
*   **Play 框架**使用 Java 代理在运行时支持类的热交换
*   在 **Harness，**我们利用 JVM 提供给本地代理的低级功能来显示导致错误的实际源代码和变量值。

## 代理商能做什么？

正如我上面提到的，有两种代理——Java 和 native。虽然两者都以几乎相同的方式加载到 JVM 中(使用一个特殊的 JVM 启动参数)，但它们在构建方式和用途上几乎完全不同。

‍
让我们来看两个。

### **Java 代理**

Java 代理是。jar 文件定义了一个特殊的 premain 静态函数，这个函数将在应用程序的 main 函数被调用之前被 JVM 调用。神奇的部分来自于[插装](http://docs.oracle.com/javase/7/docs/api/java/lang/instrument/Instrumentation.html)对象，它由主机 JVM 作为参数传递给这个函数。通过抓住这个对象，代理的代码(否则表现为根类加载器加载的任何 Java 代码)可以做一些真正强大的事情。

###### public static void premain(字符串代理参数，仪器仪表){

###### myInst = inst//获取对 inst 对象的引用供以后使用

###### }

#### 他们做什么

给予代理的最强大的能力是在运行时类中动态重写目标类的方法内容的能力(字段结构是不可变的)。这个过程称为字节码插装，它使代理能够在代码运行时重写方法的内容。
一些例子包括添加对特定方法的调用以分析性能(例如 end time–start time)或记录参数值(例如传递给 servlet 的 URL)。另一个例子是在不重启 JVM 的情况下重新加载一个新版本的类，就像 JRebel 所做的那样。

#### 这是怎么做到的

对于代理来说，修改代码或加载的类实际上触发了 JVM 重新加载类的过程，其中类的字节码被替换为新版本。这要求代理能够向 JVM 提供可验证的新字节码(即符合 JVM 规范)。不幸的是，在运行时生成正确的字节码并不简单——有很多需求和边缘情况。为此，代理通常使用库来读写字节码。该库使他们能够将现有类的字节码加载到一个类似 DOM 的结构中，通过添加诸如分析调用之类的东西来修改它，然后将 DOM 保存回原始字节码。

‍
[ASM](http://asm.ow2.org/) 是一个流行的库，它提供了一个通用的 Java 字节码操作和分析框架。这是最流行的字节码操作库之一，可以用来修改现有的类或者直接以二进制形式动态生成类。它非常流行，以至于 Sun 的一些内部代码实际上使用它来解析 Java 中的字节码。

### **本地代理**

本土特工是完全不同的野兽。如果您认为 Java 代理可以让您做一些很酷的事情，请抓紧时间，因为本地代理在完全不同的层面上运行。本机代理不是用 Java 编写的，而大部分是用 C++编写的，不受普通 Java 代码运行的规则和限制。不仅如此，它们还提供了一组非常强大的功能，称为 JVM 工具接口(JVMTI)。

#### 他们做什么

jvmti.h 公开的这组 API 使 JVM 动态加载的 C++库能够获得对 JVM 实时工作的高度可见性。这跨越了广泛的领域，包括 GC、锁定、代码操作、同步、线程管理、编译调试等等。JVM TI 被设计成使 JVM 尽可能透明，同时仍然保持设计灵活性，允许 JVM 供应商提供不同的底层实现。这组 API 非常广泛，包含数百个回调和 JVM 函数。您可以使用这些工具来做 Java 代理不能做的非常强大的事情，比如编写自己的调试器，或者构建低级的实时错误分析工具。
‍

由 Harness Service Reliability Management(SRM)执行的绝大多数监控都是在本机代码中进行的，级别低于大多数其他代理。这意味着在大多数情况下，SRM 甚至对字节码级别的其他代理都是不可见的。
‍

由于 SRM 在服务器上占用的 CPU、内存和网络空间很少，因此其他代理的性能不会受到其监视活动的影响。如果您想进一步了解 SRM 如何与您现有的工具和代理配合工作。
‍

回到 JVMTI——这里有一个 JVMTI 提供给代理的回调，这样每当 JVM 内部的任何地方抛出异常时，代理都会接收到抛出异常的字节码位置、所有者线程、异常对象以及是否/在哪里会被捕获。确实是强大的东西。

###### void JNI 调用异常回调(jvmtiEnv * jvmti，JNIEnv *jni，jthread thread，

###### jmethodID 方法，jlocation 位置，jobject 异常，

###### jmethodID catch_method，jlocation catch_location)

#### 不利方面

如果我描述的一切听起来绝对桃色，你可以问，为什么不是所有的代理都写成原生代理？有几个需要注意的原因，所以在这里列出来(排名不分先后):

##### # 1–复杂性

首先是 JVMTI API 非常复杂，有许多小的移动轮子。在大多数情况下，如果您编写的代理不需要非常低级的功能，那么 Java 代理 API 就很好，它更简单，可以帮助您更快地完成工作。

##### # 2–便携性

由于本机代理是作为本机库编写和编译的(。所以/。它们需要在您想要支持的任意数量的操作系统上进行编译和测试。如果你看看 Windows、OSX 和不同风格的 Linux，这可以转化为大量的工作。与 Java 代理相比，Java 代理是由 JVM 作为 Java 代码执行的，因此从设计上来说具有固有的可移植性。

##### # 3–字节码操作

由于本机代理通常是用 C++编写的，这意味着它们不能直接使用可靠的 Java 字节码操作库(如 ASM ),而必须使用 JNI 返回到 JVM 中，这就减少了一些乐趣。

##### # 4–稳定性

JVM 提供了强有力的保护措施，防止代码做出会导致愤怒的操作系统终止进程的事情。正常情况下会导致 SIGSEV 和进程崩溃的内存访问冲突，会给我们一个漂亮的 NullPointerException。由于本地代理运行在 JVM 的同一层(与 Java 代理相比，Java 代理的代码由 JVM 执行)，因此它们所犯的任何错误都有可能终止 JVM。

## 最后的想法

希望这有助于突出两者之间的一些差异。了解什么是代理以及它们是如何构建的是有好处的，因为即使您最终没有编写一个代理，您今天也可能会依赖其中的一个或多个来驱动您的应用程序。

‍