<html>
<head>
<title>Binary to your Browser - Hello WebAssembly aka WASM | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>浏览器的二进制代码- Hello WebAssembly又名WASM | Harness</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/binary-to-your-browser-hello-webassembly-aka-wasm#0001-01-01">https://www.harness.io/blog/binary-to-your-browser-hello-webassembly-aka-wasm#0001-01-01</a></blockquote><div><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>玩笑归玩笑，上一次我不得不在企业环境中处理浏览器是决定什么样的Internet Explorer安全设置适合我们的应用程序，这毫无乐趣可言。在我与IE竞争的几年前，我非常幸运地在IBM获得了一个轮流在<a href="https://en.wikipedia.org/wiki/Cooperative_education">合作的</a>职位，这个职位持续了我大学的大部分时间，直到2000年代中期。在第二次轮流期间，我在做<a href="https://www.ibm.com/cloud/websphere-application-platform/">WebSphere Application Server</a>的管理控制台(你知道你登录的那个东西)。我们正在重写大约15，000个左右的Struts动作<a href="https://struts.apache.org/core-developers/action-configuration.html">来表示管理控制台，因为WebSphere是JAVA转化为HTML的地方。我们一直在努力解决web问题，在浏览器之间测试新的控制台项目。当我为一个新组件</a><a href="https://javaee.github.io/tutorial/jsf-custom005.html">的几个问题争论不休时，一位团队领导向我提到了我写的“浏览器是我们最好的朋友和最坏的敌人”。又过了几分钟，“Ravi想象一下，如果我们能把二进制文件流式传输到浏览器就好了”。这将是令人惊讶的，因为我用JAVA完成的事情比我在浏览器中使用像JSF这样的MVC技术要多得多。十年过去了，变化不断，我偶然发现了InfoQ的一篇文章，总结了Richard Feldman关于网络未来的演讲。理查德提到WebAssembly是他观察网络未来的一个视角。我以为Richard提到的是一个</a><a href="https://webpack.js.org/"> WebPack </a>，并决定进一步调查WebAssembly。在经历了几件抵押品之后，我的2000年中期团队领导的梦想实现了！</p><h2>浏览器的二进制(ish)</h2><p>你通往世界的门户，你的网络浏览器，只懂几种语言；<a href="https://en.wikipedia.org/wiki/HTML"> HTML </a>，<a href="https://en.wikipedia.org/wiki/Cascading_Style_Sheets"> CSS </a>，以及<a href="https://en.wikipedia.org/wiki/JavaScript"> JS </a>的风味。您的网络浏览器将解释这些语言，并在渲染引擎(例如<a href="https://en.wikipedia.org/wiki/WebKit"> Webkit </a> / <a href="https://en.wikipedia.org/wiki/Blink_(browser_engine)"> Blink </a>)的帮助下渲染您所看到的内容。在某个时候，<a href="https://en.wikipedia.org/wiki/Binary_code">二进制文件</a>被创建并在你的计算机上执行，作为你的机器的低级指令，也就是“最接近事实的指令”。之所以在渲染上存在web浏览器差异，是因为渲染引擎都不一样。容器技术<a href="https://harness.io/blog/what-is-kubernetes-container/">上升的一个原因是容器允许的可移植性和一致性。有了容器，您不必担心运行映像内部的不同解释，因为您正在运送您需要的一切。尽管如此，如果你的应用程序有一个基于浏览器的组件，比如一个</a><a href="https://en.wikipedia.org/wiki/User_interface"> UI </a>，不管你的后端是否被容器化，浏览器仍然是一个不确定的领域。随着我们的应用程序变得越来越复杂，从有不止一个web浏览器的那一天起，我们一直在努力解决的问题似乎变得越来越复杂。另一个我自从大学上了<a href="https://www.udacity.com/course/compilers-theory-and-practice--ud168">编译器课</a>(现在是免费的，<a href="https://www.cc.gatech.edu/"> Go Jackets </a>)之后就没接触过的技术！)是<a href="https://en.wikipedia.org/wiki/LLVM"> LLVM </a>。如果你对LLVM不熟悉，很多<a href="https://en.wikipedia.org/wiki/Compiler">编译器</a>都是基于LLVM的。WebAssembly支持LLVM语言，因此可以放入WebAssembly的语言列表<a href="https://github.com/appcypher/awesome-wasm-langs">非常丰富，包括</a><a href="https://en.wikipedia.org/wiki/Go_(programming_language)"> Go </a>、<a href="https://en.wikipedia.org/wiki/Rust_(programming_language)"> Rust </a>和<a href="https://en.wikipedia.org/wiki/OCaml"> OCaml </a>。在<a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">客户机-服务器</a>模型中，大量的语言通常是为服务器保留的，处理过程再次转向你的浏览器，例如客户机。</p><h2>客户端-无服务器？</h2><p>WebAssembly可能代表处理发生的根本转变。客户机(也称为浏览器)成为通常驻留在服务器上的语言的执行点。那么这是通过移除更多远程呼叫的新的无服务器吗？当然，更多的处理可以转移到浏览器。WebAssembly如此新颖(2017)仍在不断发展。当我们开始探索向web浏览器发送低级命令时，肯定会有很多限制和顾虑。我们都知道Adobe Flash和T2 JAVA小程序在其生命周期中存在的安全隐患；Chrome仍然让我知道<a href="https://www.chromium.org/flash-roadmap#TOC-Flash-Disabled-by-Default-Target:-Chrome-76---July-2019-"> Flash支持将于2020年</a>结束。运输预编译项目并不新鲜。在JAVA服务器页面的好日子里，你可以告诉应用服务器预编译JSP。甚至更现代的语言如<a href="https://nodejs.org/en/"> NodeJS </a>提前编译JavaScript以产生<a href="https://en.wikipedia.org/wiki/List_of_server-side_JavaScript_implementations">服务器端JavaScript </a>。最好的学习方法是尝试一些网络组件。</p><h2>给我打包一个web程序集</h2><p>WebAssembly是一个新兴的标准，由于语言列表很长[感谢LLVM]，底层项目/语言有很多变化。查看WebAssembly运行情况的快速方法是浏览WebAssembly 项目的教程。好消息是先决条件步骤可以在Linux <a href="https://docs.staging-devharnessio.kinsta.cloud/article/h9tkwmkrm7-delegate-installation#where_do_i_install_the_delegate"> Harness Delegate </a>上运行。本教程的核心是<a href="https://github.com/emscripten-core/emsdk"> Emscripten SDK </a>的安装，它可以通过代理配置文件轻松地安装在线束代理上。由于我有一个基于Ubuntu 的代理，我需要在我的亚马逊Ubuntu AMI 上安装一些工具。<em>设置</em> &gt; <em>驾驭代理</em> &gt; <em>管理代理配置文件</em> &gt; <em>添加代理配置文件</em></p><figure class="w-richtext-figure-type-image w-richtext-align-center"/><p>在Harness Delegate配置文件中设置bootstrap命令是确保以模板化和一致的格式应用基础设施的一种好方法。一旦完成，你就可以启动一个终端并创建一个<a href="https://en.wikipedia.org/wiki/C_(programming_language)">“复杂的”C应用程序</a>，它非常接近WebAssembly教程。我在这里直接登录了我的代理人。</p><figure class="w-richtext-figure-type-image w-richtext-align-center"/><p>一旦你有了你的C应用程序，你就可以使用EMCC来构建可分发的然后运行。有一个来自<a href="https://content.pivotal.io/youtube-springone-platform-2019/webassembly-revolution-not-evolution"> Spring One </a>的优秀视频展示了<a href="https://wasdk.github.io/WasmFiddle/"> WASM提琴</a>这是一个基于网络的编辑器，可以快速创建<a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Text_format_to_wasm"> WAT/WASM </a>包装。WebAssmbley肯定会发展起来，随着标准变得更加成熟，实践和模式肯定会改变。有了所有的活动部件，Harness就有了你的后盾。</p><h2>柔性线束平台</h2><p>对于一个还没有过时的编译过程来说，用一个复杂的脚本驱动的管道来生成WebAssmbley WAT包似乎相当沉重。Harness平台的美妙之处在于，您可以让一个Harness代表以代表身份运行<a href="https://github.com/emscripten-core/emsdk"> Emscripten SDK安装</a>，同时享受Harness提供的所有好处。随着WebAssembly标准和生态系统的不断成熟，对包含创建(别忘了测试)WebAssembly的<a href="https://docs.staging-devharnessio.kinsta.cloud/article/m220i1tnia-workflow-configuration">利用工作流</a>的更改可以很快被纳入考虑范围。2014年使用Kubernetes成像与今天相比，我们已经走了多远。期待WebAssembly如何在未来塑造浏览器功能的创造性方法。如果你有任何有创意的用例/挖掘更多，请随意在<a href="https://community.harness.io">线束社区</a>上发帖。干杯！拉维</p></div></div>    
</body>
</html>