<html>
<head>
<title>Micro-Frontend Architecture in the Harness Software Delivery Platform | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>线束软件交付平台|线束中的微前端架构</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/micro-frontends-architecture#0001-01-01">https://www.harness.io/blog/micro-frontends-architecture#0001-01-01</a></blockquote><div><p>说到微前端，有许多好处和挑战。了解我们如何解决依赖性、逻辑、组件等的独立部署和共享问题！</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>简单来说，微前端之于前端，如同微服务之于后端。这是通过将一个整体的 web 应用程序转换成分布式的、小型的独立应用程序来实现的。在某些情况下，这些单独的应用程序可以作为独立的应用程序运行，可以独立开发和部署。此外，当与其他应用程序结合时，它们可以作为单个应用程序运行。</p><figure class="w-richtext-figure-type- "/><p>在 Harness，我们希望采用微前端架构来拆分我们的单片 UI 应用程序，以实现以下目标:</p><ul role="list"><li><strong>性能:</strong>并非应用的所有部分都被所有用户使用。按需加载复杂应用程序某些部分的能力有利于缩短初始应用程序加载时间。</li><li><strong>独立部署:</strong>线束是一个复杂的应用程序。因此，它由各种模块组成。如果采用微前端架构，则可以将各个模块划分为不同的子应用程序，并且可以独立部署它们，以取代当前一次性部署每个模块的方法。</li><li><strong>开发速度:</strong>可以显著提高，因为模块可以独立运行。这消除了运行整个应用程序来在一个模块中修复/实现一个特性的开销。</li><li>开发人员的认知负荷:我们可以简化它来理解完整的应用程序，即使他们可能在一个模块上工作。</li></ul><h2>微前端的挑战</h2><p>当我们开始寻找市场上可用于实现微前端的不同解决方案时，我们要求应涵盖以下几点:</p><ul role="list"><li><strong>依赖共享:</strong>我们想要一个能够轻松处理依赖共享的解决方案。依赖于应用程序的资源，如公共库、React、Lodash 和 React Router。这些是将被子应用程序和父应用程序使用的一些。当孩子被动态加载时，所选择的架构不应该重新加载公共资源。</li><li><strong>数据共享:</strong>当数据必须在父节点和子节点之间共享时，首选解决方案应该能够以最有效的方式处理双向数据传输。</li><li>资源共享:需要在子应用程序和父应用程序之间共享一些通用的 UI 组件。这应该在所有模块中保持一致，并且当父应用程序中已经有相同的模块时，不应该在子应用程序中重新加载它们。</li><li><strong>独立部署:</strong>我们需要一种解决方案，它可以帮助我们独立部署子模块，并在加载父应用程序时加载最新的可用子模块，而无需重新部署父应用程序。</li><li><strong>独立开发:</strong>首选解决方案应该帮助开发者在本地独立运行子应用。</li></ul><h2>微前端解决方案类型</h2><p>上述挑战可以大致分为两类:</p><ol role="list"><li>子应用程序如何插入父应用程序。</li><li>数据/资源将如何共享给子应用程序。</li></ol><p>因此，我们想出了以下解决方案来解决这两个问题。</p><h3>插入子应用程序</h3><ul role="list"><li><strong> Webpack 模块联盟</strong>:我们使用 Webpack 捆绑工具在特定路径上运行子应用程序，父应用程序从该路径动态加载子应用程序。</li><li><strong>导入模块为 App </strong>:子应用的加载方式与第三方库相同。在此之前，子应用程序也将作为库发布。</li><li>Iframes :我们加载子应用程序，它使用 Iframes 在一个单独的位置运行。</li></ul><h3>子应用程序的数据/资源共享</h3><ul role="list"><li><strong>托管包装器</strong>:我们使用上面的任何一种方法加载子应用程序。然而，当加载到父节点中时，它将被包装在一个包装器中，该包装器负责将数据从父节点传输到子节点，反之亦然。</li></ul><h3>Webpack 模块联盟</h3><p>这是最流行的方法，其中名为 webpack 的捆绑工具有助于将子应用程序作为特定路径或端口的服务公开。当父应用程序想要动态加载子应用程序时，它被预先配置为点击子路径。</p><p>在下图中，Harness 应用程序是 shell 应用程序或父应用程序，以及 CI、CV 等。是 Harness 应用程序中的各种模块。</p><figure class="w-richtext-figure-type- "/><p><strong>优点:</strong></p><ul role="list"><li>处理模块的绑定/加载和开箱即用的依赖性共享。</li><li>完整的应用程序只在运行时合并成一个。</li></ul><p><strong>缺点:</strong></p><ul role="list"><li>没有解决数据共享和资源共享。</li><li>锁定到 webpack 作为构建工具。</li></ul><h3>将模块作为应用程序导入:</h3><p>在这种方法中，我们将子应用程序捆绑为 npm 包并发布该包。稍后，我们像下载任何其他 npm 包一样下载子包，并开始像在父应用程序中使用任何其他库一样使用它。</p><figure class="w-richtext-figure-type- "/><p><strong>优点:</strong></p><ul role="list"><li>只要子级发布其类型，静态导入就会导致类型安全。</li><li>允许独立开发模块，但有一定的限制。</li><li>一个单独的包意味着在加载 micro UI 时没有网络延迟。</li></ul><p><strong>缺点:</strong></p><ul role="list"><li>延迟加载需要额外的努力来实现</li><li>构建父应用程序(NGUI)的成本很高，因为它也捆绑了子应用程序。</li><li>子应用程序不能从父应用程序导入代码，这意味着资源共享很困难。</li><li>没有独立的子部署。</li></ul><h3>托管包装:</h3><p>在这种方法中，我们在 HTML 元素中运行子应用程序，例如父应用程序代码的“div”。获取子代码的方法可以是上面讨论的两种方法中的任何一种。这种方法背后的思想是编写一个包装器，可以将子应用程序包装在父应用程序中，父应用程序还负责将数据向下传递给子应用程序，反之亦然。编写这个包装器是为了让它能够理解父数据格式和子数据格式，因为这两个应用程序都提前发布了数据类型。</p><figure class="w-richtext-figure-type- "/><p><strong>优点:</strong></p><ul role="list"><li>子应用程序不限于任何单个呈现或构建框架。</li><li>子进程可以通过依赖注入使用父进程的资源/组件。</li><li>父节点控制子节点可以使用哪些共享数据。</li></ul><p><strong>缺点:</strong></p><ul role="list"><li>这只是解决了数据和资源共享。它仍然必须与前面两种捆绑和依赖共享方法中的一种结合起来。</li></ul><h3>Iframes:</h3><p>这是许多组织实现微前端最常用的方法之一。在这种方法中，子应用程序作为独立的应用程序在指定的预定义路径上运行。当父应用程序需要加载这个子应用程序时，它只需使用预定义的路径在 iframe 中加载子应用程序。这种方法的主要缺点是它有许多安全问题。此外，我们发现，与上述方法相比，即使共享资源也不是无缝的。</p><figure class="w-richtext-figure-type- "/><p><strong>优点:</strong></p><ul role="list"><li>简单的解决方案最容易实现。</li><li>子应用程序的完全隔离。</li></ul><p><strong>缺点:</strong></p><ul role="list"><li>潜在的安全问题(可能使用正确的 CSP 配置解决)。</li><li>依赖共享非常困难。</li><li>数据共享的成本非常高(需要序列化)。</li></ul><h2>我们的微前端方法</h2><p>我们使用 Webpack 模块联合，一个单独的路径/端口，将子模块作为一个单独的服务运行。</p><p>当我们在父应用程序中动态加载子应用程序时，我们在包装器中运行子应用程序。这负责在父应用程序和子应用程序之间来回共享数据/资源。</p><p>为了理解子节点的父数据格式，父应用程序发布一个包，该包包含它想要与子节点共享的资源/数据的数据类型。</p><p>只要运行在子应用程序中的包装器有能力将父数据转换为子可理解的数据，那么子就可以自由地运行在其选择的任何框架中，而不一定要运行父框架(比如 React)。</p><figure class="w-richtext-figure-type- "/><p><strong>T9</strong></p><p><strong>优点:</strong></p><ul role="list"><li>数据和资源共享很容易。</li><li>懒加载。</li><li>父包很小。</li><li>双向数据共享。</li><li>子应用程序的部署和开发是独立的。</li><li>不依赖于任何单一的第三方库。</li><li>资源共享的父控件。</li><li>对 NGUI 的最小改动。</li><li>将来可以自由试验，因为习惯于驾驭。</li><li>有助于开源，因为它不依赖于任何第三方库。</li></ul><p><strong>缺点:</strong></p><h2>微前端实现步骤</h2><ol role="list"><li>从父应用程序中将类型/接口作为包发布。</li><li>Parent 公开关于如何在父级中呈现子级的接口。</li><li>将子进程作为单独的应用程序/服务运行。</li><li>延迟加载子模块。</li><li>在运行时将公共组件/上下文数据从父应用程序传递到子应用程序。</li></ol><p>下面显示了我们方法中的步骤。</p><figure class="w-richtext-figure-type- "/><h3>数据类型共享</h3><figure class="w-richtext-figure-type- "/><h3>数据流</h3><figure class="w-richtext-figure-type- "/><h2>结论</h2><p>通过使用我们的微前端解决方案，我们将子应用程序动态加载到父应用程序内部的包装器中。这就像一个代理在子应用程序和父应用程序之间发送和接收数据。我们能够从父应用程序中重用子应用程序中的公共组件，而无需重新加载它们。这种方法还帮助我们在需要时单独部署子应用程序，而不依赖于父应用程序。</p><p>这也有助于开发人员在本地工作时独立运行子应用程序，而无需运行父应用程序。由于我们预先发布了父应用程序类型，使用子应用程序的开发人员了解数据的结构。父应用程序使用它，并将它传递给子应用程序，这对开发人员使用子应用程序有很大的帮助。</p><p>看来你喜欢深潜！我们为你准备了更多精彩的内容。请随意阅读关于<a href="https://harness.io/blog/builder-factory-pattern-testing/" target="_blank">构建器工厂模式</a>或<a href="https://harness.io/blog/externalizing-strings-in-react-1/" target="_blank">在 React </a>中测试和外部化字符串的文章。</p><p><em>本文是与 Swaraj Cheguri 和 Abhinav Rastogi 合作撰写的。</em></p></div></div>    
</body>
</html>