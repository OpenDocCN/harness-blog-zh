<html>
<head>
<title>What is a Kubernetes Container? | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>什么是Kubernetes容器？装具</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/what-is-kubernetes-container#0001-01-01">https://www.harness.io/blog/what-is-kubernetes-container#0001-01-01</a></blockquote><div><p>和我们一起踏上六个部分的旅程，让你做好准备，成为库伯内特斯新领地的一把尖刀。从最基本的到未来，让我们把事情做好。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>开始我们的六部分系列的第一部分，我们在Harness将帮助你成为Kubernetes世界的一把锋利的刀。随着越来越多的组织经历容器革命，让我们从整体上看一下生态系统和需要克服的挑战。许多组织正在踏上容器革命的征途；一场应用和应用基础设施容器化的革命。如果你今天就开始你的旅程，当你向某人询问容器技术时，他们说的第一句话通常是Docker或与Docker相关的东西。尽管Docker并不是2008年第一个对名为<a href="https://en.wikipedia.org/wiki/LXC"> Linux容器</a>又名LXC的标准进行解释的人，尽管他们肯定是最著名的。</p><h2>咚咚，是Docker！</h2><p>几年前，我第一次听说Docker时，我正在Red Hat工作。具有讽刺意味的是，当时我正穿着Docker的卡其裤，不明白为什么有人在谈论我在Kohl's买的裤子。当我的同事开始解释他不是在谈论裤子时，我的脑海里迅速回想起JAVA容器，如<a href="https://tomcat.apache.org/tomcat-9.0-doc/api/org/apache/catalina/startup/Catalina.html">Catalina</a>(Tomcat的Servlet容器)。尽管在对话和介绍Docker的过程中，让我印象深刻的是在各种环境中保持不变的能力和非常好的可移植性。想象一下，一个超负荷的应用程序发行版拥有您运行所需的一切。作为<a href="https://en.wikipedia.org/wiki/Java_Platform,_Enterprise_Edition"> JEE </a>的开发者，我将<a href="https://spring.io/projects/spring-boot"> Spring Boot </a>的口头禅类比为“只管跑”。Docker的历史相对较新，由<a href="https://containerjournal.com/2017/03/23/docker-4-milestones-docker-history/"> dotCloud在2013年</a>开源，Docker生态系统继续蓬勃发展，包含使容器格式健壮和可伸缩所需的工具。</p><h2>容器，图像，天啊！</h2><p>随着我们在计算世界中从大型机迁移到x86，然后迁移到虚拟机，现在革命已经集中在强大的容器上[有些人可能会认为无服务器是下一个]。一些行话，用Docker术语来说,<a href="https://docs.docker.com/engine/reference/commandline/image/"> image </a>是变成运行容器或者更多时候不是运行容器的东西。从咒语开始，把容器想象成应用程序监狱。应用程序只能拥有由映像清单/规范定义的资源。就像您的汽油动力汽车需要火花、空气、燃料和压缩才能运行一样，您的应用程序需要计算、内存、存储和网络才能发挥价值。容器规范有助于定义所有这些必需的组件。</p><h2>为什么这么大张旗鼓？</h2><p>容器最大的吸引力在于一致性和可移植性。在软件世界中，由于抽象，我们的目标是<a href="https://en.wikipedia.org/wiki/Write_once,_run_anywhere">写一次，在任何地方运行</a>【WORA】。JAVA是这个跨平台目标的事实上的标准。虽然编写应用程序只是应用程序运行所需的一部分。最典型的<a href="https://en.wikipedia.org/wiki/Bootstrapping#Software_development">引导问题</a>又名先运行什么；在较低的级别，您的应用程序需要系统库来运行。Docker/containers帮助打包这些系统库。我当然可以看到好处，如果您能够准确地打包您需要运行的内容、系统库等，您就可以准确地获得您需要的内容，例如正确的规模。这样，你可以开始增加密度。按照设计，容器是不可变的，这意味着它们不能改变。由于容器是一个运行中的映像，如果您需要进行更改，您需要重新创建映像并构建新的容器。如果你在做改变，你就是在做新的改变；不再需要热修补，这当然让变更控制人员很高兴，尽管有可能将SSH整合到一个运行容器中。尽管对于热补丁来说这不是一个好主意，但是容器的另一个特点是它们是短暂的，也就是说它们本质上是短暂的或可传递的。所以，即使你做了一个补丁，容器也是死的，所以你的改变不会只存在于那个容器中。</p><h2>我现在需要一个容器！</h2><p>由于开源的大量部件可供我们使用，Docker图像的可用性一直在爆炸式增长，这要感谢像<a href="https://hub.docker.com/"> Docker Hub </a>这样的公共图库。你需要一个<a href="https://www.mongodb.com/"> MongoDB </a>，可以快速从100张甚至1000张包含MongoDB的图片中提取。不像应用程序依赖，例如，你的JAVA应用程序需要与你从<a href="https://search.maven.org/"> Maven Central </a>获得的MongoDB对话的数据库驱动程序<a href="https://mongodb.github.io/mongo-java-driver/"> JDBC，你可以从Docker Hub获得MongoDB本身的工作实例。开始就像下载一个Docker引擎运行时一样简单。如果你在Mac上，最简单的方法就是安装</a><a href="https://docs.docker.com/docker-for-mac/install/"> Docker for Mac Desktop </a>。在你安装并启动服务后，你可以进入终端并输入“docker ”,奇迹就开始了。</p><h2>让我们开始魔法吧！</h2><p>使用Docker命令很容易。目前，两个基础是拉和运行。和那两个人在一起你很危险。准备好运行您的第一个容器了吗？用<a href="https://docs.docker.com/engine/reference/commandline/pull/"> Docker Pull </a>下拉<a href="https://www.nginx.com/"> nginx </a> (web服务器)然后就可以立即运行那个了。Docker Mac客户端预先配置为指向Docker Hub作为默认注册表。通过运行“<em> docker pull nginx </em>”，您将在Docker Hub上获得nginx的最新发布版本。快到了！接下来，准备运行新创建的nginx映像。可以利用<a href="https://docs.docker.com/engine/reference/run/"> Docker运行</a>命令。尽管我们将添加一些参数，这样我们就可以用-p标志公开和绑定默认的nginx端口80，并用- name属性命名容器。docker run-name your-first-nginx-p 80:80 nginx。一旦你运行了它，你就可以进入nginx启动页面，只需进入你的浏览器并输入localhost[也就是你的IP]。要停止正在运行的容器可以只运行<a href="https://docs.docker.com/engine/reference/commandline/stop/">停止</a>命令。最简单的方法是找到容器ID，并将ID传递给stop命令。用“<em> docker ps -a </em>”运行<a href="https://docs.docker.com/engine/reference/commandline/ps/"> list container </a>命令，复制“<em> your-first-nginx </em>的容器ID。你现在要做的就是运行“<em>docker stop your _ container _ ID”。</em></p><h2>有奖游戏-制作和分享一些东西</h2><p>制作你自己的Docker应用程序的主要机制之一是<a href="https://docs.docker.com/compose/"> Docker Compose </a>。自己做也没那么难。一个简单的Docker作曲，你就上路了。您需要定义一些关于如何访问容器的规范，并为您的应用程序定义资源限制。制作您自己的映像的主要原因可能是修改将在容器内运行的应用程序基础结构上的配置。这篇关于<a href="https://dev.to/domysee/setting-up-a-reverse-proxy-with-nginx-and-docker-compose-29jg"> dev.to的优秀且非常详细的文章介绍了如何将nginx </a>配置成一个<a href="https://en.wikipedia.org/wiki/Reverse_proxy">反向代理</a>，并将所有这些配置更改打包成一个新的映像。一旦你做了某样东西，轻轻一推就可能与世界分享。Docker Push 需要一个Docker注册表来发布。例如，如果你在Nexus中没有私有的，那么公共的Docker Hub one就很棒。</p><h2>为什么我的所有工作负载都不在一个容器中？</h2><p>回到容器是短暂的这一点，某些工作负载不适合这种特别是有状态的工作负载。需要状态或具有特定持久性要求的项可能没有被构建到容器中。由于容器的来去速度快于集群的再平衡速度，应用集群机制可能会不堪重负。甚至我最喜欢的语言JAVA也在经历一场进化，变得更容易容器化。当容器化一个运行时或语言时，需要考虑很多内部因素，例如语言如何考虑资源限制。幸运的是，四大需求支柱(请记住，应用程序需要计算、内存、存储和网络才能有价值)的生态系统已经有了很多改进，并且允许更多的应用程序基础架构实现容器化。看看<a href="https://landscape.cncf.io/">云原生计算基金会的</a>格局是如何逐年变化的，在这个过程中，有如此多的项目可以帮助我们。</p><h2>如果我们有不止一个这样的容器呢？</h2><p>关于应该在一个容器中运行的并发进程的数量有很多争论。因为容器很容易旋转，它们逃避自己成为一个进程的家，就像魔术一样，你正朝着你眼前的微服务前进。但是应用程序肯定不会自己运行，并且有扩展需求，因此需要一个平台来协调所有这些运行的容器。音乐响起，欢迎Kubernetes！既然我们现在已经有足够多的关于容器的危险了，接下来的五个部分将集中在800磅的容器编排大猩猩Kubernetes上。</p><h2>马具是你的朋友</h2><p>我们很高兴能在您的集装箱/Kubernetes之旅中与您合作。理解技术只是拼图的一部分，因为让您的应用程序重新平台化或迁移可能需要时间，尤其是在您的管道过程中需要跨越的所有障碍。有了你新的或者不是新的Docker Hub证书，准备好开始Kubernetes之旅吧！</p></div></div>    
</body>
</html>