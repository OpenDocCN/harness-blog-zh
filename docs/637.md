# 标准 Java 日志记录死了吗？装具

> 原文：<https://www.harness.io/blog/is-standard-java-logging-dead>

在这篇文章中，我们将从另一个角度探索结果数据集，对数据集进行更多的阐释，并将重点放在标准 java.util.logging 级别的使用上

大写的日志级别会导致高水平的压力。如果我们用“哎呀”代替“错误”会怎么样？更严重的是，我们最近对 GitHub 的顶级 Java 项目及其使用的日志记录语句进行了大规模的数据处理，揭示了普通 Java 项目的日志级别分解。

在这篇文章中，我们将从另一个角度探索产生的数据集，更好地了解数据集，并将重点放在标准 java.util.logging 级别的使用上，而不是更流行的框架，如 Log4j (+ Log4j 2)和 Logback。

进来吧。

## 见见玩家

日志实用程序可以大致分为两类:日志外观和日志引擎。

至于日志外观，您几乎有两种选择:slf4j 和 Apache 的 commons-logging。实际上，5 个 Java 项目中有 4 个选择使用 slf4j。基于 Github 上 2016 年顶级 Java 库的数据。使用日志门面的动机非常明确和直接，是您选择的日志引擎之上的抽象——允许您在不改变实际代码和日志语句的情况下替换它。

至于日志引擎，最流行的选择是 Logback，它是 Log4j 的一个进化版本，Log4j 本身，以及它的新版本，因为它的开发被传递给了 Apache Software Foundation，Log4j2。紧随其后的是 Java 的默认日志引擎 java.util.logging，又名 JUL。

## 指指点点，骂人

从表面上看，每个日志框架的日志级别的名称略有不同。

在 slf4j 与 java.util.logging 一起使用的极少数情况下，会发生以下映射:

最精细->跟踪

更精细->调试

精细->调试

信息->信息

警告->警告

严重->错误

这里要注意的另一件事是，Logback 和 java.util.logging 没有致命的对等物。在这些错误名称后面，是简单的整数值，有助于控制正在运行的应用程序中的日志记录级别。每个库还包含 OFF 和 ALL 的值，这些值基本上将记录器级别设置为实际传输所有内容，或者什么都不传输。例如，将日志记录级别设置为 WARN，将只记录 WARN 及以上的消息——这实际上是生产环境的默认设置。

## 级别命名分解在实践中看起来如何？

对于数据危机，我们将重点放在两种方法中至少有 100 条日志记录语句的顶级 Java 项目上。检查项目的数据集，我们发现只有 4.4%的项目专门使用 java.util.logging 命名方案。

为了查看一般的 java.util.logging 项目，我们对其进行了过滤，只包括那些至少有 100 条语句的项目，这些语句来自与非 JUL 命名方案(警告和信息)不重叠的级别。

也就是说，看起来在这两种情况下，日志记录语句的⅔在生产中被禁用，因为在这种情况下只有 WARN 和 above 被激活。

有趣的事实:作为一个额外的数据点，我们也看了所有/关闭水平。结果只有 8.6%的项目使用了这两种方法。

## 我们是如何获得数据的？

这项研究的起点是 GitHub 档案，以及它在 Google BigQuery 上的数据集。我们希望专注于合格的 Java 项目，排除 android、样本项目和简单的测试人员。一个自然的选择是查看最受欢迎的项目，包括 40 万个顶级存储库的数据库。

我们最终得到了 15，797 个包含 Java 源文件的存储库，占初始数据集的 4%。但并没有就此止步。考虑到日志记录语句的数量，我们决定只关注至少有 100 条不同语句的项目。数据集就在这里。

我们认为这是我们试图实现的目标的一个相当有代表性的例子。对于完整的演练和我们获取数据所采取的步骤，包括确切的 SQL 查询，请查看本文的最后一部分。

## 最后的想法

这篇文章强调 java.util.logging 实际上已经死了。大多数严肃的项目选择使用第三方日志框架。你在数据集中有没有发现其他我们可能遗漏的东西？你还有其他有趣的问题可以通过这个或者类似的数据来回答吗？