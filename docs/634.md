# Java 调试器——工具|工具的最终列表

> 原文：<https://www.harness.io/blog/java-debugger-list-of-tools>

看看不同类型的 Java 调试器。

Java 调试是一个复杂的领域。有许多类型的调试器和许多工具可供选择。在这篇博客中，我们将介绍七种调试器之间的区别，并回顾每一类中的主要工具，以帮助您为正确的工作选择正确的工具。

## 定义

用广义的定义来说，bug 是指我们编写的代码和我们得到的输入不匹配的情况。这些的不同效果可以大致分为几类:

**1。意外的流控制**，导致异常或代码中我们不想出现的位置。这是调试器最常用来检查代码和状态的相关性的地方。

2.**意外的堆分配**。在这种情况下，我们要么分配了太多的对象，要么分配了太大的对象。保留长久的引用只会增加乐趣。这就是堆分析器发挥作用的地方。

3.**延迟流量控制**。这很可能与我们将错误的输入传递给外部调用(即“SELECT * FROM everything”)或陷入长循环或无限循环有关。这就是性能分析器通常发挥作用的地方。

当然，工具和类别之间存在重叠，因为它们本质上都服务于相同的目的——让我们看到我们没有预料到的状态，以便我们可以修复代码，并使它达到预期。

## 1.命令行调试器

**主要工具**:这里的主角是 [jdb](http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html) ，它是 JDK 自带的，是相当于 gdb 的 JVM。它有一个命令行界面，可以附加到正在运行的 JVM 上。像 gdb 一样，它的功能是健壮的，你可以用 jdb 做任何你可以用一个完整的 IDE 调试器做的事情。jdb 有一个助手——jstack——可以让您在给定时刻打印一个活动 JVM 的线程调用栈。然而，这并不捕获变量或堆状态。

**用在**的时候:jdb 最大的好处就是便携性。您可以相当快地将它安装到服务器上，而不必远程附加调试器。如果您正在处理一个服务器上的恶劣情况，并且有能力停止 JVM 来检查它，那么 jdb 是您最好的朋友。

缺点:jdb 和 jstack 的缺点是，和其他命令行工具一样，它们在日常使用中效率不高。这就把我们带到了下一个类别。

## 2.IDE 调试器

**主要工具**:在这一类别中，有两个工具目前领先——Eclipse 和 NetBeans。两者都使用与 jdb 类似的技术来附加或启动新的 JVM。虽然移植性不是很好，但你确实得到了所有的附加功能，这可以使调试更短，更有趣。

**用在**时:假设你不是德克斯特(神童，不是连环杀手)——日常。

劣势:作为高端桌面应用，它们不是你想要在生产机器上运行的东西。总是有远程调试的可能性，但是在复杂的环境中，这种可能性很小。

## 3.构建您自己的调试器

到目前为止，我们描述的所有调试器都构建在相同的 JVM 开放调试架构上，最常见的是使用 JDWP (Java 调试器有线协议)与运行中的 JVM 通信。JSwat 是一个构建在这个框架之上的独立调试器的例子。

**在**时使用:构建定制的 JVM 扩展，或者对 JVM 如何工作非常感兴趣。

劣势:这是一件相当复杂的事情(尤其是当你不想影响目标 JVM 的状态时)，所以你需要一个非常有说服力的理由来解释为什么你不能使用一个现有的、经过实战检验的工具。

## 4.堆转储

**主要工具** : jmap，MAT。在很多情况下，你面对的是死者。在这些情况下，您看到的是 JVM 堆的快照，而不是已经停止的活动 JVM 的快照。JDK 附带的 jmap 允许您从活动的 JVM 生成堆转储。有许多工具可以让您探索和分析转储。 [jhat](http://docs.oracle.com/javase/6/docs/technotes/tools/share/jhat.html) 和 visualVM，都来自 JDK，在这方面做得很好。Eclipse 插件 [MAT](http://www.eclipse.org/mat/) 和 NetBean 的 HeapWalker 是很好的选择，因为它们利用了已经很强大的 IDE UI。

**在**时使用:出现复杂错误，无法应用正常的调试技术(例如，应用程序正在客户的服务器上运行)。另一种选择是使用堆转储来分析内存泄漏，方法是打开 JVM-heapdumponotomemoryerror 标志，让 JVM 在堆耗尽时自动转储堆的内容。

缺点:使用堆转储的最大缺点是它们和堆本身一样重(这很可能意味着它是以 GBs 为单位的)。然后，这必须被转回到你的分析。在生产中捕捉它们也不是在公园里散步。

## 5.历史调试器

**主要工具**:这类工具依赖于您不能或不想停止 JVM 来收集状态或获取堆快照。 [Chronon DVR](http://chrononsystems.com/) 就是这种方法的一个很好的例子。这里，调试器使用字节码检测来记录代码本身的数据。这通常包括调用方法的顺序和传递给它们的参数。这使得调试器能够“重放”代码，并让您了解执行时的流控制。Replay Solutions(被 CA 收购)是另一个采用不同方法的例子，记录 JVM 的 IO 输入，然后“重放”回一个活动实例——模拟过去执行的代码。

使用时机:这类工具的主要途径通常是在 QA 阶段，在 QA 阶段，它们可以通过捕获实际的运行时状态来帮助提高 bug 的重现性。另一个场景是让客户或支持工程师专门运行该工具，以便在应用程序在生产中意外运行时从 JVM 捕获状态。

**缺点**:这些工具最大的缺点就是日志记录需要你付出代价，记录每一件事的代价都很大。这意味着历史调试器可以将应用程序的速度降低 50%到一个数量级，从而限制了可以使用这些调试器的生产场景的数量。

## 6.动态跟踪

**主要工具** : BTrace。这一类的工具使您能够有选择地打印(“跟踪”)正在运行的 JVM 的状态信息，而不必停止它，也不必记录正在发生的一切。可以把它想象成动态织入一段新代码，从代码内部打印出值供您查看。这里一个突出的工具是 [BTrace](https://kenai.com/projects/btrace) ，它引入了自己的语法，让你定义在你的代码上跟踪哪里和什么。该语法还被设计为仅支持只读操作，以防止您实际改变程序的状态或导致无限循环。

**在**时使用:最常见的是当您试图调试服务器的特定问题(比如连接池被耗尽)或者希望在不停止 JVM 执行的情况下收集特定的统计数据。

**缺点**:就像调试器一样，从生产服务器进行动态跟踪通常是不可取的(而且很多时候是不允许的)。要在服务器环境中高效地使用动态跟踪，还需要一个小小的学习过程。

## 7.生产调试

**主要工具**:记录状态的日志框架(log4j，Logback)和大规模解析数据的日志分析器(Logstash，Splunk…)。

**用在**时:这是一个相当棘手的领域，因为当你处理生产系统时，停止 JVM 来查看状态或进行堆转储通常是一个大禁忌。这是因为你本质上是关闭服务器来调试它，这通常只在极端情况下才这样做。

我们通常在运行时从 JVM 中提取状态而不停止它的方法是有选择地将变量值记录到文件中(通常在 Java 日志框架的帮助下)。我们以后可以使用各种工具来解析数据，从简单的 tail 开始，一直到可扩展的日志分析器，如开源的 Logstash 和 enterprise Splunk。

劣势:这里最大的缺点是我们当然需要提前知道要记录什么(并有效地做到)。日志也会很快被填满，如果没有开发团队的严格管理，可能会包含很多不必要的数据或者遗漏一些关键的数据。

科学家发现，将日志文件中的数据拼凑起来以理解导致错误的可变状态是一种非常受欢迎的夜间和假日消遣。

## **线束服务可靠性管理调试**

我们构建了线束服务可靠性管理(SRM ),心中有一个简单的目标。我们想让开发人员容易地知道生产代码何时以及为什么会中断。这意味着，每当新的异常或日志错误开始发生时，我们都会捕捉它并通知您。第二部分是跟踪部署，以了解问题是从哪个部署开始的，以及发生的频率。最后(也是最有趣的)部分是生产调试部分。对于每个异常或错误，SRM 会向您显示错误发生时的确切源代码和变量状态(包括局部和对象值),就好像它发生时您就在那里一样。