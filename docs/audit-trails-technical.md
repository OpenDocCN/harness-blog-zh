# 审计线索 201:技术深度挖掘-见神奇|驾驭

> 原文：<https://www.harness.io/blog/audit-trails-technical>

审计跟踪比看起来要复杂得多！这是它的技术方面，在我们介绍审计跟踪之后。

在我们深入技术细节之前，让我们先简单讨论一下什么是审计追踪。

审计线索(或审计日志)是按照时间顺序对某人执行的操作的记录。每个审计记录至少捕获以下基本信息:

1.  已执行的操作；
2.  执行操作的用户的标识；
3.  执行操作的资源；
4.  执行操作的时间。

可以看到，每个审计记录本质上都是关于 ***谁做了什么，以及什么时候*** *。*

审计有助于:

1.  法规遵从性，因为它是一种可用于跟踪变更的书面证据。
2.  检测安全违规。
3.  调试问题。

审计跟踪是 Harness 平台的一个内置特性。在 Harness 平台上执行的大多数操作都会生成一个审计记录。请看下面的截图。

**注意:审计跟踪用户界面将于 2022 年 1 月结束的第四季度发布。目前可以通过 API 访问审计跟踪。**

如果你想了解更多关于[审计跟踪](https://harness.io/blog/audit-trails/)的基本信息，请随意阅读我们的 101 级博客帖子。这篇文章的其余部分是技术上的深入探讨，并讨论我们如何在 Harness 中实现审计跟踪的高级设计。

## 高层设计

在 Harness 中，我们有一个基于微服务的架构，其中有多个特定于域的微服务。比如我们有 CI 微服务，CD 微服务等。想要保留这种审计线索。出于这个原因，审计跟踪是作为 Harness 中的平台级功能构建的，因为它是许多微服务所需的常见功能。

在高层次上，审计系统由一个中央专用微服务组成，它负责与审计相关的一切。另一方面，还有客户端(其他领域特定的微服务，如 CI、CD 等。在这种情况下),他们用审计服务以审计的形式记录内部发生的操作。

## 审计服务

该微服务主要负责:

1.  存储审计。
2.  为审计提供查询和过滤功能。
3.  导出审计。
4.  删除超过保留期的审核。
5.  对审计实施访问控制。

这项服务的一些显著特点是:

1.  这是一个 Dropwizard 应用程序，大多数其他微服务也是如此。
2.  它通过 REST APIs 公开其所有功能。没有 GraphQL。
3.  所有 API 都受到访问控制，以确保只有授权用户才能阅读审计。
4.  此服务中运行一个后台作业，以确保定期删除超过保留期的审核。
5.  该服务的多个实例在生产中运行，以实现高可用性和可伸缩性。

## 数据存储

数据存储是这项服务最有趣的方面。审计服务使用 MongoDB 作为其存储后端。以下是做出这一选择的几个原因:

1.  **非关系数据**:审计记录之间没有关系。一个记录不引用另一个记录。因此，不需要外键关系。
2.  **ACID** :不需要保持多个审计记录的一致性。审计记录是相互独立的。因此，在单个记录级别提供 ACID 属性的数据存储就可以了。
3.  **操作开销:**丰富的在 Harness 内使用 MongoDB 的经验。Harness 中的大多数微服务都使用 MongoDB Atlas 作为其数据存储。不同的数据存储会增加操作的复杂性。
4.  **可伸缩性:**与大多数 NoSQL 数据库一样，MongoDB 也提供现成的分片功能，这在未来数据量增加时可能会有所帮助。一旦数据增长超过了单台机器所能容纳的范围，关系数据库就很难扩展，因为它们提供了诸如 ACID 事务、外键约束等特性。
5.  无模式:审计记录没有固定的模式。许多字段，如时间戳、动作、用户、资源 ID 等。对于所有审计记录都是通用的，但是审计记录中可以有许多附加字段，这取决于被审计的操作的种类。

## 审计客户

如前所述，客户机是其他微服务，它们希望捕获在它们内部执行的操作作为审计线索。

注册审计很容易:只需调用审计服务的 API。然而，客户端最重要的技术考虑是如何首先捕获操作作为审计记录。

让我们看看几个选项:

1.  **在服务业务逻辑中嵌入审计代码:**每个服务方法都可以创建一个审计记录，并与审计服务一起保存。在这种方法中，审计日志代码和业务逻辑混在一起，这使得它不可维护。此外，开发人员可能会忘记编写审计日志代码。这使得这种方法容易出错。
2.  **面向方面编程(AOP)** :使用 Spring 之类的面向方面框架来拦截方法调用，保存审计。然而，AOP 框架只能访问方法名和参数，因此很难确定正在执行操作的对象，并生成丰富的面向业务的审计记录。
3.  **变更数据捕获:**通过数据库维护的事务日志找出发生的操作，并生成审计记录。这种方法与底层的数据库技术高度耦合。像 Debezium 这样的框架通过抽象出特定于 DB 的实现来简化变更数据捕获。但是这种方法仍然有很高的操作和维护(将数据库行级别的更改转换为高级面向业务的审计记录的代码)开销，这是我们希望避免的。

我们更喜欢一种标准的方法来捕获跨微服务的审计，即使它们可能构建在不同的技术堆栈上。**进入**域事件。

## 域事件

领域事件是领域驱动设计中非常重要的工具。领域事件记录业务重大事件。ProjectCreated *、* AccountDeleted *、* SecretUpdated *、*都是域事件的例子。基于这些域事件，可以触发其他业务工作流。

域事件包含所有相关信息。例如:ProjectCreated events 会有 *accountId，Id，name，description* properties *。*其他常见属性，如*用户标识、时间戳*等。可以从请求上下文中填充。

将变更和相应的域事件一起保存在 DB 的同一个事务中是非常重要的。

*一旦域事件被持久化，一个后台作业就通知感兴趣的侦听器它们的发生，以便它们可以被执行。感兴趣的听众可以在同一个微服务内，也可以在其他微服务内。如果另一个微服务对该事件感兴趣，专用监听器可以将该事件发布到消息代理的某个主题中，其他服务可以订阅该主题。*

## *来自域事件的审核记录*

*一旦有了域事件，就很容易利用它们并从中生成审计记录。有一个监听器，它监听域事件，将它们转换成审计记录，最后用审计服务保存它们。*

## *这种方法的优点*

1.  ***低维护:**域事件是域的一部分。它们是在业务层捕获的。因此，很容易将它们转换成审计记录。审计日志记录代码不会污染服务层代码。*
2.  ***不需要中间件:**域事件首先保存在服务的数据存储中，它充当一个持久队列。事件将继续被分派给所有侦听器进行处理，直到所有侦听器都成功处理了该事件。因此，即使审计服务在一段时间内不可用，这也不是问题。该事件将继续重试，直到成功注册审核！*

*这种方法实现了**事务发件箱模式**。你可以在这里了解更多:[https://micro services . io/patterns/data/transactional-outbox . html](https://microservices.io/patterns/data/transactional-outbox.html)。*

## *结论*

*我们希望您喜欢这个技术审计跟踪演练。审计跟踪在许多行业中都是必要的，并且只是作为 CI/CD 中的一种最佳实践。同样，请随意阅读我们关于[审计追踪](https://harness.io/blog/audit-trails/)的入门级帖子，了解更多关于你为什么需要它们的信息。*

*对更关注治理的内容感兴趣吗？阅读我们关于 [RBAC](https://harness.io/blog/rbac/) 和[秘密](https://harness.io/blog/secrets-management-ci-cd/)的文章！*