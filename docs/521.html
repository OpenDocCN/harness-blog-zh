<html>
<head>
<title>The Journey to Microservices &amp; Deployment Strategies | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>微服务和部署策略之旅|利用</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/microservices-deployment-strategies#0001-01-01">https://www.harness.io/blog/microservices-deployment-strategies#0001-01-01</a></blockquote><div><p>从整体到微服务！了解所有关于微服务和部署策略的信息。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>每天，我都会与许多客户和潜在客户谈论他们的软件交付策略。在所有的话题中，最重要的讨论之一是他们在整体微服务之旅中的位置。一些人开始新建，从头开始构建微服务架构。其他构建或继承的整体式应用程序已经过多年的测试，但其固有的局限性降低了它们以业务要求的速度交付的能力。大多数人都在从整体服务到微服务的旅程中，努力克服出现的所有可能性和障碍。</p><p>让我们深入这个旅程，定义我们的术语，并讨论微服务的神话状态是什么样子的，其中团队能够按需部署更小的组件而不停机。</p><h2>微服务基础</h2><h3>为什么选择微服务？</h3><p>我在大学里花了很多时间给卡车卸货来支付账单。想象一下，如果我的 5-10 名船员都聚集在仓库的同一个地方，试图在同一时间从同一堆中抓取箱子，并把它们带到同一个地方。混乱？也许吧。低效？绝对的。任何系统，无论是软件、硬件还是机械，都是为了提高效率而分工合作。微服务是一种在软件系统中分割任务的系统方法。</p><h3>什么是微服务？</h3><p>在最基本的层面上，微服务是一个软件组件，在更大的系统中有一个独特的目的。这种用途的例子可以是处理支付、购物车或电子商务应用程序中的用户。</p><p>让五个软件工程师来定义微服务，你会得到六个甚至更多的定义。也就是说，对于为什么会这样，以及拥有什么样的共同特征，有一个普遍的共识。关于服务职责的界限在哪里，如何正确应用 DRY(不要重复自己)原则等等，仍然存在持续的争论。</p><p><strong>仔细确定范围</strong>:职责应该归结为围绕单一职责的一组基本任务(通常映射到业务能力)。太宽的话，你会得到 Monolith Lite，太细的话，你会得到一个感觉像是用乐高搭建了一整栋房子的系统。</p><figure class="w-richtext-figure-type- "/><p><strong>松散耦合:</strong>两个或更多服务之间的交互应该遵循黑盒方法。不管服务 A 的开发人员对服务 B 了解多少，他们只根据约定的契约(API)进行交互。根据这一原则，您对待另一个微服务的方式与对待您可能集成的任何第三方服务的方式相同:您假设他们只会做他们在文档和规范中发布的事情。</p><p><strong>高可用性和容错:</strong>这些应用程序范围较窄，但应该是独立的，能够在不中断大型应用程序的情况下处理不利事件。</p><p>一般来说，好的微服务设计遵循好的代码和应用程序设计原则。给定的组件应该能够执行，而不管其他服务在做什么，只要它们可用并提供它们同意的服务。</p><h3>整体应用和微服务的区别</h3><p>在实践中，微服务最重要的好处是摆脱了通常必须在整体架构中使用的要么全有要么全无的方法。在一个 monolith 中，一些组件可以被替换或修补，但是如果没有一个好的系统来管理这个过程，您经常会遇到与每次部署时重置整个系统一样多的麻烦。</p><p>扩展是微服务真正能够大放异彩的另一个领域。当一个应用程序达到最大容量时，它很少需要更多的“一切”，而不是特定的服务。例如，一个电子商务应用程序可能会在结账时遭到猛烈攻击，但不需要额外的搜索能力。拥有可以根据需要水平扩展的较小组件，可以更有效地利用资源和更快地响应特定需求。</p><p>最后，微服务允许更大的灵活性。如果您正在添加一个新功能，它可能是一个全新的服务。这使得 it 可以自由地进行优化设计，而不受现有服务的限制。从事这项工作的团队不必学习新的代码库，甚至可以选择使用更适合这项服务的不同编程语言。现有的服务可以更容易地更新或替换，因为团队有一个服务必须履行的明确定义的契约(最常见的形式是 RESTful API，使用普遍存在的格式，如 JSON 或 XML)。与此形成对比的是，作为服务所有者，您并不经常完全了解整体应用程序的每个其他部分是如何实现(并且经常误用)您的代码的。</p><figure class="w-richtext-figure-type- "/><h3>从整体应用部署到微服务</h3><p>又到故事时间了！我曾经和 Jenkins 一起部署过一个单一的应用程序。我们必须满足 99.7%正常运行时间的 SLA，并且必须进行蓝绿切换。这是早期的 Jenkins，Kubernetes 之前的日子，那时微服务应用还不流行。部署过程非常缓慢，整个过程中使用了 100 多个脚本，需要 2-4 个小时来启动、应用补丁程序和进行切换前的准备。有很多词可以形容这一点，其中一些我被告知不允许在公司博客上使用。这并不是每个人对单片应用程序的体验，但这是一个常见的故事。</p><p>很少有公司会直接从上述领域跳到完美微服务应用的乐土。转换通常看起来像是将应用程序中更容易独立的服务和方面分开。随着时间的推移，这个巨大的整体变得越来越小，每次必须同时部署的组件也越来越少。理想的状态是每个服务都是小型的、快速的，能够按需部署、扩展以满足容量需求，并且能够快速回滚。</p><h2>分解微服务部署</h2><p>微服务之旅的最终状态将因给定组织的目标而异。在大多数情况下，功能是相同的。敏捷性、灵活性和高可用性(或者我称之为伟大技术的‘能力’)只是其中的一些好处。当涉及到部署时，这种轻量级方法可以表现为每周发布特性，甚至可以一天多次无畏地部署给定的服务。</p><h2>微服务部署策略</h2><p>在您开始执行部署之前，有必要快速讨论一下您将部署到的常见平台，以及服务最终驻留在哪里。</p><h3>库伯内特斯</h3><p>Kubernetes 不涉及管理集群的复杂性(这是另一本书的内容)，它允许在部署和伸缩方面有很高的自由度。服务可以声明性地分布在节点、区域等之中。最大限度地提高可用性、性能和可扩展性。此外，<a href="https://harness.io/blog/what-is-a-service-mesh/" target="_blank">服务网格</a>如 Istio 提供了高效使用边车模式、流量路由等功能。</p><h3>物理/虚拟机</h3><p>当 Kubernetes 席卷 DevOps 世界时，每天都有数以百万计的服务器基础设施部署，包括单片和微服务应用。其中包括直接使用传统的 HTTP 服务器、Docker 容器以及 Docker Swarm 等编排解决方案。在直接部署到服务器的上下文中，常见的模式包括为每个服务至少将每个服务的一个实例部署到一个主机或专用主机。后者的优点是允许更容易地打包单个服务，缺点是水平扩展需要时间，这取决于流程的优化程度。</p><h3>无服务器</h3><p>无服务器是另一种越来越流行的常见设计模式。AWS Lambda 是最常见的例子之一，还有 Azure 函数和谷歌云函数。使用这种模式，不需要维护服务器——您提供代码，代码在某个地方执行。不需要维护操作系统，状态通过数据库和其他存储方式进行管理，因此对于通过与其他服务交互来执行任务的服务来说，这非常有用。虽然我见过一些客户采用纯无服务器方法，但大多数客户将无服务器作为大型系统中的一个组件。关于无服务器还有很多要说的，所以现在我把这个留给你<a href="https://harness.io/blog/serverless-death-by-infrastructure/" target="_blank">。</a></p><h3>战略</h3><h4><strong>滚动</strong></h4><p>随你怎么称呼它，但是那些不需要持续可用的服务仍然利用以新换旧的模式，然后点击重启按钮。简单性方面很有吸引力，对最终用户的干扰较少。随着停机窗口变得越来越小，这越来越不受欢迎。</p><figure class="w-richtext-figure-type- "/><h4><strong>蓝绿色</strong></h4><p>要实现最简单的最小停机时间策略<a href="https://harness.io/blog/blue-green-canary-deployment-strategies/" target="_blank"> Blue-Green </a>，您需要建立一个与正在运行的服务容量相同的服务，然后在负载平衡器上将流量切换到新的服务。主要优势是在切换过程中对最终用户的干扰最小，无需设计您的服务来处理多个并行版本，并且能够通过将流量转移回之前的部署来立即恢复。缺点是，在出现故障的情况下，100%的用户都会受到影响，直到流量被转移回来，以及运行相同服务的相同集合的容量成本。</p><figure class="w-richtext-figure-type- "/><h4><strong>金丝雀</strong></h4><p>虽然前两种策略可以手动执行，但<a href="https://harness.io/blog/blue-green-canary-deployment-strategies/" target="_blank"> Canary </a>是一种仅作为 CD(连续交付)解决方案的一部分才有效的策略。Canary rollouts 是一小组新服务被启动，一小部分流量被定向到该服务，一旦通过验证门，更新将在整个服务池中全面铺开。最明显的优势是，应用程序问题只会影响用户群的一个子集，退出会将流量重定向回仍在运行的稳定服务。直到最近几年，持续执行金丝雀策略是极其困难的，但 Harness 是第一个(或第一个)提供开箱即用的无脚本金丝雀部署的产品之一。除了实施 Canary 推广的复杂性之外，一些人可能选择不使用 Canary 推广的其他原因包括应用程序无法处理同一服务运行的多个版本，或者缺乏验证基础架构来了解该策略的全部优势。</p><figure class="w-richtext-figure-type- "/><h4><strong>对比对比</strong></h4><p>这些策略及其变体是当今的行业标准，从我的经验来看，公司在微服务之旅中所处的位置往往与选择的策略相对应。在早期，滚动式策略很容易实现并完成工作。随着正常运行时间和交付要求的增加，对更复杂策略的需求也在增加。Blue-Green 在概念上很简单，具有强大的回滚功能，在快乐路径的情况下停机时间最少。Canary 部署结合了各种优势，可在部署失败的情况下最大限度地减少停机时间、快速回滚和最小中断。金丝雀风格的模式可以通过多个阶段进行扩展，也可以通过 Istio 等网格来定位特定的流量。</p><p>适合您的正确策略应取决于以下几个因素:</p><ul role="list"><li>正常运行时间要求(SLA/SLO)；</li><li>质量要求；</li><li>服务成熟度(设计、容错、兼容性)；</li><li>用于实现卷展栏的工具。</li></ul><h2>利用线束部署微服务</h2><p>Harness 提供了所有这些策略，不需要任何脚本。相同的服务甚至可以部署到具有不同策略的多个环境中。如果 Canary 部署在您的开发环境中过于复杂，而 Blue-Green 部署又过于昂贵，那么就部署吧！希望您的用户继续他们的日常工作，而没有意识到您部署了新的东西？淡黄色和蓝绿色听起来像你正在寻找的。</p><h2>结论</h2><p>Harness 被设计成能够在几分钟内以复杂的策略构建管道。不相信我？<a href="https://harness.io/demo/" target="_blank">立即预订您的演示</a>!如果你还没有准备好演示，继续学习。下载我们关于<a href="https://harness.io/learn/ebooks/ebook-pipeline-patterns/" target="_blank">管道模式</a>的电子书，了解更多关于上面提到的策略——以及如何正确使用它们。</p></div></div>    
</body>
</html>