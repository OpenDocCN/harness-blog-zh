<html>
<head>
<title>Java vs. Native Agents – And How It Affects Your Code | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Java与本地代理的对比——以及它如何影响您的代码</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/java-vs-native-agents#0001-01-01">https://www.harness.io/blog/java-vs-native-agents#0001-01-01</a></blockquote><div><p>Java和本地代理之间的区别以及它将如何影响您的代码和应用程序。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p><strong>在安装代理之前您应该知道什么，以及它如何影响您的代码</strong></p><p>当构建一个可扩展的服务器端应用程序时，我们花费了大量的时间来考虑如何在生产中监控、操作和更新我们的代码。一种新的工具已经发展到可以帮助Java和Scala开发人员做到这一点。它们中的许多都建立在外部代码在运行时与JVM集成的最强大的方式之一上——Java代理。</p><p>‍ <br/>代理是操作系统本地或Java库(我们将在下面描述它们的区别), JVM为它们提供了普通应用程序代码所不具备的功能。为了了解这些工具有多基础，让我们来看看我们使用的几个依赖于它们的工具:</p><ul role="list"><li><strong>评测器</strong>使用Java代理修改目标框架的代码，以注入收集性能指标的新代码。这包括独立或托管服务，如NewRelic或YourKit</li><li>JRebel 通过构建一种在运行时不需要重启JVM就能提供类的平滑热交换的技术，将它带到了一个新的高度</li><li><strong> Play框架</strong>使用Java代理在运行时支持类的热交换</li><li>在<strong> Harness，</strong>我们利用JVM提供给本地代理的低级功能来显示导致错误的实际源代码和变量值。</li></ul><h2>代理商能做什么？</h2><p>正如我上面提到的，有两种代理——Java和native。虽然两者都以几乎相同的方式加载到JVM中(使用一个特殊的JVM启动参数)，但它们在构建方式和用途上几乎完全不同。</p><p>‍ <br/>让我们来看两个。<br/></p><h3><strong> Java代理</strong></h3><p><br/> Java代理是。jar文件定义了一个特殊的premain静态函数，这个函数将在应用程序的main函数被调用之前被JVM调用。神奇的部分来自于<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/instrument/Instrumentation.html" target="_blank">插装</a>对象，它由主机JVM作为参数传递给这个函数。通过抓住这个对象，代理的代码(否则表现为根类加载器加载的任何Java代码)可以做一些真正强大的事情。<br/></p><h6>public static void premain(字符串代理参数，仪器仪表){</h6><h6>myInst = inst//获取对inst对象的引用供以后使用</h6><h6>}</h6><h4>他们做什么</h4><p>给予代理的最强大的能力是在运行时类中动态重写目标类的方法内容的能力(字段结构是不可变的)。这个过程称为字节码插装，它使代理能够在代码运行时重写方法的内容。<br/>一些例子包括添加对特定方法的调用以分析性能(例如end time–start time)或记录参数值(例如传递给servlet的URL)。另一个例子是在不重启JVM的情况下重新加载一个新版本的类，就像JRebel所做的那样。</p><h4>这是怎么做到的</h4><p>对于代理来说，修改代码或加载的类实际上触发了JVM重新加载类的过程，其中类的字节码被替换为新版本。这要求代理能够向JVM提供可验证的新字节码(即符合JVM规范)。不幸的是，在运行时生成正确的字节码并不简单——有很多需求和边缘情况。为此，代理通常使用库来读写字节码。该库使他们能够将现有类的字节码加载到一个类似DOM的结构中，通过添加诸如分析调用之类的东西来修改它，然后将DOM保存回原始字节码。</p><p>‍ <br/> <a href="http://asm.ow2.org/" target="_blank"> ASM </a>是一个流行的库，它提供了一个通用的Java字节码操作和分析框架。这是最流行的字节码操作库之一，可以用来修改现有的类或者直接以二进制形式动态生成类。它非常流行，以至于Sun的一些内部代码实际上使用它来解析Java中的字节码。</p><h3><strong>本地代理</strong></h3><p>本土特工是完全不同的野兽。如果您认为Java代理可以让您做一些很酷的事情，请抓紧时间，因为本地代理在完全不同的层面上运行。本机代理不是用Java编写的，而大部分是用C++编写的，不受普通Java代码运行的规则和限制。不仅如此，它们还提供了一组非常强大的功能，称为JVM工具接口(JVMTI)。</p><h4>他们做什么</h4><p>jvmti.h公开的这组API使JVM动态加载的C++库能够获得对JVM实时工作的高度可见性。这跨越了广泛的领域，包括GC、锁定、代码操作、同步、线程管理、编译调试等等。JVM TI被设计成使JVM尽可能透明，同时仍然保持设计灵活性，允许JVM供应商提供不同的底层实现。这组API非常广泛，包含数百个回调和JVM函数。您可以使用这些工具来做Java代理不能做的非常强大的事情，比如编写自己的调试器，或者构建低级的实时错误分析工具。<br/> ‍</p><p>由Harness Service Reliability Management(SRM)执行的绝大多数监控都是在本机代码中进行的，级别低于大多数其他代理。这意味着在大多数情况下，SRM甚至对字节码级别的其他代理都是不可见的。<br/> ‍</p><p>由于SRM在服务器上占用的CPU、内存和网络空间很少，因此其他代理的性能不会受到其监视活动的影响。如果您想进一步了解SRM如何与您现有的工具和代理配合工作。<br/> ‍</p><p>回到JVMTI——这里有一个JVMTI提供给代理的回调，这样每当JVM内部的任何地方抛出异常时，代理都会接收到抛出异常的字节码位置、所有者线程、异常对象以及是否/在哪里会被捕获。确实是强大的东西。<br/></p><h6>void JNI调用异常回调(jvmtiEnv * jvmti，JNIEnv *jni，jthread thread，</h6><h6>jmethodID方法，jlocation位置，jobject异常，</h6><h6>jmethodID catch_method，jlocation catch_location)</h6><h4>不利方面</h4><p>如果我描述的一切听起来绝对桃色，你可以问，为什么不是所有的代理都写成原生代理？有几个需要注意的原因，所以在这里列出来(排名不分先后):</p><h5># 1–复杂性</h5><p>首先是JVMTI API非常复杂，有许多小的移动轮子。在大多数情况下，如果您编写的代理不需要非常低级的功能，那么Java代理API就很好，它更简单，可以帮助您更快地完成工作。</p><h5># 2–便携性</h5><p>由于本机代理是作为本机库编写和编译的(。所以/。它们需要在您想要支持的任意数量的操作系统上进行编译和测试。如果你看看Windows、OSX和不同风格的Linux，这可以转化为大量的工作。与Java代理相比，Java代理是由JVM作为Java代码执行的，因此从设计上来说具有固有的可移植性。</p><h5># 3–字节码操作</h5><p>由于本机代理通常是用C++编写的，这意味着它们不能直接使用可靠的Java字节码操作库(如ASM ),而必须使用JNI返回到JVM中，这就减少了一些乐趣。</p><h5># 4–稳定性</h5><p>JVM提供了强有力的保护措施，防止代码做出会导致愤怒的操作系统终止进程的事情。正常情况下会导致SIGSEV和进程崩溃的内存访问冲突，会给我们一个漂亮的NullPointerException。由于本地代理运行在JVM的同一层(与Java代理相比，Java代理的代码由JVM执行)，因此它们所犯的任何错误都有可能终止JVM。</p><h2>最后的想法</h2><p>希望这有助于突出两者之间的一些差异。了解什么是代理以及它们是如何构建的是有好处的，因为即使您最终没有编写一个代理，您今天也可能会依赖其中的一个或多个来驱动您的应用程序。</p><p>‍</p></div></div>    
</body>
</html>