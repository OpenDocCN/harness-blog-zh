<html>
<head>
<title>Tutorial: Vault Agent Advanced Use Case With Kubernetes Delegates and Shared Volumes | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>教程:使用Kubernetes代理和共享卷的Vault Agent高级用例|利用</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/vault-agent-kubernetes-delegates#0001-01-01">https://www.harness.io/blog/vault-agent-kubernetes-delegates#0001-01-01</a></blockquote><div><p>本教程是我关于Vault代理集成和利用的文章的高级延续。我收到了一些专家客户的反馈，我决定创建另一个教程，重点介绍Kubernetes代理和我们支持Vault Agent作为Harness Secrets Manager集成方法的新功能。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>本教程是我关于Vault Agent <a href="https://harness.io/blog/devops/vault-agent-secrets-management/" target="_blank">集成</a>和利用的文章的高级延续。我收到了一些专家客户的反馈，我决定创建另一个教程，重点关注<strong> Kubernetes代表</strong>和我们支持<strong>保险库代理</strong>的新功能，作为线束秘密管理器的集成方法。我们将利用配置映射、持久卷、机密等。创建非常可靠的存储库代理部署。</p><p>记住保险库代理<strong>不是</strong>Harness的一个组件是非常重要的。它在哈希公司的王国里。在一天结束时，我们的代表只需要能够够到包含好令牌的接收器文件，即使万一Tom Marvolo Riddle自己把它放在那里。金库特工只是一个协助者。Harness不对您的Vault Secrets Manager负责。</p><h3>重要说明:管理多个Vault服务器</h3><p>假设每个环境(如开发、QA、生产)都有一个Vault服务器。</p><p>我决定在一些<strong>清单模板</strong>中利用<strong>线束环境名</strong>。这是使用多台Vault服务器进行设置的好方法。</p><p>此外，为了保持原子性并避免单点故障，我考虑了保险库服务器和保险库代理之间的一对一关系。</p><p>因此，如果每个环境中有一个存储库，则该存储库代理可以有多个部署。</p><p>为了帮助我们解决这个用例，我们将利用一些服务配置变量，这些变量将被环境服务配置覆盖所覆盖(这是本教程的预览，但让我们来看一看):</p><p>这是服务配置变量:</p><figure class="w-richtext-figure-type- "/><p>这是来自开发环境的覆盖:</p><figure class="w-richtext-figure-type- "/><p><br/></p><h2>教程第1部分:在K8s中创建更专业的Vault Agent部署</h2><h3>要求</h3><p>一点K8s经验，一个目标集群，一个不错的老马具账号。因为我们将使用持久卷，所以Vault Agent工作负载必须驻留在与代理相同的Kubernetes集群名称空间中。</p><h3>Vault上的任务</h3><p>请参考我在本文开头的第一个教程，在您的Vault服务器中配置一个好的程序。</p><h3>安全问题</h3><p>由于RoleID和SecretID也是超级重要的秘密，我决定将它们存储在默认的由Harness管理的Google KMS秘密管理器中。然后，我使用模板引擎为我检索它们。</p><p>当然，这是你必须和你的安全顾问或安全架构师一起决定的事情。我在我的用例中展示了我所做的事情。</p><h3>保险库代理库本内特的清单来源</h3><p>我会在这个<a href="https://github.com/gacerioni/vault-agent-kubernetes" target="_blank"> GitHub repo </a>中保存所有与我们的Vault Agent K8s服务清单相关的文件。我不会破坏这个回购，但这是一个实验室回购。为了安全起见，请把它叉开。</p><h3>第一步</h3><p>第一步是在Harness中存储RoleID和SecretID。如果您想采用相同的方法，它们是在我的第一篇教程中创建的。同样，底层Auth方法与Harness没有关系，但这是您应该与Vault管理员一起做出的决定。</p><figure class="w-richtext-figure-type- "/><figure class="w-richtext-figure-type- "/><p><strong>重要提示:</strong>如果您想要添加另一个安全层，您可以将其存储为base64，并使用一个数据秘密(在当前使用stringData的Secret Kubernetes清单中)，而不是stringData。看你的了！</p><h3>第二步</h3><p>让我们创建将托管Vault Agent工作负载的Harness服务。</p><figure class="w-richtext-figure-type- "/><p>添加工件源中可用的Vault Docker图像:</p><figure class="w-richtext-figure-type- "/><p>确保链接您的远程清单:</p><figure class="w-richtext-figure-type- "/><p>请添加我们之前讨论过的服务配置变量:</p><figure class="w-richtext-figure-type- "/><h3>第三步</h3><p>现在，创建一个环境、一个基础设施定义，并添加覆盖。这是处理多个Vault服务器的技巧。我们将在模板技巧中使用这些变量。</p><figure class="w-richtext-figure-type- "/><h3>第四步</h3><p>现在，让我们研究一些与存储库代理清单文件相关的内容。</p><p>如果您看一下values.yaml文件，您会发现其中有一些重要的内容:</p><ul role="list"><li>持久卷声明名称，这是我选择的在这个部署和委托部署之间共享接收器文件的机制；</li><li>基础身份验证方法配置HCL文件；</li><li>RoleID和SecretID函数从默认的机密管理器中检索它们。</li></ul><p>注意，当我需要为每个环境保留一个对象时，我使用了＄{ env . name}。这将有助于我们设计多保险库服务器策略。</p><figure class="w-richtext-figure-type- "/><p>您可以在templates文件夹中的deployments.yaml文件中看到我是如何处理所有这些内容的。</p><h3>第五步</h3><p>现在，让我们在Harness中创建一个滚动部署工作流。</p><figure class="w-richtext-figure-type- "/><h3>第六步</h3><p>如果您照原样运行它，您已经在发送一个存储库代理了！<br/></p><figure class="w-richtext-figure-type- "/><h3>第七步</h3><p>那么，你怎么知道这是有效的呢？您可以将日志输出到您最喜欢的具有日志功能的工具中。就我而言:Splunk、ELK和Graylog。</p><p>因为我们已经离家很远了，所以让我们把派对留在K8s的世界里吧。让我们使用<strong> ReadinessProbes </strong>来确保接收器文件是可用的！由于接收器文件只有在这个过程结束时才会出现并填充一个令牌，所以这是监视Pod是否良好的好方法。</p><figure class="w-richtext-figure-type- "/><p>尽管如此，探针上的任何东西都无法判断令牌是否是好的。即使您的身份验证方法包含错误的凭据，存储库代理也会创建文件。和其他东西一样，这是哈希公司的保险库设计——与脊甲无关。</p><p>您可以创建一个自定义脚本来导出VAULT_ADDR和VAULT_TOKEN，并使用以下命令测试该令牌:</p><p>VAULT_TOKEN= <the_token_generated_in_sink>保险库机密列表<br/></the_token_generated_in_sink></p><p>我建议您使用以下命令检查日志:</p><p>ku bectl-n harness-delegate logs pod/vault-agent-<...><br/></...></p><p>这是一个很好的部署:</p><figure class="w-richtext-figure-type- "/><p>这是个坏消息:</p><figure class="w-richtext-figure-type- "/><h3>第一部分结果</h3><p>使用您将在高级就绪探测中使用的相同逻辑，令牌必须是好的！</p><figure class="w-richtext-figure-type- "/><h2>教程第2部分:与委托部署共享令牌(具体来说是StatefulSet)</h2><p>我们几乎结束了艰苦的工作。现在，是时候改变我们的马具委托清单了。是的，就是您用来在集群中安装代理的那个。</p><p>唯一的要求是，Vault代理和代理必须位于同一个K8s集群名称空间中。我们使用PVC来共享接收器文件。</p><h3>第一步</h3><p>让我们更改我们的委托清单，以便它可以通过卷到达我们的接收器文件。我使用的是来自委托UI向导的完全相同的清单。这里没有诡计:<br/></p><figure class="w-richtext-figure-type- "/><p>第一个技巧是在Harness Delegate StatefulSet块的末尾添加卷定义:</p><figure class="w-richtext-figure-type- "/><p>卷:<br/>-名称:vault-agent-sink-shared<br/>persistentVolumeClaim:<br/>声明名称:vault-agent-sink-PVC-dev <br/></p><p>当然，添加挂载以使文件对我们的线束委托容器可用:</p><figure class="w-richtext-figure-type- "/><p>别急，这里可以得到一个很好的例子:<a href="https://github.com/gacerioni/vault-agent-kubernetes/blob/main/EXAMPLE-harness-delegate-with-vault-agent-mountpoint/harness-delegate.yaml" target="_blank"> GitHub repo </a>。</p><h3>第二步:</h3><p>我们可以看到，现在委托容器可以看到接收器文件。这太棒了。</p><figure class="w-richtext-figure-type- "/><p>让我们继续检查Harness是否能够通过新的代理方法与Vault集成——但是使用Kubernetes委托:</p><figure class="w-richtext-figure-type- "/><h3>第三步:</h3><p>现在，我们可以创建和编辑一些秘密来稍微强调一下令牌。<br/></p><figure class="w-richtext-figure-type- "/><p>不错！</p><p> </p><figure class="w-richtext-figure-type- "/><p><br/>有任何问题或意见吗？让我知道-我总是乐意帮忙。</p><p>加百列</p></div></div>    
</body>
</html>