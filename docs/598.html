<html>
<head>
<title>CLR vs JVM: How the Battle Between C# and Java Extends to the VM-Level | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>CLR vs JVM:C #和Java之间的战争如何延伸到VM级|利用</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/clr-vs-jvm#0001-01-01">https://www.harness.io/blog/clr-vs-jvm#0001-01-01</a></blockquote><div><p>Java和C#之间的战争永远不会结束。了解虚拟机级别的差异如何影响这场辩论。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>我们已经写了很多关于C#和Java之间的区别，涵盖了我们最喜欢的特性，这些特性在另一个中没有对等的。随着关于哪种语言比另一种语言更好的激烈争论的进行，我们将深入战场，看看它们各自的虚拟机(VM)之间的差异和相似之处。<em> ‍ </em></p><h2>TL；DR:CLR和JVM之间的五大相同点和不同点</h2><p>CLR和JVM之间的主要相似之处包括:</p><ul role="list"><li>两台虚拟机(VM)</li><li>两者都包括垃圾收集</li><li>两者都采用基于堆栈的操作</li><li>两者都包括运行时级别的安全性</li><li>两者都有异常处理的方法</li></ul><p>CLR和JVM之间的主要区别包括:</p><ul role="list"><li>CLR被设计成语言中立的，JVM被设计成特定于Java的</li><li>CLR最初只与Windows兼容，JVM可以与所有主流操作系统兼容</li><li>CLR使用JIT编译器，JVM使用专门的JIT编译器，称为Java HotSpot</li><li>CLR包括闭包、协程和指针声明/操作的指令，而JVM没有</li><li>JVM与更健壮的错误解决和生产监控工具兼容</li></ul><p>既然我们已经确定了5个最大的相似性和差异，让我们来看看所有这些都意味着什么。从基础开始，然后深入了解所有这些意味着什么。</p><h2>什么是虚拟机？</h2><p>不难猜测，虚拟机(VM)是计算机操作系统的虚拟仿真。除此之外，这种系统抽象还有两种不同的实现。<br/> <strong> <em>系统虚拟机</em> </strong>作为全功能操作系统存在，通常被创建为使用物理机器的替代品。这样，多个环境可以同时在同一台机器上运行。但是，这听起来不像我们钟爱的CLR和JVM。<br/>公共语言运行时(CLR)和Java虚拟机(JVM)都是<strong> <em>进程虚拟机</em> </strong>。这意味着它们不是执行整个操作系统，而是专门设计来运行一个进程或程序，而不依赖于平台环境。</p><h2>仔细看看CLR和JVM之间的相似之处</h2><p>CLR和JVM都是虚拟机，它们都执行独立于平台的操作，即执行编译后的源代码。本质上，这些虚拟机都充当程序员源代码和系统机器代码之间的中间步骤，允许各种类型的处理器具有更高的可用性。在下图中，您可以看到两者的高级功能实际上是相同的。</p><p>除了它们的基本功能，它们还包括垃圾收集、运行时安全和异常处理的方法。最后一个相似之处是，两者都采用基于堆栈的操作，这是存储和检索操作数及其结果的最常见方法。<br/> ‍</p><p>但是，当然，对于这些虚拟机共享的每一个相似之处，都可以发现实施上的差异。然而，就像编程语言一样，这些虚拟机的开发以一种类似蛙跳的方式前进。其中一个实现了类似“标记-清除-压缩”的垃圾收集方法，另一个很快也会实现。</p><h2>现在一些主要的区别</h2><h3>语言和平台兼容性</h3><p>CLR和JVM之间一个潜在的表面差异(尽管这可能影响了它们的开发方式)是，JVM是专门为与Java一起工作而创建的，而CLR是被设计成语言中立的。相反，CLR最初被设计成只能在Windows操作系统上运行，而JVM总是与操作系统无关的。众所周知，时代已经变了，现在有了运行在Linux和Mac上的CoreCLR，并且开发了更多的语言来支持JVM。这导致了一个事实，在很大程度上，CLR和JVM之间的差异也是使用它们的语言之间差异的标志。或者，你可以说语言之间的一些最重要的差异(为了便于讨论，让我们说<a href="http://blog.overops.com/c-vs-java-5-irreplaceable-c-features-wed-kill-to-have-in-java/"> C#和Java </a>)实际上是在VM级别实现的。</p><h3>JIT编译</h3><p>我们在VM级别看到的一个很大的区别是，尽管两者都使用JIT(实时)编译，但编译器并不是同时运行的。当CLR在运行时被调用时，它将所有MSIL代码编译成机器码。JVM使用名为HotSpot的专用性能引擎将Java字节码JIT编译成机器可读的代码。它的不同之处在于它编译和优化了代码中最常用的“热点”。这些编译策略在性能方面都有自己的权衡。因为CLR在运行时调用时编译所有的机器码一次，所以在某些情况下执行时间可以缩短。但另一方面，如果在高频率下需要一小部分代码，Java的HotSpot编译器可以通过额外的优化来提高效率。</p><h3>语言功能的实现</h3><p>另一个较小的区别是，CLR是用处理泛型类型和在运行时对这些类型应用参数化专门化的指令构建的。基本上，这意味着CLR能够识别List <int>和List <string>之间的区别，而JVM不能(Java将泛型实现为编译器的一部分)。CLR还允许用户以结构的形式定义新的值类型，而基于JVM的语言中的值类型是固定的(byte、short、int、long、float、double、char、boolean)，尽管T2正在计划改变这一点。</string></int></p><h3>生产监控和异常处理</h3><p>尽管两者都包括异常处理方法，但两者之间的总体差异会影响与不同异常和错误监控工具的兼容性。这进而会影响故障排除策略和工作流程。</p><h2>性能和采用</h2><p>剑桥大学的Jeremy Singer在2003年进行了一项研究，研究了CLR和JVM之间的性能差异，发现至少在当时，它们的性能实际上是相同的。</p><p>研究发现，Java编译器生成的字节码更小，这可能会对VM性能产生影响。然而，当运行代码时，执行时间几乎是一半一半，CLR和JVM各有一半的时间执行得更快。基于这个研究，当谈到Java和。NET用户，看起来虚拟机本身在区分功能方面发挥的作用比它们直接影响应用程序效率的作用更大。</p><p>在考虑收养时，这也是有意义。在企业公司中，开发人员同时使用基于CLR和基于JVM的语言并不少见。这尤其可能发生在有许多不同部门从事不同项目和应用程序的大公司中。例如，埃森哲同时使用C#和Java，Intuit也是如此。</p><h2>社区</h2><p>说到竞争，我们知道。NET和Java都有强大的社区支持它们。在这些社区中，开发人员在StackOverflow这样的网站上提出问题并进行深入的讨论。快速搜索每个虚拟机的名称会发现，CLR被标记了3250次，而JVM被标记了8628次。</p><p>在StackOverflow之外，还有由微软和T2甲骨文自己开发的广泛的社区。在那里，用户可以找到除了CLR和JVM之外的其他信息和资源。其中的主题包括云中的实现、故障排除问题等等。<br/>然而，除此之外，这些社区肯定更多地围绕着个人语言和平台，比如<a href="https://twitter.com/dotnet">。NET </a>、<a href="https://twitter.com/java"> Java </a>、C/C++、Scala等。</p><h2>最后的想法</h2><p>从最高层次来看这些虚拟机，CLR和JVM之间的差异几乎可以忽略不计。然而，在许多(如果不是大多数)情况下，VM级别的差异反映了使用它们的语言之间的关键差异。由于这些虚拟机及其相应语言的构建方式，每个虚拟机的功能都略有不同，以便提供其创建者想要提供的功能。</p></div></div>    
</body>
</html>