# 如何使用线束连续交付|线束创建多阶段 Docker 构建

> 原文：<https://www.harness.io/blog/how-to-create-multi-stage-docker-builds-with-harness-continuous-delivery>

本教程解释了什么是多阶段 Docker 构建，以及它们如何帮助加速您的开发过程。

在软件开发和部署的快节奏世界中，每一分钟都很重要。对于简化您的过程来说，每一秒都很重要，因此您可以减少等待构建时间或其他滞后步骤所花费的时间。在尽可能高效地创建容器图像方面，有许多不同的技术。一种方法是使用 Docker 的多阶段构建，这有助于减小容器的大小。

当使用 Docker 管理软件构建和部署时，您希望确保尽一切可能简化过程，这样开发人员就不会陷入冗长的构建过程。这就是为什么多阶段构建是 Docker 的一个非常有用的特性。

本教程解释了什么是多阶段构建，以及它们如何帮助加速您的开发过程。但是首先，让我们探索更多可以从多阶段构建中获益的方法。

## 使用多阶段构建的好处

如果简化软件交付是你的目标之一，那么你一定要理解多阶段 Docker 是如何构建工作的。多阶段构建是简化映像创建过程并节省开发人员时间的好方法。

多阶段 Docker 构建的一个极好的好处是，它减少了映像中的依赖项和不必要的包的数量，减少了攻击面并提高了安全性。此外，通过只拥有在生产中运行应用程序所需的东西，它保持了构建的干净和精简。否则，开发人员最终都会构建和推送带有漏洞的大尺寸图像，这给攻击者提供了进入我们应用程序的简单途径。尝试使用多阶段 Docker 构建来优化映像和安全性。

以下是使用多阶段构建的一些其他优势:

*   优化 Docker 图像的整体大小
*   消除了为不同阶段创建多个 docker 文件的负担
*   易于调试特定的构建阶段
*   能够在新的环境中使用前一阶段作为新的阶段
*   能够使用缓存的图像使整个过程更快
*   随着多阶段构建使映像变得更小，降低了发现漏洞的风险

## 创建 Dockerfile 文件

容器允许您将应用程序与所有必要的部分打包在一起，比如库和其他依赖项，并作为一个包发送出去。整个应用程序可以转换成一个图像，并推送到 DockerHub 之类的图像注册中心。Docker 是一个容器化平台，允许开发者创建可移植的、自给自足的容器。Docker 构建过程从图像开始，这只是最终图像的基础层。这意味着映像只包含操作系统和执行命令所需的任何其他包。

Dockerfile 的主要目的是创建一个可以尽快部署的映像，并尽可能减少依赖性。Dockerfile 是一个简单的文本文档，包含创建 Docker 映像的所有命令和指令，它被编写为 Docker 要遵循的指令列表。

docker 文件以一个将另一个文件(称为基本映像)的内容复制到您的计算机上的指令开始。之后，您可以根据您正在使用的应用程序相应地添加您自己的定制。Docker 文件由 Docker 引擎读取，然后按顺序执行指令。

此过程的下一步是使用其他映像中的层或手动安装包向此基础层添加层。

您在上一步中创建的 Docker 文件详细指定了所有这些步骤，并且可以通过 Docker build 命令用作 Docker 构建过程的输入。Docker build 命令用于从 Docker 文件创建映像，并且可以与一个标记一起运行，以指定应该创建映像的哪个版本。

## 创建多阶段 Docker 构件

每个微服务都应该是一个独立的容器。如果你只使用单阶段的 Docker 构建，你就错过了构建过程的一些强大的特性。相比之下，在部署微服务方面，多阶段 Docker 构建比单阶段构建有许多优势。

多阶段构建是一个允许您将构建 Docker 映像的步骤分成多个阶段的过程。这将使您能够创建只包含最终应用程序所需功能所必需的依赖项的映像，从而节省时间和空间。对于多阶段构建，您将首先构建仅包含构建应用程序所需的依赖项的映像。然后，在构建映像之后，您可以添加创建应用程序所需的任何附加层，并为部署进行配置。这样，您可以只使用构建应用程序所需的代码来构建图像。这也是战略性地用于优化容器图像，使它们更小。

如上所述，多阶段构建允许您创建优化的 Docker 映像，并且只包含构建应用程序所需的依赖项。结合 Docker 的分层图像，这可以帮助您节省大量空间。多阶段过程节省了 Docker 主机和 Docker 映像中的空间，并加快了构建过程。此外，与包含构建应用程序所需的所有代码相比，这个过程会快得多。

创建两个 docker 文件(一个用于开发，一个用于生产)在 DevOps 世界中并不理想。这就是多阶段 Docker 构建派上用场的地方，因为我们可以为所有环境创建一个优化的 Docker 文件，无论是开发、试运行还是生产环境。

### Java 多阶段 Docker 构建示例

为了更好地理解多阶段 Docker 构建的概念，让我们考虑一个简单的 Java Hello World 应用程序。

在名为 HelloWorld.java 的文件中添加以下代码

###### HelloWorld 类{

###### 公共静态 void main(String[] a) {

###### System.out.println("Hello world！");

###### }

###### }

然后，创建一个 Dockerfile 文件，其中包含以下内容，

###### 来自 openjdk:11-jdk

###### 复制 HelloWorld.java。

###### 运行 javac HelloWorld.java

###### CMD java HelloWorld

使用以下命令构建映像，

###### 巨大的。

让我们用以下内容修改我们的 Docker 文件，以展示多阶段 Docker 构建是如何工作的。

###### 来自 openjdk:11-jdk AS build

###### 复制 HelloWorld.java。

###### 运行 javac HelloWorld.java

###### 从 openjdk:11-jre AS 运行

###### COPY-from =构建 HelloWorld.class。

###### CMD java HelloWorld

使用以下命令构建映像，

###### docker build -t helloworld:小型。

现在，让我们比较两张图片。检查用以下命令创建的图像，

###### docker 图像

‍

这两幅图像在尺寸上有很大的差别。这种差异允许您在同一个 Dockerfile 文件中分离构建和运行时环境。将生成环境用作依赖项[COPY-from = build hello world . class。]同时使用多阶段 docker 构建方法创建 docker 文件。这将有助于最小化 Docker 图像的大小。

### 节点。Js 多阶段 Docker 构建示例

我们先从一个简单的节点来学习。有一个基本 Dockerfile 文件的 Js 应用程序。

###### 从节点:14-阿尔卑斯山

###### 补充。/应用程序

###### 工作目录/应用程序

###### 复制 package.json。

###### 运行 npm 安装-生产

###### 收到。。

###### 曝光 3002

###### CMD [ "node "，" app.js" ]

让我们用下面的命令构建图像，

###### docker build -t [DockerHub 用户名]/图像名称:标签

使用命令将映像推送到 Docker Hub，

###### docker 推送[DockerHub 用户名]/图片名称:标签

我把图片推送到 DockerHub，下面是图片和尺寸，

现在，让我们尝试使用多阶段 Docker 构建的概念并修改我们现有的 Docker 文件。

###### 从节点:14-阿尔卑斯山作为基础

###### 补充。/应用程序

###### 工作目录/应用程序

###### 复制 package.json。

###### 运行 npm 安装

###### 来自阿尔卑斯山:最新

###### 复制自=阶段 1/应用程序/应用程序

###### 工作目录/应用程序

###### 曝光 3002

###### CMD [ "node "，" app.js" ]

让我们用上面使用的类似命令来构建和推送映像。只是要确保给这个图像取一个不同的名字。

现在，比较图像大小。一个是通常的 Docker 文件，大小为 48.81 MB，另一个是用多阶段 Docker 构建创建的，大小为 7.12 MB。由多阶段 Docker 构建方法创建的映像更加优化且更小。

另一个展示如何有效使用多阶段 Docker 构建的例子是一个场景，其中您为不同的环境剖析 Docker 文件。

一个普通的 docker 文件如下所示:

###### 从节点:14-阿尔卑斯山

###### 工作主管/服务代表

###### 复制 package.json 包-lock.json /src/

###### 运行 npm 安装-生产

###### 收到。/src

###### COPY . /src

###### 曝光 3000

###### EXPOSE 3000

###### CMD ["node "，" bin/www"]

###### 我们将从上面的 Dockerfile 文件创建三个简单的阶段。

***基础阶段*** :该阶段将与原始 Dockerfile 有共同之处

1.  ***生产阶段*** :这个阶段将包括对生产环境有用的东西
2.  ***开发阶段*** :这个阶段将拥有对开发环境有用的组件
3.  请参见下面修改后的 Dockerfile 文件:

从节点:14-阿尔卑斯山作为基础

###### 从节点:14-阿尔卑斯山作为基础

###### 工作主管/服务代表

###### 复制 package.json 包-lock.json /src/

###### 曝光 3000

###### EXPOSE 3000

###### 从生产基地开始

###### 环境节点 _ 环境=生产

###### 运行 npm ci

###### 收到。/src

###### CMD ["node "，" bin/www"]

###### CMD ["node", "bin/www"]

###### 从基础作为开发

###### 环境节点 _ 环境=开发

###### 运行 NPM install-g nodemon & & NPM install

###### 收到。/src

###### CMD ["nodemon "，" bin/www"]

###### 开始使用 Harness 部署应用程序

## [注册免费试用](https://app.harness.io/auth/#/signup/?utm_source=internal&utm_medium=social&utm_campaign=community&utm_content=replace&utm_term=get-started)装具，选择 **TryNextGen** 选项卡，体验无缝体验。

创建一个新项目并选择连续交付模块。首先创建一个新的管道，并添加管道所需的所有细节。

***注意:*** 为了让 Harness 发挥它的魔力，你需要一个叫做“代理”的东西在你的 Kubernetes 集群上运行。别担心，我们有一个简单的教程来帮助你[设置代表](https://docs.harness.io/article/2k7lnc7lvl-delegates-overview)。

接下来，为您的应用程序指定服务、基础设施和部署策略。设置好一切后，保存配置并运行以部署应用程序。

一旦管道成功运行，您应该看到您的应用程序部署在指定的 Kubernetes 集群上。这可以通过 kubectl 命令来验证:

kubectl 获取豆荚

###### ‘kubectl get pods'