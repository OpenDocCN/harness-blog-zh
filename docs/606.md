# C#与 Java: 5 个不可替代的 C#特性，我们非常想在 Java | Harness 中拥有

> 原文：<https://www.harness.io/blog/c-vs-java-5>

看看 C#中的一些我们希望在 Java 中看到的特性。

如果我们可以在 C#和 Java 之间取长补短，那会是什么样子？

完美的编程语言是不存在的。我希望我们能在这一点上达成一致，如果没有别的事情的话。新的语言通常是为了应对另一种语言的缺点而发展起来的，每种语言都不可避免地在某些方面更强，而在另一些方面更弱。

C#和 Java 都源于 C/C++语言，除了都是面向对象的之外，它们还有很多共同点。除了 Java 的 JVM 和 C#的. NET CLR 在结构上有一些相似之处之外，两者都在各自的道路上前进，各自的开发团队专注于语言应该是什么样的不同愿景。

我们不想迷失在语言孰优孰劣的争论中，我们只想概述一些 C#开发人员正在使用的特性，这些特性是 Java 所没有的。

让我们开始吧。

## 1.LINQ

LINQ(语言集成查询)在 2007 年被引入到 C#中，以帮助开发人员查询各种来源的数据。有了它，我们可以编写查询，而不需要考虑被调用的特定数据库的适当语法。LINQ 提供商 LINQ 的一个组件将查询转换成底层源可读的格式。例如，如果我们需要从 SQL 数据库中查询数据，LINQ 到 SQL 提供程序会将 LINQ 查询转换为 T-SQL，以便数据库能够理解它。

‍
在 LINQ 中执行查询操作，首先获取数据库，然后创建查询，最后执行查询。在 LINQ 到对象的查询中，这可以简单到只有一行代码，而不是编写复杂的嵌套 for each 循环的迭代。
‍

例如，让我们看看这段用 C#从列表中过滤 2 位数的代码。
首先，不使用 LINQ:

###### List<int>filtertwodigitnumbers withoutliq(List<int>numbers)
{
var tens = new List<int>()；

为(var I = 0；我<的数字。count()；i++)
{
if ((9 <数字[i]) & &(数字[i] < 100))
{
十进制。Add(数字[I])；
}
}
返回十位；
}</int></int>

然后在查询语法中使用 LINQ:

###### List<int>FilterTwoDigitNumbersWithLinq(List<int>numbers)
{
return(从 a in numbers
where(a>9&a<100)
select a)。to list()；
}</int></int>

和方法语法:

###### List<int>filternontwodigitnumbers with linq 2(List<int>numbers)
{
返回数字。其中(a =>a>9&a<100)。to list()；</int></int>

###### }

这里的两种语法都是正确的，唯一真正的区别是查询语法看起来更像 SQL，方法语法使用 lambda 表达式(因此，看起来像我们可能用 Java 编写的东西)。**底线:**LINQ 所依赖的许多特性，比如 lambdas，本身就很有用，并且已经有了用 Java 实现的等价物。因此，虽然我们*可以*使用 streams 和 lambdas 来查询数据，但 LINQ 简化了这个过程，去掉了 Java 中仍然存在的许多冗长。

## 2.结构体

C#中结构的用法类似于类。事实上，结构本身甚至可以被认为是一个“轻量级类”，因为它可以包含构造函数、常数、方法等等。结构和类的最大区别是结构是值类型，而类是引用类型。与创建类相比，编写结构的最大好处是，构造值类型比构造引用类型更容易确保值语义。正如微软的[文档](https://msdn.microsoft.com/en-us/library/aa664472(v=vs.71).aspx)中所说，“结构类型的变量直接包含结构的数据，而类类型的变量包含对数据的引用。”因此，在类上使用 struct 的好处之一是，从代码的其他部分改变它的值的唯一方法是显式地将它作为引用传递。

微软[的‍
开发者建议](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct)只对小于 16 字节、不可变、短命且不频繁装箱的类型使用 struct 代替 class。在这些情况下，使用结构也可能比使用类更有效，因为它更可能存储在堆栈中而不是堆中。
‍

‍举例

###### 公共结构点
{
public int X；
public int Y；

公点(int X，int Y)
{
此。X = X
这个。Y = Y
}

公共静态点运算符+(点 p1，点 p2)
{
返回新点(p1。X + p2。x，p1。Y + p2。y)；
}

公共覆盖字符串 ToString()
{
return($ "({ X }，{ Y })")；
}
}
类程序
{
静态 void Main(string[]args)
{
Point Point 1 =新点(1，5)；
点 point2 =新点(2，3)；

控制台。WriteLine("两点相加将得到:{0} "，(point 1+point 2))；
控制台
。read key()；
}
}

‍ **底线:**在许多情况下，写一个结构似乎可以节省内存分配和释放的时间，因此更有吸引力。然而，事实是，值类型存储在它们被拥有的任何地方。不管使用结构有什么明显的好处或坏处，当涉及到 Java 时，我们都不必担心这些。

## 3.异步/等待

通过在代码部分调用 async，或者更具体地说，在方法上调用 async，该方法将在单独的线程上执行，从而不会阻塞当前线程。当代码到达 await 命令时，它将继续运行。如果到那时，异步代码还没有完成，那么执行将返回到它的调用方法。

‍
这有助于提高应用程序的整体响应能力，并有助于减少性能瓶颈。当应用程序试图访问 web 和所有与 UI 相关的活动时，使用异步编程是非常重要的。与以前实现异步编程的技术相比，async/await 的使用保留了代码的逻辑结构，编译器完成了过去需要开发人员完成的繁重工作。
‍

示例:

###### 类程序
{
公共静态 void Main()
{控制台。WriteLine("嘿，大卫，98745 除以 7 是多少？");

任务<int>David = think about it()；

控制台。WriteLine(“在他思考的时候，让我们聊一会儿天气。”);
控制台。WriteLine("你认为明天会下雨吗？");
控制台。WriteLine(“不，我觉得应该是晴天。”);

大卫。wait()；var davidsAnswer = david。结果；

控制台。WriteLine($ " David:{ davidsAnswer } ")；

控制台。read key()；
}

私有静态异步任务<int>think about it()
{
await ReadTheManual()；

控制台。WriteLine(“我想我明白了。”);

返回(98745/7)；
}

私有静态异步任务 ReadTheManual()
{
string file = @ " D:\ howtocalc . txt "；

控制台。WriteLine("阅读手册。");

使用(StreamReader reader = new StreamReader(file))
{

###### string text =等待读者。ReadToEndAsync()；
}
控制台。WriteLine(“完成。”);
}
}

输出:

###### //可能输出:

嘿大卫，98745 除以 7 是多少？
阅读手册。在他思考的时候，我们聊一会儿天气。
你认为明天会下雨吗？不，我想应该是晴天。
搞定。我想我明白了。大卫:14106

‍ **底线:** CompletableFutures 无疑让我们更接近于在 C#和 Java 中拥有同等的异步编程能力。尽管如此，使用它的复杂性使得它无法与 async/await 关键字实现的简易性相媲美。

## 4.懒惰的<t>类</t>

无论是用 C#还是用 Java，我们中的许多人都实现了惰性初始化(或实例化),这样直到第一次使用一个对象时才创建它。使用惰性初始化的一个更常见的情况是，应用程序在启动时加载了许多对象，但最初只需要其中的几个。在这种情况下，我们希望指示不必要的对象仅在需要提高应用程序性能时进行初始化。
**底线:**在 Java 8 中引入 lambda 表达式后，最近在 Java 中实现惰性初始化变得容易多了(许多其他事情也是如此)。尽管如此，在 C#中我们可以使用 Lazy < T >包装类，它为任何类库或用户指定的类型提供了惰性初始化的语义。

## 5.一些关键词等价

语言中有用的特性不必像在 C#中实现 LINQ 或在 Java 中实现模块那样大。这里有一些帮助 C#开发人员的关键字，是 Java 中没有的:

### a.如同

C#中的关键字 *as* 试图将一个对象安全转换为一种类型，如果不能，它将返回 null。Java 的 *instanceof* 几乎是可比较的，但是它是一个布尔值，如果类型匹配就返回 true，如果不匹配就返回 false。

### b.产量

在 C#中使用 *Yield* 和 *return yield* 来执行自定义和有状态迭代，而不需要显式的额外类，也不需要创建临时集合。用 Java 实现迭代的最佳选择似乎是访问外部库或使用 Java 8 中引入的 lambdas。

### c.在哪里

V *ar* 是由编译器确定的隐式类型，功能上等同于写显式类型(即 *int* 、 *string* 等)。).除了节省一些额外的击键次数， *var* 允许匿名类型，这是 LINQ 查询中最常用的。我们[期待看到一个“var”标识符](http://blog.overops.com/java-community-survey-results-74-of-developers-want-less-verbosity/)在新期待的 Java 10 中实现，它将“扩展类型推理到带有初始化器的局部变量的声明”

### d.检查

在 C#中，我们使用 *checked* 关键字来显式启用整型表达式的溢出检查。如果某个表达式的结果值超出了目标类型的范围，我们可以使用 *checked* 来强制运行时抛出 OverflowException。这很有帮助，因为默认情况下，常量表达式在编译时有溢出检查，而非常量表达式没有。

## 工具生态系统

当然，Java 和 C#之间还有很多不同之处，其中一些根源在于 Java 和。NET 框架。有了这些差异，提供生产监控和错误跟踪的有用工具的兼容性也会出现差异。

‍
其中一个工具是，为开发人员显示完整的源代码和整个调用栈中每个生产错误的变量状态。它目前支持基于 JVM 的语言。NET 框架兼容性将在未来几个月内实现。

## 最后的想法

说到底，我们在这里提到的大多数特性在代码的长度和清晰度方面给了 C#开发人员优势，而不是让他们能够编写不能用 Java 编写的代码。通过在最近的版本更新中加入 lambda 表达式，至少部分地解决了使 Java 成为一种更冗长的语言的大部分问题。尽管如此，我们在 C#中发现的而在 Java 中没有的许多特性简化了常见用例的语法，超出了 lambdas 所提供的。

‍:再说一次，我们不想卷入关于哪种语言更好的无休止的争论，我们只是在这里指出两者之间的一些差异。我们错过了 Java 中你想拥有的特性吗？请在评论中告诉我们！

‍