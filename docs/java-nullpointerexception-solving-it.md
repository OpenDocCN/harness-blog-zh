# 如何解决 Java NullPointerException | Harness

> 原文：<https://www.harness.io/blog/java-nullpointerexception-solving-it>

在这篇文章中，我们强调了单独依靠堆栈跟踪来研究 Java NullPointerExceptions 的缺点。

如果你曾经因为一个例外而沮丧过，那你就来对地方了。

在这篇文章中，我们强调了单独依靠堆栈跟踪来研究 Java NullPointerExceptions 的缺点。虽然您得到了抛出异常的行，但是知道它是否是新的，为什么会发生，以及是谁引入了导致它的变化是完全不同的事情。

我们走吧。

## 典型的 NullPointerException 解决工作流

虽然我们在这里讨论的问题并不仅限于 NullPointerExceptions，但是它提供了一个很好的简单例子。毕竟，它们是 Java 生产环境中最常见的异常。

让我们假设刚刚发生了一个 NullPointerException，您是如何意识到它的呢？

*   最糟糕的情况——你的客户受到了负面影响，你的团队通过愤怒的推文意识到了这一点。
*   最好的情况是——它未能通过您的一项测试，您可以阻止它进入生产环境。
*   常见的情况是，例外时有发生，但你不知道它们是新的还是关键的。

出于本练习的目的，让我们假设我们手中有一个异常，我们的任务是解决它，所以识别是不可能的(目前)。调查阶段的起点通常是应用程序日志和异常对应的堆栈跟踪。也有可能这个异常没有被记录——我们喜欢称之为 Java 应用程序的无声杀手。

让我们来看看最好的情况，假设确实记录了异常:

###### Java。郎。nullpointerexception:com 上的 null
。火花故事。可怕的故事。服务器。app。servlet。计费。getuserbillingservlet。内部工作(getuserbillingservlet。Java:64)
at com。火花故事。可怕的故事。服务器。app。servlet。计费。getuserbillingservlet。class:na
at com【Tomcat-redis-session-manager-1.2 .jar:na]
at org。阿帕奇。卡特琳娜。核心。标准主阀。调用(标准主机阀。Java:171)
at org。阿帕奇。卡特琳娜。阀门。错误报告阀。调用(errorreportvalve。Java:99)【卡特琳娜。罐子:7。
0.42 ch。服务质量。返回日志。访问。雄猫。对数回流阀。调用(invoke

现在，让我们清除干扰，去掉第三方代码，以获得最相关的信息:

###### Java。郎。nullpointerexception:com 上的 null
。火花故事。可怕的故事。服务器。app。servlet。计费。getuserbillingservlet。内部工作(getuserbillingservlet。Java:64)
at com。火花故事。可怕的故事。服务器。app。servlet。计费。getuserbillingservlet。【班娜】
看着通讯器

我们看到在 GetUserBillingServlet 类的第 64 行有一个 NullPointerException。

当我们跟踪和检查代码时，有两种可能的情况。调试的蛇和梯子:

您在 c:\ users \ app data \ roaming \ gold Berg steamemu saves \ settings 的路径中尝试过了吗

###### if(user . is customer()){
…
}
“用户”对象绝对是麻烦的源头。

**2。墨菲定律。**如果事情会出错，它就会出错。考虑下面的 if 语句:

###### 如果(用户。是客户()& &帐户。equals(id)){
...
}

现在我们不确定是“用户”还是“帐户”为空，我们被困住了。

让我们看看一些可能的解决方案，这将有助于我们推进调查。

## 解决方案 1:分解复杂的代码行

在上面的例子中，if 语句可以分解为:

###### 如果(用户。是客户()& &
的账户。equals(id)){
...
}

堆栈跟踪将包括适当的行号，并让我们更快地前进。这也是为什么在流上拆分聚合操作是一个好的实践。

事实上，一些风格指南为了可读性问题也坚持同样的原则。看看这篇文章，我们比较了 Google、Twitter 和 Mozilla(以及 Pied Piper)等公司的 Java 风格指南。

## 解决方案 2:更多的空检查

这可能是最显而易见的解决方案，检查空值并确保没有流氓值传递到关键区域。充满空支票的代码并不好看，但有时这是不可避免的。

在之前一篇关于 JVM JIT 优化技术的文章中，我们详细阐述了 JVM 如何利用公共陷阱机制来解决可能影响性能的冗余空检查。

## 解决方案#3:更详细的日志记录

如果有异常，通常会有一个包含额外提示的日志消息。它是否会包含有用的信息是另一回事。

下一步可能是向消息中添加信息，或者添加额外的日志语句，这将有助于了解…爆炸的路径。这就产生了调试悖论——希望错误再次发生，让它不再发生。

关于大规模调试生产服务器的其他方法，请查看高可伸缩性博客上的这篇文章(对于任何与大规模系统相关的内容来说，这都是一个很好的资源)。

## 解决方案 4:采用持续的可靠性思维

提高代码质量和确保应用程序的可靠性是很难解决的问题。为了使事情变得简单，我们在这篇文章中做了一些假设，但是正如你所知道的，应用程序错误在现实中是一个更加复杂的问题。

持续可靠性(CR)有助于定义一种新的方法来确保持续集成(CI)和持续交付(CD)管道中的软件质量。通过引入基于质量关口、应用程序可观察性和上下文反馈循环的识别和解决关键软件问题的结构化实践，帮助促进“左移”、“右移”和开发人员生产力计划。

在 OverOps，我们专注于在关键任务 Java 和范围内实现持续可靠性的愿景。基于. NET 的应用。每当出现异常、记录的错误或警告时，OverOps 会捕获并分析它，帮助确定其优先级，并提供一个快照，显示从导致错误的代码出现时起的完整变量状态。

这样，无论问题是什么，识别、区分优先级和解决问题只需几分钟:

## Java NullPointerException 分析

NullPointerExceptions 不会很快消失。这就是为什么有一个好的策略来识别、优先处理和解决这些问题是至关重要的！