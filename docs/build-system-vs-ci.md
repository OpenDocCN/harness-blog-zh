# 构建系统与 CI 系统(持续集成)|管理

> 原文：<https://www.harness.io/blog/build-system-vs-ci>

什么是构建系统？构建系统和 CI 有什么不同？在本文中，我们解释“构建系统与 CI”的问题。

## 先来点历史吧，年轻人

我个人将构建系统等同于[持续集成](https://www.harness.io/products/continuous-integration)系统。至少现在我是这样做的。20 年前我可能不会。毕竟，我们是在比较同一枚硬币的两面；这个问题一直存在于软件开发中！开玩笑的。“构建系统”一词在 60 年代左右开始在英语文学中流行:

大约在那个时候，软件开始成为一种东西，大型机正在公司总部用起重机安装起来！没有客户喜欢与软件互动。CD 管道只是一个梦想，没有人谈论交付时间，部署步骤，甚至发布。

Dave Farley，Jez Humble，Nicole Forsgren 博士，以及所有改变了我们对 CD 工具和 CD 过程的看法的领军人物甚至还没有出生。软件开发实践是一门正在发展的手艺，然后编译器、传输器和当时所有狂热的技术被创造出来。至少，构建工具的最初版本最终会是什么样子。

但是后来，新的东西出现了。版本控制可能是任何人的开发环境中最好的新事物。根据 Google 的说法，持续集成可以说是软件开发中第二个达到一定成熟度的类别。应用程序正在成为任何组织中的一等公民，开放源码正在爆炸，构建服务器正在成为一个彻底的烦恼。因此，我们有了现代/成熟的 CI 系统来强化软件开发过程，使之与之前的手工过程自动化。

## 这不是 NIST 的定义，但是我们开始了:构建系统 vs CI

我们想要探索两个术语，对许多人来说，它们是同义词——然而，这场辩论的实际意义并不在于它们是否表示相同的东西，而是在于开发人员想要如何使用它们。

划分这两个概念的界限是，构建系统指的是通常在开发人员的机器上本地运行的工具(或一组工具)。持续集成，虽然最初只是一个后台运行的守护进程，轮询源代码回购以寻找变化来触发一个过程，但现在大致等同于一组最佳实践，开发人员通过这些实践经常将代码变化合并到一个中央存储库中，在那里自动构建和测试运行。我们不会用这个来烦你，但是如果你想了解持续集成的好处和什么是 CI，我们有一篇文章给你。

有趣的是，一如既往，在细节上。构建系统背后的细微差别是开发人员倾向于的隔离。我这样说并没有经过任何判断:编码需要高度的抽象和大量的注意力和集中，当一台机器被微调到开发人员的愿望时，这可以得到更好的满足。主分支、特征分支、配置文件等。有很多事要处理。在本地，所有的依赖关系都得到了很好的控制，IDE 针对开发人员最喜欢的特定工作流进行了个性化，等等。但是，这项工作，即使在其生产力的顶峰，也只会以快速构建而不是少量集成而告终，这最终会在企业级开发团队中引发合并冲突。这不是任何公司想要的编码哲学，因为沟通速度和集成频率太慢，并且容易与较长的解决周期发生冲突。

这正是 CI 成为持续交付(CD)方法中如此成功的一部分的原因。这个概念由 Kent Beck 在 [Xtreme programming](https://en.wikipedia.org/wiki/Extreme_programming) 中倡导，由 Martin Fowler 在 2000 年的一篇[文章中推广，后来在 2006 年](https://www.martinfowler.com/articles/originalContinuousIntegration.html)[修订和更新](https://www.martinfowler.com/articles/continuousIntegration.html)，在 [Cruise Control](http://cruisecontrol.sourceforge.net/) 的 CI 工具中首次实现(由 Thoughtworks 开发)。

构建系统仍然是任何 CI 系统的核心，但是现代 CI 系统不鼓励持续的构建、偶尔的集成(CBOI)实践，并鼓励协作、频繁的集成、持续的代码评审和许多最佳实践，这些最终有利于软件质量、安全性、开发团队的速度和信任。CI 的美妙之处在于，系统(或者至少是开发人员确信更改不会破坏任何东西(即他们的微服务)的必要部分)可以完全旋转起来，与更改集成，并运行语法、测试、扫描器等，以向用户返回一个完整性检查来交付工件。

最终，差异归结为积分位。持续的方法指的是系统的特征，即处于运行一个过程的准备就绪的恒定状态(想想:每天的小变化，或每天多次，与每周或每月相对)。但是整合到底意味着什么呢？最浅显的定义将包括运行集成测试。也就是说，知道来自不同团队或个人的代码是否破坏了代码库本身要交付的整体功能的能力。这种情况下的集成还包括高级语法检查、林挺和某种静态代码分析。

## 开门见山:为什么这很重要？

无论您有一个构建系统还是 CI 系统，或者您是否真正通过 CI(或者更可能是 CBOI)进行持续部署，都是无关紧要的。作为创作者，开发者希望专注于他们的工作。为了实现这一点，他们需要一个管道:无论是在本地运行还是在公共云实例中与团队成员共享，都可以在需要时立即方便地提供。

配置需要以自助的方式民主化——甚至完全抽象化。像 Jenkins 这样的传统 CI 系统在这一点上失败了，让开发人员和构建工程师超负荷地使用大量 Groovy 代码，这些代码像旧的守护程序那样查看更改的目录或存储库。你可以阅读我们关于 Jenkins 的[依赖/集成地狱](https://harness.io/blog/continuous-delivery/dependency-plugin-hell-jenkins/)的文章，了解更多关于这方面的想法。

总之，这在大型组织中无法扩展，因为在大型组织中，许多工程师必须编辑这些文件，回购结构很复杂，并且管理和访问所述知识产权对他们的业务至关重要。相反，CI 位于现代软件开发团队想要的核心:一个平台，意味着云原生设置之上的层，允许开发人员设置基线管道，开发人员自助服务他们需要的 it。

CBOI 也是某种更大事物的征兆，这种事物超出了工程师独立工作的自然习惯。让整个系统运转起来，并让它通过所有必要的检查和扫描，并不是每个基础设施都能胜任的。队列和缓慢的构建/缓慢的软件交付过程将是最常见的结果。但是，即使可行，每次运行完整的系统及其测试的经济权衡是极其昂贵的。如果你用你的新特性实践好的旧 TDD，你的测试套件只会增加，你的构建过程会变得更大。在软件构建场中运行新代码将变得更加昂贵(这与降低成本的所有尝试背道而驰)，不管它是在本地环境中运行还是在公共云中运行。我们敢说，计算、网络和存储费用将会变得非常昂贵。

Chonky build cat likes to eat tests and tests!

因此，竞争情报也是从重复的模式中学习。毕竟，CI 管道是一种一遍又一遍重复的东西，大部分时间只进行增量更改，最终，最少的更改进入生产环境。QA 团队和他们的测试环境已经超负荷了，最好的 CI 系统包括智能功能，能够只检测什么发生了变化，并对代码子集应用所需的测试。

## 结论

最终，团队意识到要走的路是安顿下来并维护适当的开发人员体验。您的开发人员是在他们自己的构建系统中本地运行所有东西，还是通过共享的 [CI 服务器](https://www.harness.io/products/cloud-cost)进行协作，这可能不是实际问题。

正如[这篇论文指出的](https://www.researchgate.net/publication/320088580_Continuous_Integration_is_Not_About_Build_Systems)，开发者想要产生影响。他们希望自己的努力有助于解决问题。为此，他们使用的系统需要提供反馈，说明他们的贡献是如何交付给最终用户的。正是这种反馈机制提供的信心真正鼓励了开发人员变得更有能力并达到速度。引用这篇研究文章，“如果交付过程很耗时，如果交付太复杂，或者如果经常向主线交付没有明显的价值，开发人员将会减少交付频率。”

这就是为什么马具是这样建造的。除了别的以外，提供一个稳定的开发者体验。它缩短了代码提交到代码验证和更新之间的反馈循环的长度。考虑到这一点，Harness 的工程师和设计师正在构建一个 CI/CD 平台(加上功能标志、云成本管理和其他产品),以增强开发人员的信心并抽象复杂性，同时降低风险。我们很想邀请您今天来[试驾](https://app.harness.io/auth/#/signup)。

如果你还没有准备好冒险一试，请继续你的阅读之旅，阅读关于[最佳 CI 工具](https://harness.io/blog/continuous-integration/continuous-integration-tools/)的内容，或者简单地了解更多关于 [Harness 持续集成平台](https://harness.io/products/continuous-integration)的内容。