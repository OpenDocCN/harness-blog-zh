# 超级 jstack:如何以 100 英里/小时的速度调试你的服务器

> 原文：<https://www.harness.io/blog/supercharged-jstack-debug-your-servers>

使用 Jstack 调试您的生活 Java 生产服务器。

**使用 jstack 调试 Java 生产服务器的指南**

jstack 就像 U2 一样——它从一开始就伴随着我们，我们似乎无法摆脱它。玩笑归玩笑，jstack 是目前为止你的武器库中调试一个现场生产服务器最方便的工具之一。即便如此，我仍然觉得它在事情变糟时把你从火中拉出来的能力远远没有得到充分利用，所以我想分享一些方法，让你在对抗生产 bug 的战争中成为更强大的武器。

jstack 的核心是一个超级简单的工具，可以向您显示在目标 JVM 中运行的所有 Java 线程的堆栈跟踪。只需通过 pid 将它指向一个 JVM 进程，并获得当时所有线程堆栈跟踪的打印输出。这使您能够回答“这个服务器在做什么？”这个古老的问题，并让您更进一步了解它为什么会这样做。jstack 最大的优点是它是轻量级的——它不会给 JVM 增加任何性能开销，也不会改变它的执行状态(不像调试器或分析器)。

‍
因为没有什么是完美的，jstack 有两个明显的缺点。首先，jstack 除了调用堆栈之外，不提供任何可变状态，这意味着当您查看一个堆栈时，您不知道是什么状态让它出现在那里。一个很好的例子是查看一个挂起的 JVM，其中 jstack 会向您显示大量线程正在执行 DB 查询或等待获得连接。

‍
这可能意味着一些查询执行时间过长，导致其他线程要么等待连接，要么被拒绝连接。在这种情况下，您很想知道哪个查询正在执行(或者它的参数是什么)导致了速度变慢，以及它是何时开始的。当然，这只是众多场景中的一个例子，在这些场景中，一些线程被阻塞并降低了应用程序的吞吐量。但是不幸的是，对于 jstack，你没有得到任何可变的状态——你真的不知道是哪个线程出了问题。

‍
j stack 的第二个缺点是它不是一个永远在线的工具。这意味着当问题发生时，你必须在现场，这在生产中是很少发生的。在虚拟机不断重启的弹性环境中更是如此。
精彩的部分来了——让我们来看看两种技术，它们可以帮助我们克服这两个缺点，让一个好的工具变得真正伟大。

## 创建有状态线程数据

第一个问题是如何将状态添加到 jstack 打印输出中？答案简单而强大——线程名。虽然许多人错误地认为线程名是不可变的，或者是由操作系统决定的属性，但实际上它是每个线程都具有的一个可变且极其重要的特征。它也是进入 jstack 流的一个元素，这就是关键所在。

‍
实际应用就像日志一样，一旦线程通过一个入口点(比如 servlet、actor 或 scheduler)进入你的代码，你就应该控制它的名字。此时，您需要将其名称设置为一个有意义的值，以帮助您理解执行上下文和相关参数，从而帮助您隔离事务及其内容。

‍
这最有可能包括-
1。线程的目的(例如，处理消息、响应用户请求等..).
2。事务 ID，它将使您能够跨不同的机器和应用程序的不同部分识别这个特定的数据流。
3。参数值，如 servlet 参数或正在出列的消息的 ID。
4。您获得线程控制权的时间。当您使用 jstack 来观察代码中的哪些线程被阻塞时，最后一项对您来说非常重要。

###### ‍
【Java】
thread . current thread()。集合名称(上下文+ TID +参数+当前时间，..);
[/java]

‍
这些数据将意味着查看打印输出(如下图所示，它实际上并没有告诉我们线程正在做什么或为什么做)和提供信息的打印输出之间的差异:
***" pool-1-thread-1 " # 17 prio = 5 OS _ prio = 31 tid = 0x 00007 f9d 620 c 9800 NID = 0x6d 03 in object . wait()[0x 000000013 ebcc 00]***
将此与

你现在看到的是这个线程实际上在做什么的更全面的解释。您可以很容易地从 AWS 队列中看到它的出队消息、它正在分析的消息、它的类型、ID 和事务 ID。最后，但绝不是最不重要的——线程什么时候开始处理它的。这可以帮助您快速关注那些被阻塞的线程，并了解它们所处的状态。从那以后，本地优化和复制就变得容易多了。

‍
这里的另一种选择是希望日志文件中有数据，并且能够将日志中的数据与这个线程相关联。另一种选择是在生产环境中本地或远程附加一个调试器。两者都不令人愉快且耗时。

‍
在线程名中写入这些信息也有助于传统的日志记录。尽管大多数日志框架都提供了可以添加到日志中的基于线程的上下文，但是您必须确保配置正确。使用线程名还可以确保日志中包含您需要的所有数据。
注意:有些人可能会说线程名称是不可修改的。从我多年来从事这项工作的个人经验和许多同事的经验来看，我对此深信不疑。

## 使 jstack 始终开启

我们在使用 jstack 时面临的第二个挑战是，就像调试器一样，它是一个工具，当问题发生时，您必须手动操作它来捕获损坏的状态。然而，当服务器挂起或低于或高于某个阈值时，有一种更主动的方法可以使用 jstack 自动生成打印输出。关键是只要满足特定的应用程序条件，就像在 JVM 中调用任何日志功能一样，以编程方式调用 jstack。这里的两个关键挑战是何时以及如何去做。

## 如何编程激活 jstack？

由于 jstack 是一个普通的操作系统进程，调用它相当简单。你要做的就是激活 jstack 进程，指向自己。这里的难点是如何从 JVM 中获取进程的 pid。实际上没有标准的 Java API 来做这件事(至少在 Java 9 之前没有)。下面是完成这项工作的一小段代码(虽然不是 api 文档的一部分):

###### ‍
【Java】
string MX name = management factory . getruntimemxbean()。getName()；
int index = mxname . index of(PID _ SEPERATOR)；
字符串结果；
如果(索引！=-1){
result = MX name . substring(0，index)；
} else {
抛出新的 IllegalStateException("无法使用"+ mxName "获取 pid
}
[/java]

‍
另一个小挑战是将 jstack 输出导入你的日志。使用输出流 gobblers 也很容易设置。请看[这里](https://github.com/takipi/jstack/blob/master/src/preemptiveJstack/ProcessInterface.java)的一个例子，关于如何将你调用的进程输出的数据导入你的日志文件或输出流。

‍
虽然有可能使用 [getAllStackTraces](http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#getAllStackTraces()) 在内部捕获正在运行的线程的堆栈跟踪，但出于多种原因，我更喜欢通过运行 jstack 来实现。首先，这是我通常希望在运行的应用程序外部发生的事情(即使 JVM 参与提供信息),以确保我不会通过进行内省调用来影响应用程序的稳定性。另一个原因是 jstack 的功能更强大，比如向您显示本机框架和锁状态，这是 JVM 中所没有的。

## 什么时候激活 jstack？

您需要做出的第二个决定是，在什么条件下您希望 JVM 记录一个 jstack。这可能会在服务器低于或高于特定处理(即请求或消息处理)阈值的预热阶段之后完成。您可能还想确保每次激活之间有足够的时间；只是为了确保您不会在低负载或高负载下淹没日志。这里使用的模式是从 JVM 中加载一个 watchdog 线程，它可以定期查看应用程序的吞吐量状态(例如，在过去两分钟内处理的消息数量),并决定线程状态的“截图”是否有用，如果有用，它将激活 jstack 并将其记录到文件中。

‍
设置这个线程的名字来包含目标和实际的吞吐量状态，这样当你拍摄一个自动 jstack 快照时，你可以确切地看到为什么看门狗线程决定这样做。由于这种情况每隔几分钟就会发生一次，因此该过程不会产生真正的性能开销——尤其是与所提供的数据质量相比。

‍
下面是展示这种模式的一个片段。startScheduleTask 加载一个看门狗线程来定期检查吞吐量值，每当处理一个消息时，该值就会使用 Java 8 并发加法器递增。

###### ‍
【Java】
public void startscheduletask(){
scheduler . scheduleatfixedrate(new runnable(){
public void run(){
check throughput()；
}
}，APP_WARMUP，POLLING_CYCLE，TimeUnit。秒)；
}
private void check throughput()
{
int throughput = adder . int value()；//处理一条消息时的加法器 INCD
if(THROUGHPUT<MIN _ THROUGHPUT){
thread . current thread()。setName(" Throughput jstack thread:"+Throughput)；
System.err.println("最小吞吐量失败:执行 jstack ")；
executeJstack()；//查看 github 上的代码，看看这是怎么做到的
}
adder . reset()；
}
[/java]

‍
从你的代码中抢先调用 jstack 的完整源代码可以在[这里](https://github.com/takipi/jstack)找到。