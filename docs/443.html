<html>
<head>
<title>Harness Infrastructure Provisioners and ARM Templates - Part 2 | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>线束基础设施供应器和 ARM 模板-第 2 部分|线束</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/harness-infrastructure-provisioners-and-arm-templates-part-2#0001-01-01">https://www.harness.io/blog/harness-infrastructure-provisioners-and-arm-templates-part-2#0001-01-01</a></blockquote><div><p>在这个系列的第二部分，也是最后一部分，我们将学习如何使用 Harness 变量来模板化你的 ARM 模板，以及 Harness 如何提供回滚，而 Azure 没有。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>在本系列的第<a href="https://harness.io/blog/continuous-delivery/arm-templates-pt1/">部分，我们学习了如何使用线束供应器部署 ARM 模板。我们还学习了 Azure ARM 的基础知识，并且讨论了在部署 ARM 模板时，Harness 服务如何相互通信。我会推荐你通过</a><a href="https://harness.io/blog/continuous-delivery/arm-templates-pt1/">阅读第一篇博客</a>来重温这个信息。</p><p>在这个系列的第二部分也是最后一部分，我们将学习如何使用 Harness 变量来模板化你的 ARM 模板，以及 Harness 如何提供回滚，而 Azure 没有。</p><h2>ARM 模板中的线束变量</h2><p>假设我们想为不同的微服务，比如订单服务、支付服务、用户服务等，创建一个不同的 Azure web app。我们可以有一个 ARM 模板，web 应用程序的名称可以定义为一个参数。<br/> <br/> ARM 模板 web app 创建部分:</p><p>{ <br/> "apiVersion": "2016-08-01 "，<br/> "type": "Microsoft.Web/sites "，<br/>" name ":"[parameters(' siteName ')]"，<br/> "location": "[resourceGroup()。位置]"，<br/>"属性":{<br/>" site config ":{<br/>" name ":"[参数(' siteName')]"，<br/>" appSettings ":[<br/>{<br/>" name ":" WEBSITES _ ENABLE _ APP _ SERVICE _ STORAGE "，<br/> "value": "false" <br/> } <br/>，<br/>" linuxfxv version ":" DOCKER | nginx:alpine "<br/>}，【location "Web/serverfarms '，变量(' service planname ')]"<br/>}，<br/>" depends on ":[<br/>"[resourceId(' Microsoft .Web/serverfarms '，变量(' service planname ')]"<br/>]<br/>}</p><p><br/>如你所见，名称被定义为<em>" name ":"[parameters(' siteName ')]"</em><br/><br/>参数文件会是这样的:<br/> <br/></p><figure class="w-richtext-figure-type-image w-richtext-align-center"/><p>现在，对于每个微服务，我们需要这些参数文件:<br/></p><figure class="w-richtext-figure-type-image w-richtext-align-center"/><p>想象一下拥有 30-50 个微服务:你需要维护所有这些文件，这很容易成为可维护性问题。它就是不可扩展。<br/> <br/>通过使用线束变量，你可以把这个负担减少到只有一个参数文件。用户可以在他们的 ARM 模板中利用内置变量，如服务、环境、秘密和工作流。查看我们关于<a href="https://docs.harness.io/article/aza65y4af6-built-in-variables-list">内置变量</a>的官方文档了解更多细节。<br/> <br/> Harness 在向代理发送手臂展开请求之前解析所有这些变量。这是 Harness 提供的一个强大的工具，可以在 ARM 参数之上模板化您的 ARM 模板。<br/> <br/>您也可以将参数文件中的参数定义为工作流变量，在部署时，您可以将它们的值提供为 OrderService、PaymentService 等。<br/> <br/></p><figure class="w-richtext-figure-type-image w-richtext-align-center"/><p><br/>在部署期间，您可以提供这些变量的值。您可以创建一个具有多个阶段的管道，数量与您要部署的微服务一样多，并且您可以使用相同的工作流并提供不同的运行时值。</p><p>支付服务第一阶段-webapp: <br/> <br/></p><figure class="w-richtext-figure-type-image w-richtext-align-center"/><p>订单服务-webapp 的第 2 阶段:</p><figure class="w-richtext-figure-type-image w-richtext-align-center"/><p><br/></p><p>在 Azure 门户上，你将能够看到不同的 web 应用程序是使用相同的 ARM 模板和参数文件创建的。</p><figure class="w-richtext-figure-type- "/><h2>Harness 如何为 ARM 部署提供回滚支持？</h2><p>在 ARM 部署期间，我们需要处理以下场景的故障:</p><ul role="list"><li>如果从 Git 下载 ARM 模板时出现问题。</li><li>如果在处理 ARM 模板时出现问题。</li><li>如果在 ARM 部署开始后 Azure 端出现故障。</li></ul><p>对于第一点和第二点，我们不需要做任何事情，因为部署尚未开始。对于第三点，Harness 执行回滚。让我们来探究一下是如何做到的。</p><p>假设您有一个资源组(姑且称之为 RG1 ),它有两个资源，R1 和 R2。假设您正在尝试使用 RG1 中的 ARM 模板以增量模式部署额外的资源(R3、R4)。R3 创建成功，但在创建 R4 时，出现了问题。理想情况下，您应该能够回到以前的状态(在这种情况下，只有两个资源:R1 和 R2)。然而，Azure 让您的部署保持原样，而不是回滚。现在 RG1 中有了 R1，R2 和 R3。这是因为 Azure 本身不支持回滚。</p><p><br/></p><figure class="w-richtext-figure-type-image w-richtext-align-center"/><p><br/> <br/> Harness 通过在对现有基础设施进行任何更改之前保存资源组的当前状态，克服了 Azure 的局限性。在回滚过程中，现有模板以<strong> COMPLETE </strong>模式部署，这样可以确保只部署模板中提到的资源。例如，任何新部署的都将被删除。</p><p>这里有一个在你开始手臂展开之前会发生什么的图表:<br/> <br/></p><figure class="w-richtext-figure-type-image w-richtext-align-center"/><p><br/></p><ul role="list"><li>管理器服务发送启动 ARM 部署的请求。</li><li>委托向 Azure 发送请求，为现有资源组生成模板。</li><li>Azure 将 ARM 模板发送给代表。</li><li>代理将 JSON 响应转发给管理器。</li><li>管理器将 ARM 模板保存到 MongoDB。</li></ul><figure class="w-richtext-figure-type-image w-richtext-align-center"/><p><br/>如果机械臂展开过程中出现故障:</p><ul role="list"><li>管理器发送一个查询，在执行开始前保存 JSON 模板。</li><li>管理器使用当前执行 ID 获取现有模板。</li><li>经理将新的 ARM 部署任务发送给代表。</li><li>委托在完整模式下使用现有的 ARM 模板运行新的部署。</li><li>代理轮询部署状态。</li><li>部署状态会定期从代表处接收，并显示在 UI 上。</li></ul><h2>结论</h2><p>我们关于 Harness 基础设施供应器和 ARM 模板的博客系列到此结束。</p><p>在这篇文章中，我们学习了在 ARM 模板中使用 Harness 变量，以及 Harness 如何提供回滚支持。</p><p>要了解基础知识，请随时参考本系列的第一篇<a href="https://harness.io/blog/continuous-delivery/arm-templates-pt1/">博客。有兴趣了解更多信息吗？</a><a href="https://harness.io/demo/">安排今天的演示</a>。</p></div></div>    
</body>
</html>