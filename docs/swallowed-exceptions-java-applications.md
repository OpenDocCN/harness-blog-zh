# 吞下的异常:Java 应用程序的无声黑仔

> 原文：<https://www.harness.io/blog/swallowed-exceptions-java-applications>

在这篇文章中，我们的目标是看看如何避免错误处理的风险。

这个会有点吓人。毕竟，我们面对的是一个致命的杀手。和一些讨厌的日志文件。所以抓紧你们的座位！我们将涵盖立即和可操作的建议，用于一劳永逸地停止被吞咽的异常。

在这篇文章中，我们的目标是看看如何避免错误处理的风险，我们将通过理解被吞异常的负面影响并学习如何修复它们来做到这一点。

我们将调查并找到 Java 应用程序的无声杀手。希望我们在做这件事的时候也能得到乐趣！

是时候找出答案了。

## 释放日焦虑

这个场景可能感觉很熟悉。不幸的是。

新的错误在发布日不断出现，你试图尽快处理它们。

调查已经开始，时间紧迫。发布日引发焦虑是有原因的。我们希望至少这不是一个星期五。星期五下午 5 点。

假设我们知道我们的应用程序有问题，因为我们收到了很多来自用户的投诉，或者一些业务指标正在下降，现在我们需要调查发生了什么。这里有一个最近的例子，当一个可靠性故事成为新闻时，这可能会是什么样子。

我们需要查看大量的非结构化数据，试图理解这个日志文件对我们隐藏的故事，这可能会是一个乏味的手动过程。在这个特殊的例子中，我们看到一个文件，其中包含调试和信息级语句。但是在生产中，我们通常只打开 WARN 和 above。事实上，我们发现关于⅔的日志数据在生产中被停用，您可以在这里了解更多信息。

即使您使用的是日志管理工具，而不依赖于在控制台上浏览，它在一个更好的界面中基本上是相同的日志数据。

当在很大一部分最终用户受到负面影响之前就知道存在问题时，这尤其令人痛苦。外面的噪音太多了，以至于无法理解什么是重要的。

在对日志文件进行初步挖掘之后，我们发现有些事情感觉不太对劲。还没有线索。现在看来更像是猜测。

有什么比在嘈杂的日志文件中寻找生产错误的根本原因更有压力的呢？没太多事。好吧，也许有一件事会让整个情况变得更糟。

如果…我们要找的错误甚至不在日志中呢？

我们要抓的沉默杀手逃走了，没有在日志里留下任何线索。但我们仍然需要找出是什么导致了这一切。

“无法繁殖”不是我们可以接受的答案。当这意味着伤害顾客和损失收入时，就不能。

一定有更好的方法来解决这个问题。回到绘图板。

现在我们已经看到了隐藏错误的负面影响，让我们看看它是如何与异常联系起来的。为了深入研究，我们想仔细看看开发人员在异常捕捉块中做了什么。我们查看了滑铁卢大学最近的一篇研究论文，该论文使用 Github 的海量 Java 数据集来研究这个问题:

“Java 项目中异常处理模式的分析:实证研究”，原始研究可以在这里访问，我们还发布了一个分析来回顾结果，您可以快速通读以获得要点。

这项研究观察了超过 50 万个 Java 项目，包括 1600 万个 catch 块，并将它们分成组。

## 开发人员在异常捕获块中做什么？

我们看到它基本上分为 3 组:

1.  通过日志记录、打印堆栈跟踪或将信息打印到控制台来记录所发生的事情。
2.  重新抛出一个异常，这可能是一个更广泛的抽象，调用堆栈中更高层的方法知道如何处理它。
3.  还有…..不幸的是…没什么。一个空街区。不着痕迹地吞下了异常。而且看起来它甚至发生的频率至少和记录它的频率一样。这…至少可以说是相当惊人的。

嘣！失败了。被吞咽的异常是导致错误被忽视的主要因素。我们找到凶手了。

有时开发人员选择忽略异常，而不是通过记录错误或警告来做正确的事情。这可能会发生，要么是因为他们认为这不会发生，要么就是完全忽视它，试图压制和隐藏它。

快速回顾一下我们到目前为止所讲的内容，我们看到:

*   在不可预见的情况下排除错误极其困难，会对用户产生严重影响。
*   大约 20%的错误从未被记录到日志中。
*   被吞的异常在空的 catch 块中被捕获。

## 未来应该改变什么？

既然我们已经理解了被吞异常的负面影响，那么让我们来谈谈需要做些什么来解决它们。

### 1.代码审查指南

基础优先。可能是时候更新一些代码审查指南了。确保在未来的部署中没有空的 catch 块，没有理由忽视适当的异常处理。

### 2.日志重构

这一条可能有点说起来难，做起来容易，因为这意味着要深入研究遗留代码。更新现有代码以包含有意义的日志记录语句，并尝试找出那些空的 catch 块可能意味着什么。

实施这两个解决方案并发现所有空 catch 块的一个方法是确保在您的 IDE 中打开代码风格的检查。以下是它在 IntelliJ 中的样子:

设置->检查->错误处理->空的“catch”块

### 3.连续可靠性

我们自己使用的另一种方法是实施连续可靠性和自动化根本原因分析。无论是否包含异常，都存在如此多的错误条件，以至于不可能预测所有的错误条件，更不用说知道记录哪些数据以便将来对它们进行故障排除了。

我们需要比以往任何时候都更加敏捷，这并不意味着我们可以灵活处理生产中松散运行的易错代码。要了解它在生产和生产前环境中的工作原理，请亲自尝试或向我们的解决方案专家请求演示。

## 最后的想法

现在是 2018 年。让我们让隐藏异常成为过去。不再有空的 catch 块，也不再有未知的错误。我们描述的场景听起来熟悉吗？您是否有过其他吞咽异常的经历？请在下面的评论区告诉我们！