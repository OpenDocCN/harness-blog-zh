<html>
<head>
<title>Setting Up a Software Development Environment on Alpine Linux | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Alpine Linux | Harness上设置软件开发环境</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/setting-up-a-software-development-environment-alpine-linux#0001-01-01">https://www.harness.io/blog/setting-up-a-software-development-environment-alpine-linux#0001-01-01</a></blockquote><div><p>在这篇文章中，我将讲述我为C++和Java开发设置Alpine Linux工作站的经验，以及一些有用的Alpine知识、技巧和资源。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>无论您是从事软件开发、DevOps还是测试工程，如果您有一些Docker的工作经验，您很可能已经熟悉了Alpine Linux。</p><p>Alpine在最近几年很受欢迎，现在可能是码头工人最喜欢的Linux。它最初是为路由器设计的，是一个安全、快速、轻量级的Linux:一个基本的Alpine基础映像只需要5 MB，比其他流行的Linux发行版少几个数量级(相比之下，Ubuntu是188 MB)。这一事实使它成为Docker图像的基础系统的理想选择，在这种情况下，小尺寸是可取的，特别是对于OpenJDK Docker图像，否则会占用数百MB。</p><p>我是一个狂热的Linux粉丝，喜欢尝试新的环境，所以当我负责将OverOps代理移植到本地Alpine Linux时，我非常兴奋！但是在开始任何实际的移植工作之前，我必须为自己设置一个合适的Alpine开发环境。</p><p>在这篇文章中，我将讲述我为C++和Java开发设置Alpine Linux工作站的经验，以及一些有用的Alpine知识、技巧和资源。</p><h2>那么，Alpine Linux给你带来了什么？</h2><p>首先，我们来看一下Alpine Linux的主要特性。</p><p>项目主页很好地总结了这一点:“Alpine Linux是一个独立的、非商业的、通用的Linux发行版，是为重视安全性、简单性和资源效率的高级用户设计的。”</p><p>最显著的安全特性是一个加固的、专门打了补丁的Linux内核。</p><h3>饼图可执行文件。</h3><p>所有Alpine可执行文件都是作为独立于位置的可执行文件构建的，它们的正确操作不依赖于绝对内存地址，就像共享库一样。此类可执行文件受地址空间布局随机化(ASLR)的约束，这是一种内核在随机内存位置之间动态转移程序的技术，有助于防止某些类型的攻击。</p><h3>堆叠粉碎保护</h3><p>这个特性在所有Alpine二进制文件中都实现了，它允许堆栈溢出的程序优雅地退出，而不是可怕地崩溃。它通常是通过使用特殊的C/C++编译器选项(-fstack-protector-fstrong)构建来实现的，该选项向程序代码添加了堆栈金丝雀。这些是编译器生成的变量，标记每个函数中分配的堆栈帧的结束，当被覆盖时，指示堆栈溢出，麻烦就在前面，很像“煤矿中的金丝雀”。</p><h3>“少即是多”</h3><p>虽然Alpine本身并不是一个特性，但是它的极简特性也使得它更安全，更不容易受到攻击，因为它几乎不携带额外的行李，因此可能的攻击面要小得多，特别是与其他Linuxes相比。不幸的是，与任何其他系统一样，它不是100%防弹的，正如最近发现并修复的漏洞所揭示的那样。</p><p>因此，Alpine尽可能地安全，但是它的小内存占用是它与其他Linuxes的真正区别。它是围绕两个组件构建的，这使得它特别紧凑。</p><h3>巴布克斯</h3><p>Busybox是一个多合一、多用途的二进制文件。它的作者将其命名为“嵌入式Linux的瑞士军刀”，它为许多标准程序提供了核心功能，如awk、cp、grep、gzip、sh和top。所有程序都用符号链接到/bin/busybox，它根据程序执行时使用的名称来标识要运行的程序。它提供了与GNU对等物的高度兼容性，通常具有减少的特性集，但不用担心——您通常可以通过安装相同名称的包(如grep或tar)或捆绑包(如coreutils)来获得完整的GNU功能。</p><p>Busybox对Alpine的小尺寸非常重要——使用单个静态二进制文件减少了多个可执行文件的开销，并允许生成的二进制文件得到有效的大小优化。在Alpine 3.8上，它被压缩到只有780 KB的优度。</p><h3>音乐图书馆。</h3><p>musl libc库是GNU的libc库glibc的一个紧凑和引人注目的替代，glibc是大多数Linux发行版中使用的事实上的libc实现。与glibc相比，musl的大小很小:它在Alpine 3.8上只有572 KB，相比之下，例如glibc在Ubuntu 16.04上的大小为3mb(3mb是libc.so和libm.so的大小之和；在阿尔卑斯山中，libm.so与musl.so符号相连。但是，musl比它的小尺寸更重要:它提供了更严格的POSIX一致性、更好的安全性和更具竞争力的性能。musl的作者ETA labs提供的这张对比图，非常详细地描述了libc实现之间的差异，并强调了musl的优势。</p><p>遗憾的是，这里有一个问题:将musl作为默认的libc实现会引入一个与其他基于glibc的Linuxes的兼容性问题。几乎任何Linux程序都与libc动态链接，而glibc Linux二进制文件将与libc.so链接，Alpine二进制文件将与musl.so链接。因此，构建在glibc发行版(如Ubuntu和RedHat)上的Linux可执行文件将无法在Alpine上运行，至少不能开箱即用。</p><h2>阿尔卑斯山还有什么？</h2><p>一个简洁的包管理器，叫做apk。如果你已经熟悉apt包管理器，那就不要习惯apk:基本的命令是add、del、search和update，你可以开始了。如果你写过Alpine Dockerfiles，你应该已经对apk相当了解了。</p><p>Alpine中默认的shell是busybox提供的ash。和Alpine中的任何东西一样，它也非常简洁，缺少一些shell的便利特性，比如自动完成。如果您像我一样喜欢bash，只需安装bash apk包，并将其用作默认shell。</p><h2>让我们安装阿尔卑斯山</h2><p>因此，在四处搜寻之后，是时候开始建立一个高山工作环境了。但是应该是什么环境呢？</p><h2>Docker还是工作站？</h2><p>在我看来，有两个选择:第一，在我的开发工作中使用Alpine Docker，第二，在我的笔记本电脑上建立一个合适的Alpine工作站。这是我第一次真正接触Docker，所以我不确定我是否应该朝那个方向深入，因为我想快速地站起来并运行。</p><p>此外，在那一点上，我认为Docker本质上是一个可任意使用的环境，对于日常开发来说可能并不理想(只是后来我才意识到Docker对于这一目的也很有用)。Alpine工作站选项似乎更有吸引力，但是我也没有使用Alpine的经验，我不确定它对于开发来说有多舒适；有了Docker选项，至少我还有Ubuntu桌面可以使用。</p><p>最后，我选择了第二个选项，并匆忙在我已经双启动的Ubuntu-Windows戴尔XPS 15上安装了Alpine。</p><h2>安装阿尔卑斯Linux</h2><p>我兴高采烈地前往阿尔卑斯山下载页面。它提供了最新的Alpine版本(在撰写本文时是3.8.1)，有8种不同的ISO版本。事实证明，Alpine几乎可以在任何东西上运行，从服务器、dockers和虚拟机，到嵌入式ARM设备和Raspberry Pi。对于x86_64映像，我在“标准”和“扩展”之间进行了考虑。由于我的目标是一个成熟的桌面环境，我认为Extended会是一个更好的起点(后来证明是正确的),于是我点击了下载按钮。阿尔卑斯ISO–检查。</p><p>现在真正有趣的部分来了——安装时间！谷歌搜索到的第一个“安装alpine”是Alpine Linux Wiki上的安装页面。维基是一个不可思议的信息来源，几乎包含了所有关于阿尔卑斯山的信息。高山团队的工作真的很棒。</p><p>如安装页面所述，Alpine可以三种不同的模式安装:</p><ol role="list"><li>无盘模式–在这种模式下，Alpine从安装介质(如CD或u盘)启动，并加载到RAM中。没有数据写入磁盘，会话在重新启动时被丢弃。</li><li>数据模式—类似于无盘，但/var文件夹装载到可写介质上，在重新引导之间保持不变。</li><li>Sys模式–传统的硬盘安装。</li></ol><p>很明显，选项3是最适合我的。因此，我在Ubuntu上按照以下步骤安装Alpine:</p><ol role="list"><li>创建了一个可启动的阿尔卑斯山安装USB(指南)；</li><li>使用gparted收缩我现有的卷，为新的Alpine分区腾出空间，并将其格式化为ext4</li><li>将Alpine系统复制到新分区(指南)；</li><li>通过运行update-grub2，重新生成了我的GRUB菜单项；</li><li>调整了GRUB条目，允许引导到Alpine(见下文)。</li></ol><p>大概就是这样。只需几个小时的工作，我现在就可以登录到我全新的Alpine Linux系统，三重启动Ubuntu和Windows…太棒了！</p><h2>GRUB调整</h2><p>不过，食物部分有点棘手。安装Alpine并更新GRUB后，出现了一个新的菜单项:“未知Linux发行版(on /dev/nvme0n1p9)”。乐观地说，我点击了它，但是没有预期的“欢迎来到Alpine”提示，在启动几秒钟后，我得到了一个内核恐慌…呀！</p><p>我做了一些实验来找出问题所在:我没有为我的文件系统加载合适的内核模块，特别是ext4，update-grub2也没有做到这一点。因此，我使用Ubuntu GRUB条目作为起点，并将以下菜单项放在/etc/grub.d下的一个新文件中:</p><h6>Alpine(和其他Linuxes)的GRUB条目示例。<br/> #将[my-uuid]和[my-partition]替换为以root用户身份运行的“blkid”输出的正确值。<br/>T3】menu entry " Alpine Linux " {<br/>search-no-floppy-fs-uuid-set = root[my-uuid]<br/>Linux/boot/vmlinuz-vanilla root =【my-partition】modules = SD-mod，usb-storage，ext 4<br/>initrd/boot/initramfs-vanilla<br/>}</h6><h2>开始使用Alpine</h2><p>现在我已经能够成功地引导到Alpine，是时候进行一些基本的设置步骤了。</p><h2>连接到Wi-Fi</h2><p>首先，我需要一个正常工作的互联网连接。</p><p>我的笔记本电脑没有有线网络插座，我的USB RJ45适配器也坏了，所以我唯一的选择就是Wi-Fi。这个Alpine Wiki页面“连接到无线接入点”非常清楚地描述了Wi-Fi设置过程，因此我很快就能够连接到我的工作Wi-Fi网络(具体来说，我遵循了“手动配置”步骤)。</p><p>要在Alpine上开始使用Wi-Fi，需要安装两个基本软件包:wireless-tools和wpa_supplicant。事实证明，我对扩展ISO的押注得到了回报:与标准ISO相比，它在其离线apk数据库中包含了这些包。这省去了我用一个同事的电脑从Alpine packages目录下载这些包的麻烦(顺便说一句，非常棒！)，将它们复制到u盘，安装到Alpine并安装。手动创建apk文件。</p><p>现在我有了网络连接，我可以更新apk存储库索引并安装一些便利的包，比如bash、coreutils和nano。</p><p>已经有家的感觉了！</p><h2>准备构建环境</h2><p>在这一点上，我有了一个不错的Alpine命令行，所以我可以准备构建环境了。</p><p>与Ubuntu的build-essential类似，build-base元包是安装最常见的构建工具和实用程序(包括g++、make和binutils)的良好起点。为了构建我们的C++栈，我需要其他几个包，包括cmake和linux头文件。</p><p>有些C++项目只兼容某些编译器版本，具体来说，Alpine 3.8附带了gcc 6.4.0。据我所知，官方的Alpine资源库不包含以前的主要gcc版本，所以如果您需要Alpine上的不同gcc版本，您可以在musl-cross-make项目页面找到它(或兼容版本): https://github . com/just-containers/musl-cross-make/releases。我亲自测试过gcc 4.9.4，效果非常好。这些人做得很好，这对一些人来说可能是真正的救命稻草。</p><p>接下来，安装Java。官方的阿尔卑斯JDK实现是OpenJDK，由OpenJDK IcedTea项目带给我们。OpenJDK版本7和8是可用的，可以从Alpine apk库下载。不幸的是，目前还没有Java 9、10和11的GA版本(请参见project Portola主页和github的当前状态讨论)。目前，我对openjdk8包很满意。</p><p>最后，我期待着激烈的调试，并安装了gdb和strace，以及musl和OpenJDK调试符号，它们分别位于musl-dbg和openjdk8-dbg包中。来吧，阿尔卑斯山！</p><p>提示:对于最新的edge包，您可能希望将edge存储库添加到/etc/apk/repositories文件中，如包管理页面中所述。例如，lldb目前仅在edge中可用。然而，边缘包是实验性的，所以要小心使用。</p><h2>安装桌面和IDE</h2><p>我必须承认，我第一次把Alpine想象成一个奇特的命令行环境，甚至没有看到自己使用鼠标，所以我很高兴了解到Alpine也是一个有能力的桌面环境！</p><p>Alpine有多种桌面可供选择，包括GNOME、MATE和Xfce。我对Xfce还不熟悉，所以我决定试一试。一如既往，Alpine Wiki是一个很好的起点。“Xfce setup”页面详细介绍了安装和启动Xfce所需的所有步骤。最重要的是，要安装的包是xfce 4——桌面本身，以及alpine-desktop。后者是一个非常全面的元包，提供默认的Alpine桌面体验，包括Firefox web浏览器、AbiWord编辑器、Audacious声音播放器等。</p><p>提示:不要忘记安装一个字体包，比如font-noto。否则，你将会看到奇怪的空白方块，一些GUI应用程序可能会崩溃或运行不正常。这花了我相当多的时间才弄明白！</p><p>我的Alpine难题中缺少的最后一块是为C/C++和Java开发找到合适的ide。在这里，musl-glibc兼容性问题变得非常棘手。例如，找不到与musl兼容的Eclipse CDT版本，所以没有glibc兼容层，就不可能在Alpine上运行Eclipse。我对命令行很满意，但是我真的希望手边有一个合适的IDE，特别是用于调试。</p><p>幸运的是，我们有JetBrains IDE家族。来自JetBrains的IntelliJ、CLion和其他ide都运行在JVM上，并不直接依赖于底层的libc实现。由于OpenJDK JVM与musl完全兼容，任何标准的Java应用程序都应该可以开箱即用，IntelliJ和CLion也是如此。我是IntelliJ的忠实粉丝，所以我很高兴看到它在Alpine上也工作得很好。真是松了一口气！</p><p>值得注意的是，虽然IntelliJ的社区版对每个人都是免费的，但CLion只有30天的评估期是免费的(尽管学生可以申请免费的学术许可证)。现在，这就足够了。</p><p>就这样，我已经设置好了我的Alpine桌面环境！</p><h2>摘要</h2><p>由于在容器中的广泛使用，Alpine已经成为最重要的Linux发行版之一。虽然它的核心非常纤薄和简约，但它可以很容易地与我们熟悉的其他流行Linux发行版的大多数程序和功能堆叠在一起。经过一些努力，Alpine安装可以变成一个合适的桌面环境，没有什么可羞愧的。</p><p>然而，阿尔卑斯山有一个学习曲线，所以它肯定不适合每个人。因为它的用户群相对较小，所以可用的兼容软件较少，而且你可能会发现musl Alpine还不支持需求包。Alpine附带了优秀的文档，但另一方面，故障排除资源和讨论要少得多(想想StackOverflow)，所以您可能最终不得不自己诊断和解决问题。</p><p>总的来说，Alpine有很多很棒的东西，我目前很乐意为它工作。希望你也会！</p><h3>奖励–Alpine 3.8 IntelliJ docker文件</h3><p>几周后，随着我对docker越来越熟悉，我开始熟悉数据卷，这对于在主机和Docker容器之间共享文件夹很有用。我还了解到，如果设置得当，Docker也能愉快地运行GUI应用程序。</p><p>因此，本质上，整个Alpine构建和桌面环境可以封装在一个可重用的Docker映像中，我们的项目源代码可以与Docker共享，并用于Alpine容器上的开发。</p><p>所以，事不宜迟，这里有一个Alpine 3.8 Dockerfile，带有IntelliJ Community edition +前面提到的工具和实用程序。虽然不完美或不完整，但这张图片可能是您自己的Alpine dockered桌面的良好起点。要运行映像并启动IntelliJ，请遵循docker文件顶部的说明。通过授予Docker对主机X11服务器的访问权限来启用GUI。</p><p>尽情享受吧！</p><p>GitHub上Dockerfile的链接:https://GitHub . com/shah ARV/docker/blob/master/alpine/dev/docker file</p></div></div>    
</body>
</html>