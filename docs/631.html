<html>
<head>
<title>Benchmark: How Misusing Streams Can Make Your Code 5 Times Slower | Harness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>基准测试:误用流如何让你的代码慢5倍</h1>
<blockquote>原文：<a href="https://www.harness.io/blog/misusing-streams-make-code-slower#0001-01-01">https://www.harness.io/blog/misusing-streams-make-code-slower#0001-01-01</a></blockquote><div><p>流是Java 8中一个令人兴奋的特性，但是在使用时需要小心。</p><div fs-richtext-element="rich-text" class="blog-rtf w-richtext"><p>与长期实现相比，Java 8 lambdas和streams的性能如何？</p><p>Lambda表达式和流在Java 8中受到了热烈欢迎。这些是很长一段时间以来Java中最令人兴奋的特性。新的语言特性允许我们在代码中采用功能性更强的风格，我们从中获得了很多乐趣。太有趣了，这应该是非法的。后来我们起了疑心，决定对他们进行测试。</p><p>我们做了一个简单的任务，在数组列表中寻找最大值，并测试了长期实现和Java 8中的新方法。老实说，结果相当令人惊讶。<em> ‍ </em></p><h2>Java 8中命令式与函数式编程的比较</h2><p>我们喜欢开门见山，所以让我们看看结果。对于这个基准测试，我们创建了一个ArrayList，用100，000个随机整数填充它，并实现了7种不同的方法来遍历所有的值以找到最大值。实现分为两组:函数式风格和命令式风格，前者包含Java 8中引入的新语言特性，后者包含由来已久的Java方法。<br/></p><h2>外卖食品</h2><ol role="list"><li>哎呦！用Java 8提供的任何新方法实现一个解决方案都会导致大约5倍的性能损失。有时使用一个简单的循环和迭代器比混合使用lambdas和streams要好。即使这意味着多写几行代码，跳过那些甜蜜的语法。</li><li>使用迭代器或for-each循环是遍历数组列表最有效的方法。比索引为int的传统for循环好两倍。</li><li>在Java 8方法中，使用并行流被证明是更有效的。但是要小心，在某些情况下，它可能会降低你的速度。</li><li>Lambas在流和parallelStream实现之间占据了它们的位置。这有点令人惊讶，因为它们的实现是基于流API的。</li><li><strong>【EDIT】事情并不总是像看起来那样:</strong>虽然我们想展示在lambdas和streams中引入错误是多么容易，但我们收到了许多社区反馈，要求对基准代码进行更多优化，并删除整数的装箱/取消装箱。包括优化在内的第二组结果可以在这篇文章的底部找到。</li></ol><h2>等等，我们到底测试了什么？</h2><p>让我们从最快到最慢的顺序快速浏览一下每种方法:</p><h3>命令式风格</h3><p><strong>iteratorMaxInteger()</strong>–用迭代器遍历列表:<br/><br/><strong>【forEachLoopMaxInteger()</strong>–丢失迭代器，用<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/language/foreach.html" target="_blank"> For-Each循环遍历列表</a>(不要和Java 8 forEach混淆):<br/><br/><strong>forMaxInteger()</strong>–用简单的For循环和int索引遍历列表:<br/></p><h3>功能风格</h3><p><strong>parallelStreamMaxInteger()</strong>–在并行模式下使用Java 8流检查列表:<br/><br/><strong>【lambdaMaxInteger()</strong>–使用流的lambda表达式。甜蜜的一行程序:<br/><br/><strong>forEachLambdaMaxInteger()</strong>——这个对于我们的用例来说有点乱。新的Java 8 forEach特性最令人讨厌的地方可能是它只能使用final变量，所以我们创建了一个final包装类来访问我们正在更新的最大值:顺便说一下，如果我们已经在谈论forEach，请查看我们遇到的这个StackOverflow答案，它提供了一些关于它的一些缺点的有趣见解。<br/><strong>streamMaxInteger()</strong>–使用Java 8流查看列表:<br/></p><h2>优化基准</h2><p>根据这篇文章的反馈，我们创建了另一个版本的基准。所有与原始代码的不同之处都可以在这里看到<a href="https://github.com/takipi/loops-jmh-playground/commit/d91c55aee2d480c31fa7fad72f6f0b94fb59612e">。</a></p><h3>TL；DR:变更摘要</h3><ol role="list"><li>这份名单不再是不稳定的。</li><li>新方法forMax2移除了字段访问。</li><li>forEachLambda中冗余的helper函数是固定的。现在lambda也赋值了。可读性较差，但速度更快。</li><li>自动装箱被取消。如果在Eclipse中打开项目的自动装箱警告，旧代码有15个警告。</li><li>通过在reduce之前使用mapToInt修复了流代码。</li></ol><p>感谢<a href="https://github.com/reinhapa" target="_blank">帕特里克·莱因哈特</a>、<a href="https://github.com/RichardWarburton" target="_blank">理查德·沃伯顿</a>、<a href="https://github.com/ybonnel" target="_blank">燕·邦纳</a>、<a href="https://twitter.com/kuksenk0" target="_blank">谢尔盖·库先科</a>、<a href="https://github.com/jmax01" target="_blank">杰夫·马克斯韦尔</a>、<a href="https://github.com/gsson" target="_blank">亨里克·古斯塔夫松</a>以及所有在推特上发表评论和做出贡献的人！</p><h2>基础工作</h2><p>为了运行这个基准测试，我们使用了Java微基准测试工具JMH。</p><p>基准配置包括JVM的2个分支、5次预热迭代和5次测量迭代。测试在一个c3.xlarge Amazon EC2实例(4个vCPUs，7.5个Mem (GiB)，2个40 GB SSD存储)上运行，使用Java 8u66和JMH 1.11.2。GitHub 上有完整的源代码<a href="https://github.com/takipi/loops-jmh-playground/blob/master/src/main/java/com/takipi/oss/benchmarks/jmh/loops/LoopBenchmarkMain.java" target="_blank">，你可以在这里</a>查看原始结果输出<a href="http://pastebin.com/fB1jirqU" target="_blank">。</a></p><p>尽管如此，一个小小的免责声明:基准测试往往是相当危险的，而且要做到正确是非常困难的。虽然我们试图以最准确的方式运行它，但我们总是建议对结果有所保留。</p><h2>最后的想法</h2><p>当你使用Java 8时，首先要做的是尝试lambda表达式和流。但是要小心:这感觉真的很好很甜，所以你可能会上瘾！我们已经看到，使用迭代器和for-each循环坚持更传统的Java编程风格明显优于Java 8提供的新实现。当然，情况并不总是如此，但在这个相当常见的例子中，它显示情况可能会糟糕5倍左右。如果它影响了系统的核心部分或者产生了新的瓶颈，这可能会变得非常可怕。</p></div></div>    
</body>
</html>